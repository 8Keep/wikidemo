(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{153:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return p}));var a=n(1),r=n(9),o=(n(0),n(441)),i={},l={id:"jme3/advanced/jme3_shaders",title:"jme3_shaders",description:"Shaders Basics",source:"@site/docs/jme3/advanced/jme3_shaders.md",permalink:"/wikidemo/docs/jme3/advanced/jme3_shaders",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/advanced/jme3_shaders.md"},s=[{value:"How Does it work?",id:"how-does-it-work",children:[]},{value:"Variables scope",id:"variables-scope",children:[]},{value:"Spaces and Matrices",id:"spaces-and-matrices",children:[]},{value:"Simple example: rendering a solid color on an object",id:"simple-example-rendering-a-solid-color-on-an-object",children:[]},{value:"JME3 Global uniforms",id:"jme3-global-uniforms",children:[]},{value:"JME3 Lighting Global uniforms",id:"jme3-lighting-global-uniforms",children:[]},{value:"JME3 attributes",id:"jme3-attributes",children:[]},{value:"User&#39;s uniforms",id:"users-uniforms",children:[]},{value:"Example: Adding Color Keying to the Lighting.j3md Material Definition",id:"example-adding-color-keying-to-the-lightingj3md-material-definition",children:[]},{value:"Step by step",id:"step-by-step",children:[]},{value:"JME3 and OpenGL 3 &amp; 4 compatibility",id:"jme3-and-opengl-3--4-compatibility",children:[]},{value:"Useful links",id:"useful-links",children:[]}],c={rightToc:s};function p(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h1",{id:"shaders-basics"},"Shaders Basics"),Object(o.b)("p",null,"Shaders are sets of instructions that are executed on the GPU. They are\nused to take advantage of hardware acceleration available on the GPU for\nrendering purposes."),Object(o.b)("p",null,"This paper only covers Vertex and Fragment shaders because they are the\nonly ones supported by JME3 for the moment. Be aware that there are some\nother types of shaders (geometry, tessellation,...)."),Object(o.b)("p",null,"There are multiple frequently used languages that you may encounter to\ncode shaders but as JME3 is based on OpenGL, shaders in JME use GLSL and\nany example in this paper will be written in GLSL."),Object(o.b)("h2",{id:"how-does-it-work"},"How Does it work?"),Object(o.b)("p",null,"To keep it Simple: The Vertex shader is executed once for each vertex in\nthe view, then the Fragment shader (also called the Pixel shader) is\nexecuted once for each pixel on the screen."),Object(o.b)("p",null,"The main purpose of the Vertex shader is to compute the screen\ncoordinate of a vertex (where this vertex will be displayed on screen)\nwhile the main purpose of the Fragment shader is to compute the color of\na pixel."),Object(o.b)("p",null,"This is a very simplified graphic to describe the call stack:"),Object(o.b)("p",null,Object(o.b)("img",Object(a.a)({parentName:"p"},{src:"/images/jme3/advanced/jme3andshaders.png",alt:"jme3andshaders.png"}))),Object(o.b)("p",null,"The main program sends mesh data to the vertex shader (vertex position\nin object space, normals, tangents, etc..). The vertex shader computes\nthe screen position of the vertex and sends it to the Fragment shader.\nThe fragment shader computes the color, and the result is displayed on\nscreen or in a texture."),Object(o.b)("h2",{id:"variables-scope"},"Variables scope"),Object(o.b)("p",null,"There are different types of scope for variables in a shader:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"uniform: User defined variables that are passed by the main program\nto the vertex and fragment shader, these variables are global for a\ngiven execution of a shader.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"attribute: Per-vertex variables passed by the engine to the shader,\nlike position, normal, etc (Mesh data in the graphic)")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"varying: Variables passed from the vertex shader to the fragment\nshader."))),Object(o.b)("p",null,"There is a large panel of variable types to be used, for more\ninformation about it I recommend reading the GLSL specification\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://www.opengl.org/registry/doc/GLSLangSpec.Full.1.20.8.pdf"}),"here"),"."),Object(o.b)("h2",{id:"spaces-and-matrices"},"Spaces and Matrices"),Object(o.b)("p",null,"To understand the coming example you must know about the different\nspaces in 3D computer graphics, and the matrices used to translate\ncoordinate from one space to another."),Object(o.b)("p",null,Object(o.b)("img",Object(a.a)({parentName:"p"},{src:"/images/jme3/advanced/jme3andshaders-1.png",alt:"jme3andshaders-1.png"}))),Object(o.b)("p",null,"The engine passes the object space coordinates to the vertex shader. We\nneed to compute its position in projection space. To do that we\ntransform the object space position by the WorldViewProjectionMatrix,\nwhich is a combination of the World, View, Projection matrices (who\nwould have guessed?)."),Object(o.b)("h2",{id:"simple-example-rendering-a-solid-color-on-an-object"},"Simple example: rendering a solid color on an object"),Object(o.b)("p",null,"Here is the simplest application to shaders, rendering a solid color."),Object(o.b)("p",null,"Vertex Shader:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"//the global uniform World view projection matrix\n//(more on global uniforms below)\nuniform mat4 g_WorldViewProjectionMatrix;\n//The attribute inPosition is the Object space position of the vertex\nattribute vec3 inPosition;\nvoid main(){\n    //Transformation of the object space coordinate to projection space\n    //coordinates.\n    //- gl_Position is the standard GLSL variable holding projection space\n    //position. It must be filled in the vertex shader\n    //- To convert position we multiply the worldViewProjectionMatrix by\n    //by the position vector.\n    //The multiplication must be done in this order.\n    gl_Position = g_WorldViewProjectionMatrix * vec4(inPosition, 1.0);\n}\n")),Object(o.b)("p",null,"Fragment Shader :"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"void main(){\n    //returning the color of the pixel (here solid blue)\n    //- gl_FragColor is the standard GLSL variable that holds the pixel\n    //color. It must be filled in the Fragment Shader.\n    gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\n}\n")),Object(o.b)("p",null,"For example applying this shader to a sphere would render a solid blue\nsphere on screen."),Object(o.b)("h1",{id:"how-to-use-shaders-in-jme3"},"How to use shaders in JME3"),Object(o.b)("p",null,'You probably heard that JME3 is "shader oriented", but what does that\nmean?\\\nUsually, to use shaders you must create a program. This program\nspecifies the vertex shader and the fragment shader to use. JME3\nencloses this in the material system. Every material in JME3 uses\nshaders.'),Object(o.b)("p",null,"For example let's have a look at the SolidColor.j3md file :"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"MaterialDef Solid Color {\n    //This is the complete list of user defined uniforms to be used in the\n    //shaders\n    MaterialParameters {\n        Vector4 Color\n    }\n    Technique {\n        //This is where the vertex and fragment shader files are\n        //specified\n        VertexShader GLSL100:   Common/MatDefs/Misc/SolidColor.vert\n        FragmentShader GLSL100: Common/MatDefs/Misc/SolidColor.frag\n        //This is where you specify which global uniform you need for your\n        //shaders\n        WorldParameters {\n            WorldViewProjectionMatrix\n        }\n    }\n    Technique FixedFunc {\n    }\n}\n")),Object(o.b)("p",null,"For more information on JME3 material system, I suggest you read\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://hub.jmonkeyengine.org/t/jmonkeyengine3-material-system-full-explanation/12947"}),"jMonkeyEngine3 material system - full\nexplanation"),"."),Object(o.b)("h2",{id:"jme3-global-uniforms"},"JME3 Global uniforms"),Object(o.b)("p",null,"JME3 can expose pre-computed global uniforms to your shaders. You must\nspecify the ones that are required for your shader in the\nWorldParameter's section of the material definition file (.j3md)."),Object(o.b)("p",null,'::: {.note}\nIn the shader, the uniform names will be prefixed by a "g',"_",'".\n:::'),Object(o.b)("p",null,"In the example above, WorldViewProjectionMatrix is declared as uniform\nmat4 g","_","WorldViewProjectionMatrix in the shader."),Object(o.b)("p",null,"The complete list of global uniforms that can be used in JME3 can be\nfound in\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-core/src/main/java/com/jme3/shader/UniformBinding.java"}),"UniformBinding.java"),"."),Object(o.b)("h2",{id:"jme3-lighting-global-uniforms"},"JME3 Lighting Global uniforms"),Object(o.b)("p",null,"JME3 uses some global uniforms for lighting:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"g","_","LightDirection (vec4): the direction of the light"),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"use for SpotLight: x,y,z contain the world direction vector of\nthe light, the w component contains the spotlight angle cosine"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"g","_","LightColor (vec4): the color of the light")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"g","_","LightPosition: the position of the light"),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"use for SpotLight: x,y,z contain the world position of the\nlight, the w component contains 1/lightRange")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"use for PointLight: x,y,z contain the world position of the\nlight, the w component contains 1/lightRadius")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"use for DirectionalLight: strangely enough it's used for the\ndirection of the light...this might change though. The fourth\ncomponent contains -1 and it's used in the lighting shader to\nknow if it's a directionalLight or not.")))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"g","_","AmbientLightColor: the color of the ambient light."))),Object(o.b)("p",null,'These uniforms are passed to the shader without having to declare them\nin the j3md file, but you have to specify in the technique definition "\nLightMode MultiPass see lighting.j3md for more information.'),Object(o.b)("h2",{id:"jme3-attributes"},"JME3 attributes"),Object(o.b)("p",null,"Those are different attributes that are always passed to your shader."),Object(o.b)("p",null,"You can find a complete list of those attribute in the Type enum of the\nVertexBuffer in\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-core/src/main/java/com/jme3/scene/VertexBuffer.java"}),"VertexBuffer.java"),"."),Object(o.b)("p",null,'::: {.note}\nIn the shader the attributes names will be prefixed by an "in".\n:::'),Object(o.b)("p",null,"When the enumeration lists some usual types for each attribute (for\nexample texCoord specifies two floats) then that is the format expected\nby all standard JME3 shaders that use that attribute. When writing your\nown shaders though you can use alternative formats such as placing three\nfloats in texCoord simply by declaring the attribute as vec3 in the\nshader and passing 3 as the component count into the mesh setBuffer\ncall."),Object(o.b)("h2",{id:"users-uniforms"},"User's uniforms"),Object(o.b)("p",null,"At some point when making your own shader you'll need to pass your own\nuniforms."),Object(o.b)("p",null,'Any uniform has to be declared in the material definition file (.j3md)\nin the "MaterialParameters section.'),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"    MaterialParameters {\n        Vector4 Color\n        Texture2D ColorMap\n    }\n")),Object(o.b)("p",null,"You can also pass some define to your vertex/fragment programs to know\nif an uniform as been declared."),Object(o.b)("p",null,"You simply add it in the Defines section of your Technique in the\ndefinition file."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"    Defines {\n        COLORMAP : ColorMap\n    }\n")),Object(o.b)("p",null,"For integer and floating point parameters, the define will contain the\nvalue that was set."),Object(o.b)("p",null,"For all other types of parameters, the value 1 is defined."),Object(o.b)("p",null,"If no value is set for that parameter, the define is not declared in the\nshader."),Object(o.b)("p",null,"Those material parameters will be sent from the engine to the shader as\nfollows, there are setXXXX methods for any type of uniform you want to\npass."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'   material.setColor("Color", new ColorRGBA(1.0f, 0.0f, 0.0f, 1.0f)); // red color\n   material.setTexture("ColorMap", myTexture); // bind myTexture for that sampler uniform\n')),Object(o.b)("p",null,"To use this uniform in the shader, you need to declare it in the .frag\nor .vert files (depending on where you need it). You can make use of the\ndefines here and later in the code: ",Object(o.b)("strong",{parentName:"p"},'Note that the "m',"_"," prefix\nspecifies that the uniform is a material parameter.")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"   uniform vec4 m_Color;\n   #ifdef COLORMAP\n     uniform sampler2D m_ColorMap;\n   #endif\n")),Object(o.b)("p",null,"The uniforms will be populated at runtime with the value you sent."),Object(o.b)("h2",{id:"example-adding-color-keying-to-the-lightingj3md-material-definition"},"Example: Adding Color Keying to the Lighting.j3md Material Definition"),Object(o.b)("p",null,"Color Keying is useful in games involving many players. It consists of\nadding some player-specific color on models textures. The easiest way of\ndoing this is to use a keyMap which will contain the amount of color to\nadd in its alpha channel."),Object(o.b)("p",null,"Here I will use this color map:\\\n",Object(o.b)("img",Object(a.a)({parentName:"p"},{src:"http://wstaw.org/m/2011/10/24/plasma-desktopxB2787.jpg",alt:"<http://wstaw.org/m/2011/10/24/plasma-desktopxB2787.jpg>"})),"\\\nto blend color on this texture:\\\n",Object(o.b)("img",Object(a.a)({parentName:"p"},{src:"http://wstaw.org/m/2011/10/24/plasma-desktopbq2787.jpg",alt:"<http://wstaw.org/m/2011/10/24/plasma-desktopbq2787.jpg>"}))),Object(o.b)("p",null,"We need to pass 2 new parameters to the Lighting.j3md definition,\nMaterialParameters section:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"// Keying Map\nTexture2D KeyMap\n\n// Key Color\nColor KeyColor\n")),Object(o.b)("p",null,"Below, add a new Define in the main Technique section:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"KEYMAP : KeyMap\n")),Object(o.b)("p",null,"In the Lighting.frag file, define the new uniforms:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"#ifdef KEYMAP\n  uniform sampler2D m_KeyMap;\n  uniform vec4 m_KeyColor;\n#endif\n")),Object(o.b)("p",null,"Further, when obtaining the diffuseColor from the DiffuseMap texture,\ncheck if we need to blend it:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"#ifdef KEYMAP\n  vec4 keyColor = texture2D(m_KeyMap, newTexCoord);\n  diffuseColor.rgb = (1.0-keyColor.a) * diffuseColor.rgb + keyColor.a * m_KeyColor.rgb;\n#endif\n")),Object(o.b)("p",null,"This way, a transparent pixel in the KeyMap texture doesn't modify the\ncolor. A black pixel replaces it for the m","_","KeyColor and values in\nbetween are blended."),Object(o.b)("p",null,"A result preview can be seen here:"),Object(o.b)("p",null,Object(o.b)("img",Object(a.a)({parentName:"p"},{src:"http://wstaw.org/m/2011/10/24/plasma-desktopuV2787.jpg",alt:null}))),Object(o.b)("h2",{id:"step-by-step"},"Step by step"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Create a vertex shader (.vert) file")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Create a fragment shader (.frag) file")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Create a material definition (j3md) file specifying the user defined\nuniforms, path to the shaders and the global uniforms to use")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"In your initSimpleApplication, create a material using this\ndefinition, apply it to a geometry")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"That's it!!"))),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'    // A cube\n    Box box= new Box(Vector3f.ZERO, 1f,1f,1f);\n    Geometry cube = new Geometry("box", box);\n    Material mat = new Material(assetManager,"Path/To/My/materialDef.j3md");\n    cube.setMaterial(mat);\n    rootNode.attachChild(cube);\n')),Object(o.b)("h2",{id:"jme3-and-opengl-3--4-compatibility"},"JME3 and OpenGL 3 & 4 compatibility"),Object(o.b)("p",null,"GLSL 1.0 to 1.2 comes with built in attributes and uniforms (ie,\ngl","_","Vertex, gl","_","ModelViewMatrix, etc...). Those attributes are\ndeprecated since GLSL 1.3 (opengl 3), hence JME3 global uniforms and\nattributes."),Object(o.b)("p",null,"Here is a list of deprecated attributes and their equivalent in JME3."),Object(o.b)("p",null,"+-----------------------------------+-----------------------------------+\n| GLSL 1.2 attributes               | JME3 equivalent                   |\n+===================================+===================================+\n| gl","_","Vertex                        | inPosition                        |\n+-----------------------------------+-----------------------------------+\n| gl","_","Normal                        | inNormal                          |\n+-----------------------------------+-----------------------------------+\n| gl","_","Color                         | inColor                           |\n+-----------------------------------+-----------------------------------+\n| gl","_","MultiTexCoord0                | inTexCoord                        |\n+-----------------------------------+-----------------------------------+\n| gl","_","ModelViewMatrix               | g","_","WorldViewMatrix                |\n+-----------------------------------+-----------------------------------+\n| gl","_","ProjectionMatrix              | g","_","ProjectionMatrix               |\n+-----------------------------------+-----------------------------------+\n| gl","_","ModelViewProjectionMatrix     | g","_","WorldViewProjectionMatrix      |\n+-----------------------------------+-----------------------------------+\n| gl","_","NormalMatrix                  | g","_","NormalMatrix                   |\n+-----------------------------------+-----------------------------------+"),Object(o.b)("h2",{id:"useful-links"},"Useful links"),Object(o.b)("p",null,Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://www.eng.utah.edu/~cs5610/lectures/GLSL-ATI-Intro.pdf"}),"http://www.eng.utah.edu/~cs5610/lectures/GLSL-ATI-Intro.pdf")))}p.isMDXComponent=!0},441:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return u}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=r.a.createContext({}),p=function(e){var t=r.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l({},t,{},e)),n},b=function(e){var t=p(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),b=p(n),d=a,u=b["".concat(i,".").concat(d)]||b[d]||h[d]||o;return n?r.a.createElement(u,l({ref:t},c,{components:n})):r.a.createElement(u,l({ref:t},c))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);