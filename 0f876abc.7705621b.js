(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{164:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"metadata",(function(){return l})),a.d(t,"rightToc",(function(){return s})),a.d(t,"default",(function(){return p}));var n=a(1),r=a(9),o=(a(0),a(441)),i={},l={id:"jme3/advanced/jme3_srgbpipeline",title:"jme3_srgbpipeline",description:"Overview",source:"@site/docs/jme3/advanced/jme3_srgbpipeline.md",permalink:"/wikidemo/docs/jme3/advanced/jme3_srgbpipeline",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/advanced/jme3_srgbpipeline.md"},s=[{value:"Implementation",id:"implementation",children:[{value:"Turning Gamma Correction on/off",id:"turning-gamma-correction-onoff",children:[]},{value:"Excluding images from the sRGB pipeline",id:"excluding-images-from-the-srgb-pipeline",children:[]},{value:"ColorRGBA as sRGB",id:"colorrgba-as-srgb",children:[]},{value:"Handling rendered output Gamma Correction with a post process filter",id:"handling-rendered-output-gamma-correction-with-a-post-process-filter",children:[]}]},{value:"Should you use this?",id:"should-you-use-this",children:[]}],c={rightToc:s};function p(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(n.a)({},c,a,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h1",{id:"overview"},"Overview"),Object(o.b)("p",null,'Here is a quick overview of what lies under the "Gamma Correction term.\\\nMore in depth rundowns on the matter can be found here :\n',Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"http://http.developer.nvidia.com/GPUGems3/gpugems3_ch24.html"}),"http://http.developer.nvidia.com/GPUGems3/gpugems3_ch24.html")," and here\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"http://www.arcsynthesis.org/gltut/Texturing/Tutorial%2016.html"}),"http://www.arcsynthesis.org/gltut/Texturing/Tutorial%2016.html")),Object(o.b)("p",null,"We consider color values to be linear when computing lighting. What does\nthat means? That means that we assume that the color 0.5,0.5,0.5 is half\nway between black and white.\\\nThe problem is that it's not the case, or at least not when you look at\nthe color through a monitor.\\\nCRT monitors had physical limitations that prevented them to have a\nlinear way of representing colors. that means that 0.5,0.5,0.5 through a\nmonitor is not half way between black and white (it's darker). Note that\nblack and white remains the same though.\\\nIf we do not take that into account, the rendered images are overly\ndarken and feels dull.\\\nLCD monitors still mimic this physical limitation (I guess for backward\ncompatibility).\\\n",Object(o.b)("strong",{parentName:"p"},"Output correct colors"),"\\\nGamma Correction is the technique that tends to correct the issue. Gamma\nis an power factor applied to the color by the monitor when lighting a\npixel on screen (or at least a simplification of the function applied).\nSo when we output the color, we have to apply the inverse power of this\nfactor to nullify the effect : finalColor = pow(computedColor,\n1/gamma);\\"),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Knowing what colors we have as input"),'\\\nThe other aspect of gamma correction is the colors we get as input in\nthe rendering process that are stored in textures or in ColorRGBA\nmaterial params. Almost all image editors are storing color data in\nimages already gamma corrected (so that colors are correct when you\ndisplay the picture in a viewer of in a browser). Also most hand picked\ncolors (in a color picker) can be assumed as gamma corrected as you most\nprobably chose this color through a monitor display. Such images or\ncolor are said to be in sRGB color space, meaning "standard RGB" (which\nis not the standard one would guess). That means that textures and\ncolors that we use as input in our shaders are not in a linear space.\nThe issue is that we need them in linear space when we compute the\nlighting, else the lighting is wrong. To avoid this we need to apply\nsome gamma correction to the colors : (pow(color, gamma); This only\napply to textures that will render colors on screen (basically diffuse\nmap, specular, light maps). Normal maps, height maps don\'t need the\ncorrection.'),Object(o.b)("p",null,"This is the kind of difference you can have :\\\nleft is non corrected output, right is gamma corrected output.\\\n",Object(o.b)("img",Object(n.a)({parentName:"p"},{src:"http://i.imgur.com/uNL7vw8.png",alt:"uNL7vw8.png"}))),Object(o.b)("h2",{id:"implementation"},"Implementation"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"To handle proper gamma corrected ouput colors, Opengl expose an ARB\nextension that allows you to output a color in linear space and have\nthe GPU automatically correct it :\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://www.opengl.org/registry/specs/ARB/framebuffer_sRGB.txt"}),"https://www.opengl.org/registry/specs/ARB/framebuffer_sRGB.txt"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"To handle the input, instead of classic RGBA8 image format, one can\nuse SRGB8","_","ALPHA8","_","EXT which is basically RGBA in sRGB. Using this\nyou specify the GPU that the texture is in sRGB space and when\nfetching a color from it, the GPU will linearize the color value for\nyou (for free). There are sRGB equivalent to all 8 bits formats\n(even compressed format like DXT).")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"But all textures don't need this. For example, normal maps, height\nmaps colors are most probably generated and not hand picked by an\nartist looking through a monitor. The implementation needs to\naccount for it and expose a way to exclude some textures from the\nsRGB pipeline."))),Object(o.b)("p",null,"Gamma Correction in jME 3.0 is based on those three statements."),Object(o.b)("p",null,"::: {.important}\nNote that Gamma Correction is only available on desktop with LWJGL or\nJOGL renderer. They are not yet supported on Android or iOS renderers.\n:::"),Object(o.b)("h3",{id:"turning-gamma-correction-onoff"},"Turning Gamma Correction on/off"),Object(o.b)("p",null,"You can turn Gamma Correction on and off using the AppSettings. There is\na method setGammaCorrection(boolean) that changes the setting. use this\nin the main() method of your application :"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"AppSettings settings = new AppSettings(true);\nsettings.setGammaCorrection(true);\napp.setSettings(settings);\n")),Object(o.b)("p",null,"This setting is also exposed in the Settings dialog displayed when you\nlaunch a jME application.\\\n",Object(o.b)("img",Object(n.a)({parentName:"p"},{src:"http://i.imgur.com/Lya1ldH.png",alt:"Lya1ldH.png"}))),Object(o.b)("p",null,"::: {.important}\nThis is a short hand to enable both linearization of input textures and\nGamma correction of the rendered output on screen.\\\n",Object(o.b)("strong",{parentName:"p"},"Both can be enabled separately"),".\n:::"),Object(o.b)("h4",{id:"enabling-output-gamma-correction"},"Enabling output Gamma Correction"),Object(o.b)("p",null,"You can enable or disable the Gamma correction of the rendered output by\nusing:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"renderer.setMainFrameBufferSrgb(boolean srgb)\n")),Object(o.b)("p",null,"This will be ignored if the hardware doesn't have the\nGL","_","ARB","_","framebuffer","_","sRGB or the GL","_","EXT","_","texture","_","sRGB. This can be\ntoggled at run time."),Object(o.b)("p",null,"This uses Opengl hardware gamma correction that uses an approximated\nGamma value of 2.2 and uses the following formula : color =\npow(color,1/gamma)"),Object(o.b)("p",null,'::: {.note}\nThis will not yield exact results, as the real gamma can vary depending\non the monitor.\\\nIf this is a problem, please refer to the "handling gamma correction in\na post process section.\n:::'),Object(o.b)("h4",{id:"enabling-texture-linearization"},"Enabling texture linearization"),Object(o.b)("p",null,"You can enable or disable texture linearization by using"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"renderer.setLinearizeSrgbImages(boolean linearize)\n")),Object(o.b)("p",null,"This will be ignored if the hardware doesn't have the\nGL","_","ARB","_","framebuffer","_","sRGB or the GL","_","EXT","_","texture","_","sRGB."),Object(o.b)("p",null,"::: {.important}\nToggling this setting at runtime will produce unexpected behavior for\nnow. A change in this setting would need a proper reload of the context\nto work.\n:::"),Object(o.b)("p",null,"All images marked as in sRGB color space will be uploaded to the GPU\nusing a sRGB image format. Opengl hardware texture linearization also\nuses an approximated Gamma value of 2.2 and linearize the fetched texel\ncolor using the following formula : color = pow(color, gamma)\\\nAs with output gamma correction this will not give exact result, but the\nerror is less important since most image editor uses the same\napproximation to correct images and save them in sRGB color space."),Object(o.b)("p",null,"Not all image format have their sRGB equivalent, and only 8bit formats.\nHere is an exhaustive list of the supported format and there equivalent\n:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"RGB8 : GL","_","SRGB8")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"RGBA8 : GL","_","SRGB8","_","ALPHA8")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"BGR8 : GL","_","SRGB8")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"ABGR8 : GL","_","SRGB8","_","ALPHA8")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Luminance8 : GL","_","SLUMINANCE8")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Luminance8Alpha8 : GL","_","SLUMINANCE8","_","ALPHA8")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"DXT1 : GL","_","COMPRESSED","_","SRGB","_","S3TC","_","DXT1")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"DXT1A : GL","_","COMPRESSED","_","SRGB","_","ALPHA","_","S3TC","_","DXT1")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"DXT3 : GL","_","COMPRESSED","_","SRGB","_","ALPHA","_","S3TC","_","DXT3")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"DXT5 : GL","_","COMPRESSED","_","SRGB","_","ALPHA","_","S3TC","_","DXT5"))),Object(o.b)("p",null,"::: {.important}\nConventionally only the rgb channels are gamma corrected, as the alpha\nchannel does not a represent a color value\n:::"),Object(o.b)("h3",{id:"excluding-images-from-the-srgb-pipeline"},"Excluding images from the sRGB pipeline"),Object(o.b)("p",null,"::: {.important}\nOnly loaded images will be marked as in sRGB color space, when using\nassetManager.loadTexture or loadAsset.\\\nThe color space of an image created by code will have to be specified in\nthe constructor or will be assumed as Linear if not specified.\n:::"),Object(o.b)("p",null,"Not all images need to be linearized. Some images don't represent color\ninformation that will be displayed on screen, but more different sort of\ndata packed in a texture.\\\nThe best example is a Normal map that will contains normal vectors for\neach pixel. Height maps will contain elevation values. These textures\nmust not be linearized."),Object(o.b)("p",null,"There is no way to determine the real color space of an image when\nloading it, so we must deduce the color space from the usage it's loaded\nfor. The usage is dictated by the material, those textures are used for,\nand by the material parameter they are assigned to. One can now specify\nin a material definition file (j3md) if a texture parameter must be\nassumed as in linear color space, and thus, must not be linearized, by\nusing the keyword -LINEAR next to the parameter (case does not matter)."),Object(o.b)("p",null,"For example here is how the NormalMap parameter is declared in the\nlighting material definition."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{})," // Normal map\n Texture2D NormalMap -LINEAR\n")),Object(o.b)("p",null,"When a texture is assigned to this material param by using\nmaterial.setTexture(\"NormalMap, myNormalTexture), the color space of\nthis texture's image will be forced to linear. So if you make your own\nmaterial and want to use Gamma Correction, make sure you properly mark\nyour textures as in the proper color space."),Object(o.b)("p",null,"This can sound complicated, but you just have to answer this question :\nDoes my image represent color data? if the answer is no, then you have\nto set the -Linear flag."),Object(o.b)("h3",{id:"colorrgba-as-srgb"},"ColorRGBA as sRGB"),Object(o.b)("p",null,"::: {.important}\nThe r, g, b attributes of a ColorRGBA object are ",Object(o.b)("strong",{parentName:"p"},"ALWAYS")," assumed in\nLinear color space.\n:::"),Object(o.b)("p",null,"If you want to set a color that you hand picked in a color picker, you\nshould use the setAsSRGB method of ColorRGBA. This will convert the\ngiven values to linear color space by using the same formula as before :\ncolor = pow (color, gamma) where gamma = 2.2;"),Object(o.b)("p",null,"If you want to retrieve those values from a ColorRGBA, you can call the\ngetAsSRGB method. The values will be converted back to sRGB color Space."),Object(o.b)("p",null,"::: {.note}\nThe return type of that method is a Vector4f and not a ColorRGBA,\nbecause as stated before, all ColorRGBA objects r,g,b attributes are\nassumed in Linear color space.\n:::"),Object(o.b)("h3",{id:"handling-rendered-output-gamma-correction-with-a-post-process-filter"},"Handling rendered output Gamma Correction with a post process filter"),Object(o.b)("p",null,"As stated before, the hardware gamma correction uses and approximated\ngamma value of 2.2. Some may not be satisfied with that approximations\nand may want to pick a more appropriate gamma value. You can see in some\ngames some Gamma calibration screens, that are here to help the player\npick a correct gamma value for the monitor he's using."),Object(o.b)("p",null,"For this particular case, you can do as follow :"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Enable Gamma Correction global app setting.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Disable rendered output correction :\nrenderer.setMainFrameBufferSrgb(false); (for example in the\nsimpleInit method of your SimpleApplication).")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Use the GammaCorrectionFilter in a FilterPostProcessor, and set the\nproper gamma value on it (default is 2.2)."))),Object(o.b)("h2",{id:"should-you-use-this"},"Should you use this?"),Object(o.b)("p",null,"Yes. Mostly because it's the only way to have proper lighting. If you're\nstarting a new project it's a no brainer...use it, period. And don't\nallow the player to turn it off."),Object(o.b)("p",null,"Now if you already spent time to adjust lighting in your scenes, without\ngamma correction, turning it on will make everything too bright, and\nyou'll have to adjust all your lighting and colors again. That's why we\nkept a way to turn it off, for backward compatibility."))}p.isMDXComponent=!0},441:function(e,t,a){"use strict";a.d(t,"a",(function(){return m})),a.d(t,"b",(function(){return b}));var n=a(0),r=a.n(n);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=r.a.createContext({}),p=function(e){var t=r.a.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):l({},t,{},e)),a},m=function(e){var t=p(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},h=Object(n.forwardRef)((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(a),h=n,b=m["".concat(i,".").concat(h)]||m[h]||u[h]||o;return a?r.a.createElement(b,l({ref:t},c,{components:a})):r.a.createElement(b,l({ref:t},c))}));function b(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,i=new Array(o);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:n,i[1]=l;for(var c=2;c<o;c++)i[c]=a[c];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,a)}h.displayName="MDXCreateElement"}}]);