(window.webpackJsonp=window.webpackJsonp||[]).push([[148],{287:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return d}));var a=n(1),i=n(9),o=(n(0),n(441)),r={},s={id:"jme3/tools/navigation",title:"navigation",description:"This article describes JME's mercator projection tool. If you don't know",source:"@site/docs/jme3/tools/navigation.md",permalink:"/wikidemo/docs/jme3/tools/navigation",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/tools/navigation.md"},l=[],c={rightToc:l};function d(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"This article describes JME's mercator projection tool. If you don't know\nwhat this means, we suggest you begin by reading ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://en.wikisource.org/wiki/The_American_Practical_Navigator"}),"The American Practical\nNavigator"),'\nor browsing Wikipedia. If you do know what a Mercator projection is,\nthen our "Introduction to Marine Navigation might serve to refresh your\nmind.'),Object(o.b)("p",null,Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://en.wikipedia.org/wiki/Latitude"}),"Wikipedia")," is a source for\nformulas shown here. Read it. Absorb it."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Terms, Conventions and Definitions")," ",Object(o.b)("strong",{parentName:"p"},"Charts"),' are defined as\n"graphic representations of areas of the earth for use in marine or air\nnavigation whereby nautical charts depict features of particular\ninterest to the marine navigator',"[","1","]","."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Prime Meridian")," designates the Greenwich meridian as of 1884."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Distance")," is designated in nautical miles whereby one nautical mile\ncorresponds to one meridian arc minute (1,852 metres) at the equator."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Sailing")," refers to various mathematical methods for determining\ncourse, distance, and position. ",Object(o.b)("strong",{parentName:"p"},"Speed")," refers to the rate of motion,\nor distance per unit of time and is measured in knots (kn). One knot is\nequal to one nautical mile per hour."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Coordinates")," The purpose of coordinates is to define a distinct\nposition on earth. For the purpose of this project, only latitude and\nlongitude are of importance, although the reader should be aware that\nother coordinate systems exists such as UMT (Universal Transverse\nMercator) and UPS (Universal Polar Stereographic)."),Object(o.b)("p",null,"Latitude is the angular distance from the equator, measured northward or\nsouthward along a meridian from 0\u25e6 at the equator to 90\u25e6 at the\npoles","[","1","]",". Within aviation and maritime navigation, latitude is\ndesignated north (N) or south (S) to indicate the direction of\nmeasurement. An equally valid notation designates north (N) to be\npositive and south (S) to be negative. For example 18\u25e6 N becomes 18\nwhilst 18\u25e6 S becomes -18. Longitude is the angular distance between the\nprime meridian and the meridian of a point on the earth, measured\neastward or westward from the prime meridian through 180\u25e6. It is\ndesignated east (E) or west (W) to indicate the direction of\nmeasurement","[","1","]"," however similar to angular measurements from the\nequator, may be expressed in terms of negative (W) and positive (S). For\nex- ample 18\u25e6 E becomes 18 whilst 18\u25e6 W becomes -18. It is worth noting\nthat degrees can be further subdivided into minutes, whereby one degree\nequals 60 minutes. Minutes in turn are subdivided into seconds whereby\neach minute equals 60 seconds. Latitude and longitude coordinates are\ntherefore typically specified as degrees (\u25e6), minutes (') and seconds\n(\")."),Object(o.b)("p",null,"For example: 1\u25e6 2' 3\" W meaning 1 degree, 2 minutes and 3 seconds West.\nThis in turn can be translated into decimal notation whereby degrees are\nexpressed as a decimal fraction: therefore 1\u25e6 2' 3\" W would become\n-1.034167. Alternatively these angular measurements may be converted to\nradians (in which case they would be expressed as a signed fraction of\n\u03c0). The difference of latitude between two places is the angular length\nof arc of any meridian between their parallels. That is, it is the\nnumerical difference of the latitudes if the places are on the same side\nof the equator or the sum of the latitudes if the points are on opposite\nsides of the equator.","[","1","]"),Object(o.b)("p",null,"Similarly, the difference of longitude between two places is the shorter\narc of the parallel or the smaller angle at the pole between the\nmeridians of the two places. If both places are on the same side (i.e\neast or west) of Greenwich, then difference of longitude is the\nnumerical difference of the longitudes of the two places; otherwise the\ndifference of longitude is their numerical sum (unless of course this\nexceeds 180\u25e6. In that case it is 360\u25e6 minus the sum)."),Object(o.b)("p",null,Object(o.b)("img",Object(a.a)({parentName:"p"},{src:"/images/jme3/tools/globe_lat_long.png",alt:"Figure 1: Illustrated latitude (\u03c6) and longitude (\u03bb). Photo courtesy\nof Wikimedia Inc."}))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Meridional Parts"),' As described by Bowditch, Meridional parts are\n"units of latitude that have been adjusted to compensate for the\ndistortion that results from projecting a three-dimensional globe onto a\ntwo-dimensional Mercator chart".'),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Bearing"),' In marine navigation, bearing is defined as "the direction\none object is from another object, usually, the direction of an object\nfrom one\'s own vessel". Note that this is not to be confused with the\nequivalent term within aviation were bearing refers to "the actual\n(corrected) compass direction of the forward course of the aircraft."'),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Heading and Course")," Heading is the direction in which a vessel is\npointed and is expressed as degrees from 0 to 359. Course is the over\nground track in which a vessel moves. With wind, water movement and\nsteering error, heading and course are not necessary equal."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Mercator Projection")," Mercator projections are a standard within\nnautical charts an represent rhumb lines (a.k.a loxodromes) as straight\nsegments. A mercator projection is of non- linear scale as it accounts\nfor distortion in latitude as one moves away from the Equator and\ntowards the poles (with the poles being defined as infinity. This notion\nis illustrated to the right by figure 1.2). These distortions arise from\nthe fact that the earth is an oblate spheriod i.e. a sphere with a\nflattened top and bottom (the poles). Therefore, as one moves away from\nthe equator, nautical metrics skew to the extend whereby the length of\none degree of latitude along the poles covers approximately 1 percent\nmore distance than at the equator."),Object(o.b)("h1",{id:"chart-projection"},"Chart Projection"),Object(o.b)("p",null,"A Mercator projection is defined by its meridians and parallels, both of\nwhich are expanded at an equal ratio with increasing latitude. This\nexpansion is due to the distortion that results from projecting an\noblate spheroid onto a two- dimensional surface (see introductory notes\nabove) and equates to the secant of the latitude in addition to a\ncorrection for this distortion. Note that the secant of 90\u25e6 is infinity,\nand therefore Mercator projections cannot include the poles (thus the\nmercator projection employed here stops at 85\u25e6 North and South of the\nequator)."),Object(o.b)("p",null,"Rhumb lines appear as straight lines."),Object(o.b)("p",null,"The projection calculations are handled by the ",Object(o.b)("inlineCode",{parentName:"p"},"MapModel2D")," class, in\nthe case of 2D, and by ",Object(o.b)("inlineCode",{parentName:"p"},"MapModel3D"),", in the case of a 3D projection.\nFundamentally both projections function in the same manner, with their\nonly real differences being that ",Object(o.b)("inlineCode",{parentName:"p"},"MapModel3D")," introduces an extra\nco-ordinate (z) and the replacement of the ",Object(o.b)("inlineCode",{parentName:"p"},"toPixel()")," method with\n",Object(o.b)("inlineCode",{parentName:"p"},"toWorldUnit()")," which converts a latitude/longitude coordinate object\ninto (x,y,z) world units as opposed to pixel (x,y) coordinates. The core\nfunctionality of the entire system relies on the accurate conversion of\nlatitude/longitude into pixels/world units and vice versa. These\nconversions are handled by ",Object(o.b)("inlineCode",{parentName:"p"},"toPixel()"),", ",Object(o.b)("inlineCode",{parentName:"p"},"toWorldUnit()")," and\n",Object(o.b)("inlineCode",{parentName:"p"},"toPosition()")," respectively. Note that all sailings used by this class\nare located inside the NavCalculator class and will be elaborated upon\nin the next section of this chapter."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Minutes per pixel / Minutes per World Unit")," The number of pixels or\nworld units per minute serves as a baseline for all coordinate\nconversions and is derived by dividing the total number of minutes of\nlongitude composing the chart (i.e. 360 ","*"," 60) by the width of the\ncanvas on which to render the projection (aka viewport):\n",Object(o.b)("inlineCode",{parentName:"p"},"minutesPerPixel = (mapWidthInLongitude * 60) / (double) viewportWidth;")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"toPixel")," Unlike commonly assumed, this method is not derived from the\ninverse Guder- mannian function. Accepting a set of latitude/longitude\ncoordinates encapsulated in a Position object as a parameter, the method\nreturns the equivalent pixel (x, y) encapsulated as a Point object. This\nconversion can be summarized as follows","[","2","]",":"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Ordered List Item Get the distance between the given position's\nlongitude coordinate and the chart's longitude centre.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Convert the obtained distance into pixels by dividing it with the\nnumber of pixels that are contained within one minute. Refer to it\nas distanceInPixels.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Calculate the x-coordinate by subtracting or adding it to the\ncanvas' x-centre coordinate (the canvas' x-centre coordinate being\nthe canvas width di- vided by two) depending on the location of the\nposition itself and the chart's centre: That is, if the chart is\ncentred west of the prime meridian and if the position to be\nconverted is west of the centre, then the resulting x-coordinate is\nthe difference between the x-centre and the distanceInPixels\nobtained in step 2 above. If however the centre is West and the\nposition is east of the centre, then the resulting x-coordinate\nequates to the sum of the x-centre and its dis- tanceInPixels. The\nopposite is true for an easterly centre and a position west of this\ncentre or an easterly centre and a position east of this centre.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Ordered List Item For the y-coordinate, the difference in meridional\nparts between the chart's latitude centre and the position's\nlatitude serves as a baseline. Con- vert the difference to pixels by\ndividing it by the number of pixels contained"))),Object(o.b)("p",null,"within one minute. Refer to it as dmp1."),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"Ordered List Item Similar to step 3 above, calculate the\ny-coordinate by subtracting or")),Object(o.b)("p",null,"adding it to the canvas' y-centre coordinate (the canvas' y-centre being\nthe canvas height divided by two) depending on the location of the\nposition itself and the chart's centre: That is, if the centre is north\nand the position is north of the centre, then the resulting\ny-coordinates equates to the difference between dmp and the y-centre\ncoordinate. If however the centre is north but the position is south of\nthe centre, then the resulting y-coordinate equates to their sum. The\nopposites are true given that the centre lies in the southern\nhemisphere."),Object(o.b)("p",null,"The following converts a latitude/longitude coordinate pair into a JME\nworld-unit vector:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"try {\n    int worldWidth = 800;\n    MapModel3D m = new MapModel3D(worldWidth);\n    Vector3f v = m.toWorldUnit(new Position(-53, 8.0));\n} catch (InvalidPositionException e) { e.printStackTrace(); }\n")),Object(o.b)("p",null,"To convert world units into latitude/longitude coordinates, use the map\nmodel's toPosition method:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'try {\n     int worldWidth = 800; MapModel3D m = new MapModel3D(worldWidth);\n     Position pos = m.toPosition(new Vector3f(10, 10, 10));\n     System.out.println("Latitude: " + pos.getLatitude() + " Longitude: " + pos.getLongitude());\n} catch (InvalidPositionException e) {\n     e.printStackTrace();\n}\n')),Object(o.b)("p",null,"Navigational calculations are performed inside the ",Object(o.b)("inlineCode",{parentName:"p"},"NavCalculator"),"\nclass."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Mercator Sailing")," Mercator sailing is defined as 'the process of\nsolving problems involving course, distance, difference of latitude and\ndifference of longitude, by considering them in relation to a Mercator\nchart'","[","1","]",". Essentially, this refers to the plotting of a rhumb line2\non a Mercator chart whereby the rhumb line will appear as a straight\nline. That is, given a constant bearing \u03b2 north of the rhumb line,\nlongitude \u03bb0 where the line passes the equator, \u03bb1 being any longitude\npoint of the rhumb line, and \u03c6 being any latitude point on the rhumb\nline then its Mercator projection can be derived as:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"x = \u03bb1")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"y = m(\u03bb1 \u2212 \u03bb0)"))),Object(o.b)("p",null,"where slope m is cot(\u03b2), then \u03bb and \u03c6 can be expressed as"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"x = \u03bb1")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"y = tanh\u22121(sin(\u03c6) \u03c6 = sin\u22121(tanh(m(\u03bb1 \u2212 \u03bb0)))"))),Object(o.b)("p",null,"That is, tan(course) =\n(differenceinlongitude)/(differenceinmeridionalparts) and distance =\n(differenceinlatitude/cos(course)) where the difference in meridional\nparts is defined in terms of a Clarke Spheroid."),Object(o.b)("p",null,"This is implemented as follows where ",Object(o.b)("inlineCode",{parentName:"p"},"RLSailing")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Position")," are\nwrapper classes."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"public RLSailing mercatorSailing(Position p1, Position p2) {\n     double dLat = computeDLat(p1.getLatitude(), p2.getLatitude());\n     if (dLat == 0) {\n          RLSailing rl = planeSailing(p1, p2); return rl;\n     }\n     double dLong = computeDLong(p1.getLongitude(), p2.getLongitude());\n     double dmp = (float) computeDMPClarkeSpheroid(p1.getLatitude(), p2.getLatitude());\n     trueCourse = (float) Math.toDegrees(Math.atan(dLong / dmp));\n     double degCrs = convertCourse((float) trueCourse, p1, p2);\n     distance = (float) Math.abs(dLat / Math.cos(Math.toRadians(trueCourse)));\n\n     RLSailing rl = new RLSailing(degCrs, (float) distance);\n     trueCourse = rl.getCourse();\n     return rl;\n}\n")),Object(o.b)("p",null,"where ",Object(o.b)("em",{parentName:"p"},"dmp")," refers to the difference in meridional parts."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Difference in Meridional Parts")," Meridional parts are units of\nlatitude that have been adjusted to compensate for the distortion that\nresults from projecting an oblate spheroid onto a two- dimensional\nsurface."),Object(o.b)("p",null,"Although other datums (such as WGS 84) are equally valid, the navigation\nmodule performs all calculations within the context of the Clarke\nspheroid of 1880 which has an equatorial radius of 6,378,249.145 meters,\na polar radius of 6,356,514.870 meters and an inverse flattening of\n293.465 meters. The meridional part for any latitude L is therefore\ndefined as: M = 7915.704468 \u2217 log(tan(45 + (L/2))) \u2212 23.268932 \u2217\n(sin(L)) \u2212 0.052500 \u2217 (sin(L))3 \u2212 0.000213 \u2217 (sin(L))5"),Object(o.b)("p",null,"Where m1 and m2 refer to the meridional parts of the offset and\ndestination point respectively, the difference of meridional parts is\ncalculated as ","|","m1 \u2212 m2","|"," if both points are north, or south of the\nequator or as their sum if one of the points is north and the other\nsouth of the equator:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"public static double computeDMPClarkeSpheroid(double lat1, double lat2) {\n     double absLat1 = Math.abs(lat1); double absLat2 = Math.abs(lat2);\n     double m1 = (7915.704468 * (Math.log(Math.tan(Math.toRadians(45 + (absLat1 / 2)))) / Math.log(10)) - 23.268932 * Math.sin(Math.toRadians(absLat1)) - 0.052500 * Math.pow(Math.sin(Math.toRadians(absLat1)), 3) - 0.000213 * Math.pow(Math.sin(Math.toRadians(absLat1)), 5));\ndouble m2 = (7915.704468 * (Math.log(Math.tan(Math.toRadians(45 + (absLat2 / 2)))) / Math.log(10))\n- 23.268932 * Math.sin(Math.toRadians(absLat2)) - 0.052500 * Math.pow(Math.sin(Math.toRadians(absLat2)), 3) - 0.000213 * Math.pow(Math.sin(Math.toRadians(absLat2)), 5));\n     if ((lat1 <= 0 && lat2 <= 0) || (lat1 > 0 && lat2 > 0)) {\n          return Math.abs(m1 - m2);\n     } else {\n          return m1 + m2;\n     }\n}\n")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Course Conversion")," The conversion of a true course to its equivalent\ncompass course (i.e. con- version of true course to the targets course\nover ground (COG) where 'true course' is defined as the course to be\nsteered from true north3) as used by the ",Object(o.b)("inlineCode",{parentName:"p"},"mercatorSailing")," method is\nachieved by subtracting the course variation from the true course, where\nvariation is the angular difference between true north and the direction\nof the Earth's magnetic field (consequently variation is termed East or\nWest depending on the target's position relative to true north). Given\nthe true course between two positions, the COG is calculated by calling\nNavCalculator.convertCourse(tc, p1, p2)"),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Difference in Latitude")," The difference in latitude depends on the\nhemisphere in which both positions are can be determined by calling\n",Object(o.b)("inlineCode",{parentName:"p"},"NavCalculator.computeDLat(lat1, lat2)"),"."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Difference in Longitude")," Similar to the difference in latitude, the\ndifference in longitude depends on which side of the prime meridian both\npositions are in and can be determined by calling\nNavCalculator.computeDLong(long1, long2)."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Bearing")," The direction that one target is from another. Given the\nlatitude of two points (\u03c60and\u03c61) and the longitude of two\npoints(\u03bb0and\u03bb1), bearing (\u03b8) is defined as follows: Let dLon be the\ndifference in longitude of \u03bb0and\u03bb1, then"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"x = (sin(dLon) \u2217 cos(\u03c61)")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"y = cos(\u03c60) \u2217 sin(\u03c61) \u2212 sin(\u03c60) \u2217 cos(\u03c61) \u2217 cos(dLon))")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"\u03b8 = 2arctan\u221a \u03b8 = atan2(y, x)")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"y"))),Object(o.b)("p",null,"x2+y2+x"),Object(o.b)("p",null,"Which can be determined as follows:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"try {\n     double bearing = NavCalculator.computeBearing(new Position(-53.6, 8.1), new Position(-53, 8.\n  } catch (InvalidPositionException e) {\n     e.printStackTrace();\n  }\n")),Object(o.b)("p",null,"[","1","]"," Nathaniel Bowditch (1995), The American Practical Navigator,.\nUnited States Government, National Ocean Service Publishing. ","[","2","]",'\nGebruers C., "JMarine'))}d.isMDXComponent=!0},441:function(e,t,n){"use strict";n.d(t,"a",(function(){return h})),n.d(t,"b",(function(){return b}));var a=n(0),i=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),d=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s({},t,{},e)),n},h=function(e){var t=d(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},u=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=d(n),u=a,b=h["".concat(r,".").concat(u)]||h[u]||p[u]||o;return n?i.a.createElement(b,s({ref:t},c,{components:n})):i.a.createElement(b,s({ref:t},c))}));function b(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);