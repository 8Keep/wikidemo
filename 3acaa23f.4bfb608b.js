(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{215:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return h}));var i=n(1),a=n(9),o=(n(0),n(441)),r={},l={id:"jme3/beginner/hello_picking",title:"hello_picking",description:"Previous: [Hello Animation](../../jme3/beginner/hello_animation),",source:"@site/docs/jme3/beginner/hello_picking.md",permalink:"/wikidemo/docs/jme3/beginner/hello_picking",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/beginner/hello_picking.md",sidebar:"main",previous:{title:"hello_animation",permalink:"/wikidemo/docs/jme3/beginner/hello_animation"},next:{title:"hello_collision",permalink:"/wikidemo/docs/jme3/beginner/hello_collision"}},s=[{value:"Loading the scene",id:"loading-the-scene",children:[]},{value:"Setting Up the Input Listener",id:"setting-up-the-input-listener",children:[]},{value:"Picking Action Using Crosshairs",id:"picking-action-using-crosshairs",children:[]},{value:"Picking Action Using Mouse Pointer",id:"picking-action-using-mouse-pointer",children:[]},{value:"Exercise 1: Magic Spell",id:"exercise-1-magic-spell",children:[]},{value:"Exercise 2: Shoot a Character",id:"exercise-2-shoot-a-character",children:[]},{value:"Exercise 3: Pick up into Inventory",id:"exercise-3-pick-up-into-inventory",children:[]}],c={rightToc:s};function h(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(i.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Previous: ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"../../jme3/beginner/hello_animation"}),"Hello Animation"),",\nNext: ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"../../jme3/beginner/hello_collision"}),"Hello Collision")),Object(o.b)("p",null,"Typical interactions in games include shooting, picking up objects, and\nopening doors. From an implementation point of view, these apparently\ndifferent interactions are surprisingly similar: The user first aims and\nselects a target in the 3D scene, and then triggers an action on it. We\ncall this process picking."),Object(o.b)("p",null,"You can pick something by either pressing a key on the keyboard, or by\nclicking with the mouse. In either case, you identify the target by\naiming a ray --a straight line-- into the scene. This method to\nimplement picking is called ",Object(o.b)("em",{parentName:"p"},"ray casting")," (which is not the same as ",Object(o.b)("em",{parentName:"p"},"ray\ntracing"),")."),Object(o.b)("p",null,"This tutorial relies on what you have learned in the ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"../../jme3/beginner/hello_input_system"}),"Hello\nInput")," tutorial. You find\nmore related code samples under ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"../../jme3/advanced/mouse_picking"}),"Mouse\nPicking")," and ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"../../jme3/advanced/collision_and_intersection"}),"Collision and\nIntersection"),"."),Object(o.b)("p",null,Object(o.b)("img",Object(i.a)({parentName:"p"},{src:"/images/jme3/beginner/beginner-picking.png",alt:"beginner-picking.png"}))),Object(o.b)("h1",{id:"sample-code"},"Sample Code"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),'package jme3test.helloworld;\n\nimport com.jme3.app.SimpleApplication;\nimport com.jme3.collision.CollisionResult;\nimport com.jme3.collision.CollisionResults;\nimport com.jme3.font.BitmapText;\nimport com.jme3.input.KeyInput;\nimport com.jme3.input.MouseInput;\nimport com.jme3.input.controls.ActionListener;\nimport com.jme3.input.controls.KeyTrigger;\nimport com.jme3.input.controls.MouseButtonTrigger;\nimport com.jme3.light.DirectionalLight;\nimport com.jme3.material.Material;\nimport com.jme3.math.ColorRGBA;\nimport com.jme3.math.Ray;\nimport com.jme3.math.Vector3f;\nimport com.jme3.scene.Geometry;\nimport com.jme3.scene.Node;\nimport com.jme3.scene.Spatial;\nimport com.jme3.scene.shape.Box;\nimport com.jme3.scene.shape.Sphere;\n\n/** Sample 8 - how to let the user pick (select) objects in the scene\n * using the mouse or key presses. Can be used for shooting, opening doors, etc. */\npublic class HelloPicking extends SimpleApplication {\n\n  public static void main(String[] args) {\n    HelloPicking app = new HelloPicking();\n    app.start();\n  }\n  private Node shootables;\n  private Geometry mark;\n\n  @Override\n  public void simpleInitApp() {\n    initCrossHairs(); // a "+" in the middle of the screen to help aiming\n    initKeys();       // load custom key mappings\n    initMark();       // a red sphere to mark the hit\n\n    /** create four colored boxes and a floor to shoot at: */\n    shootables = new Node("Shootables");\n    rootNode.attachChild(shootables);\n    shootables.attachChild(makeCube("a Dragon", -2f, 0f, 1f));\n    shootables.attachChild(makeCube("a tin can", 1f, -2f, 0f));\n    shootables.attachChild(makeCube("the Sheriff", 0f, 1f, -2f));\n    shootables.attachChild(makeCube("the Deputy", 1f, 0f, -4f));\n    shootables.attachChild(makeFloor());\n    shootables.attachChild(makeCharacter());\n  }\n\n  /** Declaring the "Shoot" action and mapping to its triggers. */\n  private void initKeys() {\n    inputManager.addMapping("Shoot",\n      new KeyTrigger(KeyInput.KEY_SPACE), // trigger 1: spacebar\n      new MouseButtonTrigger(MouseInput.BUTTON_LEFT)); // trigger 2: left-button click\n    inputManager.addListener(actionListener, "Shoot");\n  }\n  /** Defining the "Shoot" action: Determine what was hit and how to respond. */\n  private ActionListener actionListener = new ActionListener() {\n\n    public void onAction(String name, boolean keyPressed, float tpf) {\n      if (name.equals("Shoot") && !keyPressed) {\n        // 1. Reset results list.\n        CollisionResults results = new CollisionResults();\n        // 2. Aim the ray from cam loc to cam direction.\n        Ray ray = new Ray(cam.getLocation(), cam.getDirection());\n        // 3. Collect intersections between Ray and Shootables in results list.\n        // DO NOT check collision with the root node, or else ALL collisions will hit the\n        // skybox! Always make a separate node for objects you want to collide with.\n        shootables.collideWith(ray, results);\n        // 4. Print the results\n        System.out.println("----- Collisions? " + results.size() + "-----");\n        for (int i = 0; i < results.size(); i++) {\n          // For each hit, we know distance, impact point, name of geometry.\n          float dist = results.getCollision(i).getDistance();\n          Vector3f pt = results.getCollision(i).getContactPoint();\n          String hit = results.getCollision(i).getGeometry().getName();\n          System.out.println("* Collision #" + i);\n          System.out.println("  You shot " + hit + " at " + pt + ", " + dist + " wu away.");\n        }\n        // 5. Use the results (we mark the hit object)\n        if (results.size() > 0) {\n          // The closest collision point is what was truly hit:\n          CollisionResult closest = results.getClosestCollision();\n          // Let\'s interact - we mark the hit with a red dot.\n          mark.setLocalTranslation(closest.getContactPoint());\n          rootNode.attachChild(mark);\n        } else {\n          // No hits? Then remove the red mark.\n          rootNode.detachChild(mark);\n        }\n      }\n    }\n  };\n\n  /** A cube object for target practice */\n  protected Geometry makeCube(String name, float x, float y, float z) {\n    Box box = new Box(1, 1, 1);\n    Geometry cube = new Geometry(name, box);\n    cube.setLocalTranslation(x, y, z);\n    Material mat1 = new Material(assetManager, "Common/MatDefs/Misc/Unshaded.j3md");\n    mat1.setColor("Color", ColorRGBA.randomColor());\n    cube.setMaterial(mat1);\n    return cube;\n  }\n\n  /** A floor to show that the "shot" can go through several objects. */\n  protected Geometry makeFloor() {\n    Box box = new Box(15, .2f, 15);\n    Geometry floor = new Geometry("the Floor", box);\n    floor.setLocalTranslation(0, -4, -5);\n    Material mat1 = new Material(assetManager, "Common/MatDefs/Misc/Unshaded.j3md");\n    mat1.setColor("Color", ColorRGBA.Gray);\n    floor.setMaterial(mat1);\n    return floor;\n  }\n\n  /** A red ball that marks the last spot that was "hit" by the "shot". */\n  protected void initMark() {\n    Sphere sphere = new Sphere(30, 30, 0.2f);\n    mark = new Geometry("BOOM!", sphere);\n    Material mark_mat = new Material(assetManager, "Common/MatDefs/Misc/Unshaded.j3md");\n    mark_mat.setColor("Color", ColorRGBA.Red);\n    mark.setMaterial(mark_mat);\n  }\n\n  /** A centred plus sign to help the player aim. */\n  protected void initCrossHairs() {\n    setDisplayStatView(false);\n    guiFont = assetManager.loadFont("Interface/Fonts/Default.fnt");\n    BitmapText ch = new BitmapText(guiFont, false);\n    ch.setSize(guiFont.getCharSet().getRenderedSize() * 2);\n    ch.setText("+"); // crosshairs\n    ch.setLocalTranslation( // center\n      settings.getWidth() / 2 - ch.getLineWidth()/2,\n      settings.getHeight() / 2 + ch.getLineHeight()/2, 0);\n    guiNode.attachChild(ch);\n  }\n\n  protected Spatial makeCharacter() {\n    // load a character from jme3test-test-data\n    Spatial golem = assetManager.loadModel("Models/Oto/Oto.mesh.xml");\n    golem.scale(0.5f);\n    golem.setLocalTranslation(-1.0f, -1.5f, -0.6f);\n\n    // We must add a light to make the model visible\n    DirectionalLight sun = new DirectionalLight();\n    sun.setDirection(new Vector3f(-0.1f, -0.7f, -1.0f));\n    golem.addLight(sun);\n    return golem;\n  }\n}\n')),Object(o.b)("p",null,"You should see four colored cubes floating over a gray floor, and\ncross-hairs. Aim the cross-hairs and click, or press the spacebar to\nshoot. The hit spot is marked with a red dot."),Object(o.b)("p",null,"Keep an eye on the application's output stream, it will give you more\ndetails: The name of the mesh that was hit, the coordinates of the hit,\nand the distance."),Object(o.b)("h1",{id:"understanding-the-helper-methods"},"Understanding the Helper Methods"),Object(o.b)("p",null,"The methods ",Object(o.b)("inlineCode",{parentName:"p"},"makeCube()"),", ",Object(o.b)("inlineCode",{parentName:"p"},"makeFloor()"),", ",Object(o.b)("inlineCode",{parentName:"p"},"initMark()"),", and\n",Object(o.b)("inlineCode",{parentName:"p"},"initCrossHairs"),", are custom helper methods. We call them from\n",Object(o.b)("inlineCode",{parentName:"p"},"simpleInitApp()")," to initialize the scenegraph with sample content."),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"makeCube()"),' creates simple colored boxes for "target practice.')),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"makeFloor()"),' creates a gray floor node for "target practice.')),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"initMark()"),' creates a red sphere ("mark). We will use it later to\nmark the spot that was hit.'),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Note that the mark is not attached and therefor not visible at\nthe start!"))),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"initCrossHairs()"),' creates simple cross-hairs by printing a "+ sign\nin the middle of the screen.'),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Note that the cross-hairs are attached to the ",Object(o.b)("inlineCode",{parentName:"li"},"guiNode"),", not to\nthe ",Object(o.b)("inlineCode",{parentName:"li"},"rootNode"),".")))),Object(o.b)("p",null,'In this example, we attached all "shootable objects to one custom node,\n',Object(o.b)("inlineCode",{parentName:"p"},"Shootables"),". This is an optimization so the engine only has to\ncalculate intersections with objects we are actually interested in. The\n",Object(o.b)("inlineCode",{parentName:"p"},"Shootables")," node is attached to the ",Object(o.b)("inlineCode",{parentName:"p"},"rootNode")," as usual."),Object(o.b)("h1",{id:"understanding-ray-casting-for-hit-testing"},"Understanding Ray Casting for Hit Testing"),Object(o.b)("p",null,'Our goal is to determine which box the user "shot (picked). In general,\nwe want to determine which mesh the user has selected by aiming the\ncross-hairs at it. Mathematically, we draw a line from the camera and\nsee whether it intersects with objects in the 3D scene. This line is\ncalled a ray.'),Object(o.b)("p",null,"Here is our simple ray casting algorithm for picking objects:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Reset the results list.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Cast a ray from cam location into the cam direction.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Collect all intersections between the ray and ",Object(o.b)("inlineCode",{parentName:"p"},"Shootable")," nodes in\nthe ",Object(o.b)("inlineCode",{parentName:"p"},"results")," list.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Use the results list to determine what was hit:"),Object(o.b)("p",{parentName:"li"},"a.  For each hit, JME reports its distance from the camera, impact\npoint, and the name of the mesh."),Object(o.b)("p",{parentName:"li"},"b.  Sort the results by distance."),Object(o.b)("p",{parentName:"li"},"c.  Take the closest result, it is the mesh that was hit."))),Object(o.b)("h1",{id:"implementing-hit-testing"},"Implementing Hit Testing"),Object(o.b)("h2",{id:"loading-the-scene"},"Loading the scene"),Object(o.b)("p",null,"First initialize some shootable nodes and attach them to the scene. You\nwill use the ",Object(o.b)("inlineCode",{parentName:"p"},"mark")," object later."),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),'  Node shootables;\n  Geometry mark;\n\n  @Override\n  public void simpleInitApp() {\n    initCrossHairs();\n    initKeys();\n    initMark();\n\n    shootables = new Node("Shootables");\n    rootNode.attachChild(shootables);\n    shootables.attachChild(makeCube("a Dragon",    -2f, 0f, 1f));\n    shootables.attachChild(makeCube("a tin can",    1f,-2f, 0f));\n    shootables.attachChild(makeCube("the Sheriff",  0f, 1f,-2f));\n    shootables.attachChild(makeCube("the Deputy",   1f, 0f, -4));\n    shootables.attachChild(makeFloor());\n  }\n')),Object(o.b)("h2",{id:"setting-up-the-input-listener"},"Setting Up the Input Listener"),Object(o.b)("p",null,"Next you declare the shooting action. It can be triggered either by\nclicking, or by pressing the space bar. The ",Object(o.b)("inlineCode",{parentName:"p"},"initKeys()")," method is\ncalled from ",Object(o.b)("inlineCode",{parentName:"p"},"simpleInitApp()")," to set up these input mappings."),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),'  /** Declaring the "Shoot" action and its triggers. */\n  private void initKeys() {\n    inputManager.addMapping("Shoot",      // Declare...\n      new KeyTrigger(KeyInput.KEY_SPACE), // trigger 1: spacebar, or\n      new MouseButtonTrigger(MouseInput.BUTTON_LEFT));         // trigger 2: left-button click\n    inputManager.addListener(actionListener, "Shoot"); // ... and add.\n  }\n')),Object(o.b)("h2",{id:"picking-action-using-crosshairs"},"Picking Action Using Crosshairs"),Object(o.b)("p",null,"Next we implement the ActionListener that responds to the Shoot trigger\nwith an action. The action follows the ray casting algorithm described\nabove:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"For every click or press of the spacebar, the ",Object(o.b)("inlineCode",{parentName:"p"},"Shoot")," action is\ntriggered.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"The action casts a ray forward and determines intersections with\nshootable objects (= ray casting).")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"For any target that has been hit, it prints name, distance, and\ncoordinates of the hit.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Finally it attaches a red mark to the closest result, to highlight\nthe spot that was actually hit.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"When nothing was hit, the results list is empty, and the red mark is\nremoved."))),Object(o.b)("p",null,"Note how it prints a lot of output to show you which hits were\nregistered."),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),'  /** Defining the "Shoot" action: Determine what was hit and how to respond. */\n  private ActionListener actionListener = new ActionListener() {\n    @Override\n    public void onAction(String name, boolean keyPressed, float tpf) {\n      if (name.equals("Shoot") && !keyPressed) {\n        // 1. Reset results list.\n        CollisionResults results = new CollisionResults();\n        // 2. Aim the ray from cam loc to cam direction.\n        Ray ray = new Ray(cam.getLocation(), cam.getDirection());\n        // 3. Collect intersections between Ray and Shootables in results list.\n        shootables.collideWith(ray, results);\n        // 4. Print results.\n        System.out.println("----- Collisions? " + results.size() + "-----");\n        for (int i = 0; i < results.size(); i++) {\n          // For each hit, we know distance, impact point, name of geometry.\n          float dist = results.getCollision(i).getDistance();\n          Vector3f pt = results.getCollision(i).getContactPoint();\n          String hit = results.getCollision(i).getGeometry().getName();\n          System.out.println("* Collision #" + i);\n          System.out.println("  You shot " + hit + " at " + pt + ", " + dist + " wu away.");\n        }\n        // 5. Use the results (we mark the hit object)\n        if (results.size() > 0){\n          // The closest collision point is what was truly hit:\n          CollisionResult closest = results.getClosestCollision();\n          mark.setLocalTranslation(closest.getContactPoint());\n          // Let\'s interact - we mark the hit with a red dot.\n          rootNode.attachChild(mark);\n        } else {\n        // No hits? Then remove the red mark.\n          rootNode.detachChild(mark);\n        }\n      }\n    }\n  };\n')),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Tip:")," Notice how you use the provided method\n",Object(o.b)("inlineCode",{parentName:"p"},"results.getClosestCollision().getContactPoint()")," to determine the\n",Object(o.b)("em",{parentName:"p"},"closest"),' hit\'s location. If your game includes a "weapon or "spell that\ncan hit multiple targets, you could also loop over the list of results,\nand interact with each of them.'),Object(o.b)("h2",{id:"picking-action-using-mouse-pointer"},"Picking Action Using Mouse Pointer"),Object(o.b)("p",null,"The above example assumes that the player is aiming crosshairs (attached\nto the center of the screen) at the target. But you can change the\npicking code to allow you to freely click at objects in the scene with a\nvisible mouse pointer. In order to do this you have to convert the 2d\nscreen coordinates of the click to 3D world coordinates to get the start\npoint of the picking ray."),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Reset result list.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Get 2D click coordinates.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Convert 2D screen coordinates to their 3D equivalent.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Aim the ray from the clicked 3D location forwards into the scene.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Collect intersections between ray and all nodes into a results list."))),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"...\nCollisionResults results = new CollisionResults();\nVector2f click2d = inputManager.getCursorPosition().clone();\nVector3f click3d = cam.getWorldCoordinates(\n    click2d, 0f).clone();\nVector3f dir = cam.getWorldCoordinates(\n    click2d, 1f).subtractLocal(click3d).normalizeLocal();\nRay ray = new Ray(click3d, dir);\nshootables.collideWith(ray, results);\n...\n")),Object(o.b)("p",null,"Use this together with ",Object(o.b)("inlineCode",{parentName:"p"},"inputManager.setCursorVisible(true)")," to make\ncertain the cursor is visible."),Object(o.b)("p",null,"Note that since you now use the mouse for picking, you can no longer use\nit to rotate the camera. If you want to have a visible mouse pointer for\npicking in your game, you have to redefine the camera rotation mappings."),Object(o.b)("h1",{id:"exercises"},"Exercises"),Object(o.b)("p",null,"After a hit was registered, the closest object is identified as target,\nand marked with a red dot. Modify the code sample to solve these\nexercises:"),Object(o.b)("h2",{id:"exercise-1-magic-spell"},"Exercise 1: Magic Spell"),Object(o.b)("p",null,"Change the color of the closest clicked target!\\\nHere are some tips:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Go to the line where the closest target is indentified, and add your\nchanges after that.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"To change an object's color, you must first know its Geometry.\nIdentify the node by identifying the target's name."),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Use ",Object(o.b)("inlineCode",{parentName:"li"},"Geometry g = closest.getGeometry();")))),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Create a new color material and set the node's Material to this\ncolor."),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Look inside the ",Object(o.b)("inlineCode",{parentName:"li"},"makeCube()")," method for an example of how to set\nrandom colors.")))),Object(o.b)("h2",{id:"exercise-2-shoot-a-character"},"Exercise 2: Shoot a Character"),Object(o.b)("p",null,"Shooting boxes isn't very exciting -- can you add code that loads and\npositions a model in the scene, and shoot at it?"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Tip: You can use\n",Object(o.b)("inlineCode",{parentName:"p"},"Spatial golem = assetManager.loadModel(\u201cModels/Oto/Oto.mesh);"),"\nfrom the engine's jme3-test-data.jar.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Tip: Models are shaded! You need some light!"))),Object(o.b)("h2",{id:"exercise-3-pick-up-into-inventory"},"Exercise 3: Pick up into Inventory"),Object(o.b)("p",null,"Change the code as follows to simulate the player picking up objects\ninto the inventory: When you click once, the closest target is\nidentified and detached from the scene. When you click a second time,\nthe target is reattached at the location that you have clicked. Here are\nsome tips:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Create an inventory node to store the detached nodes temporarily.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"The inventory node is not attached to the rootNode.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"You can make the inventory visible by attaching the inventory node\nto the guiNode (which attaches it to the HUD). Note the following\ncaveats:"),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},'If your nodes use a lit Material (not "Unshaded.j3md), also add\na light to the guiNode.')),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Size units are pixels in the HUD, therefor a 2-wu cube is\ndisplayed only 2 pixels wide in the HUD. -- Scale it bigger!")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Position the nodes: The bottom left corner of the HUD is\n(0f,0f), and the top right corner is at\n(settings.getWidth(),settings.getHeight())."))))),Object(o.b)("p",null,"::: {.important}\nLink to user-proposed solutions:\n",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"../../jme3/beginner/solutions"}),"jme3:solutions"),"\\\nBe sure to try to solve them for yourself first!\n:::"),Object(o.b)("h1",{id:"conclusion"},"Conclusion"),Object(o.b)("p",null,"You have learned how to use ray casting to solve the task of determining\nwhat object a user selected on the screen. You learned that this can be\nused for a variety of interactions, such as shooting, opening, picking\nup and dropping items, pressing a button or lever, etc."),Object(o.b)("p",null,"Use your imagination from here:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"In your game, the click can trigger any action on the identified\nGeometry: Detach it and put it into the inventory, attach something\nto it, trigger an animation or effect, open a door or crate, -- etc.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"In your game, you could replace the red mark with a particle\nemitter, add an explosion effect, play a sound, calculate the new\nscore after each hit depending on what was hit -- etc."))),Object(o.b)("p",null,"Now, wouldn't it be nice if those targets and the floor were solid\nobjects and you could walk around between them? Let's continue to learn\nabout ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"../../jme3/beginner/hello_collision"}),"Collision Detection"),"."),Object(o.b)("p",null,"See also:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"../../jme3/beginner/hello_input_system"}),"Hello Input"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"../../jme3/advanced/mouse_picking"}),"Mouse Picking"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"../../jme3/advanced/collision_and_intersection"}),"Collision and\nIntersection")))))}h.isMDXComponent=!0},441:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return d}));var i=n(0),a=n.n(i);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=a.a.createContext({}),h=function(e){var t=a.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l({},t,{},e)),n},p=function(e){var t=h(e.components);return a.a.createElement(c.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},m=Object(i.forwardRef)((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,r=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=h(n),m=i,d=p["".concat(r,".").concat(m)]||p[m]||b[m]||o;return n?a.a.createElement(d,l({ref:t},c,{components:n})):a.a.createElement(d,l({ref:t},c))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var c=2;c<o;c++)r[c]=n[c];return a.a.createElement.apply(null,r)}return a.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);