(window.webpackJsonp=window.webpackJsonp||[]).push([[182],{321:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return c})),a.d(t,"metadata",(function(){return i})),a.d(t,"rightToc",(function(){return s})),a.d(t,"default",(function(){return b}));var n=a(1),r=a(9),o=(a(0),a(441)),c={},i={id:"jme3/advanced/custom_meshes",title:"custom_meshes",description:"![custom\\_mesh.png](/images/jme3/advanced/custom_mesh.png)",source:"@site/docs/jme3/advanced/custom_meshes.md",permalink:"/wikidemo/docs/jme3/advanced/custom_meshes",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/advanced/custom_meshes.md"},s=[{value:"The Mesh Object",id:"the-mesh-object",children:[]},{value:"Vertex Coordinates",id:"vertex-coordinates",children:[]},{value:"Texture Coordinates",id:"texture-coordinates",children:[]},{value:"Connecting the Dots",id:"connecting-the-dots",children:[]},{value:"Setting the Mesh Buffer",id:"setting-the-mesh-buffer",children:[]},{value:"Example: Vertex Colors",id:"example-vertex-colors",children:[]},{value:"Example: Using Meshes With Lighting.j3md",id:"example-using-meshes-with-lightingj3md",children:[]},{value:"Example: Point Mode",id:"example-point-mode",children:[]}],l={rightToc:s};function b(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(n.a)({},l,a,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,Object(o.b)("img",Object(n.a)({parentName:"p"},{src:"/images/jme3/advanced/custom_mesh.png",alt:"custom_mesh.png"}))),Object(o.b)("p",null,"Use the Mesh class to create custom shapes that go beyond Quad, Box,\nCylinder, and Sphere, even procedural shapes are possible. Thank you to\nKayTrance for providing the sample code!"),Object(o.b)("p",null,"::: {.note}\nIn this tutorial, we (re)create a very simple rectangular mesh (a quad),\nand we have a look at different ways of coloring it. Coding a custom\nquad may not be very useful because it's exactly the same as the\nbuilt-in ",Object(o.b)("inlineCode",{parentName:"p"},"com.jme3.scene.shape.Quad"),". We chose a simple quad to teach\nyou how to build any shape out of triangles, without the distractions of\nmore complex shapes.\n:::"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Full code sample:\n",Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/model/shape/TestCustomMesh.java"}),"TestCustomMesh.java"))),Object(o.b)("h1",{id:"polygon-meshes"},"Polygon Meshes"),Object(o.b)("p",null,"Polygon ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/advanced/mesh"}),"mesh"),"es are made up of triangles.\nThe corners of the triangles are called vertices. When ever you create\nany new shape, you break it down into triangles."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Example:")," Let's look at a cube. A cube is made up of 6 rectangles.\nEach rectangle can be broken down into two triangles. This means you\nneed 12 triangles to describe a cube mesh. Therefor you must provide the\ncoordinates of the triangles\\' 8 corners (called vertices)."),Object(o.b)("p",null,"The important thing is that you have to specify the vertices of each\ntriangle in the right order: Each triangle separately,\ncounter-clockwise."),Object(o.b)("p",null,"Sounds harder than it is -- let's create a simple custom mesh, a quad."),Object(o.b)("h1",{id:"creating-a-quad-mesh"},"Creating a Quad Mesh"),Object(o.b)("p",null,"In this tutorial we want to create a 3x3 Quad. The quad has four\nvertices, and is made up of two triangles. In our example, we decide\nthat the bottom left corner is at 0/0/0 and the top right is at 3/3/0."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"0,3,0--3,3,0\n| \\        |\n|   \\      |\n|     \\    |\n|       \\  |\n|         \\|\n0,0,0--3,0,0\n")),Object(o.b)("h2",{id:"the-mesh-object"},"The Mesh Object"),Object(o.b)("p",null,"The base class for creating meshes is ",Object(o.b)("inlineCode",{parentName:"p"},"com.jme3.scene.Mesh"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"Mesh mesh = new Mesh();\n")),Object(o.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(o.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(o.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"If you create your own Mesh-based class\n(",Object(o.b)("inlineCode",{parentName:"p"},"public class MyMesh extends Mesh {  }"),"), replace the variable ",Object(o.b)("inlineCode",{parentName:"p"},"mesh"),"\nby ",Object(o.b)("inlineCode",{parentName:"p"},"this")," in the following examples."))),Object(o.b)("h2",{id:"vertex-coordinates"},"Vertex Coordinates"),Object(o.b)("p",null,"To define your own shape, determine the shape's ",Object(o.b)("strong",{parentName:"p"},"vertex coordinates"),"\nin 3D space. Store the list of corner positions in an\n",Object(o.b)("inlineCode",{parentName:"p"},"com.jme3.math.Vector3f")," array. For a Quad, we need four vertices:\nBottom left, bottom right, top left, top right. We name the array\n",Object(o.b)("inlineCode",{parentName:"p"},"vertices[]"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"Vector3f [] vertices = new Vector3f[4];\nvertices[0] = new Vector3f(0,0,0);\nvertices[1] = new Vector3f(3,0,0);\nvertices[2] = new Vector3f(0,3,0);\nvertices[3] = new Vector3f(3,3,0);\n")),Object(o.b)("h2",{id:"texture-coordinates"},"Texture Coordinates"),Object(o.b)("p",null,"Next, we define the Quad's 2D ",Object(o.b)("strong",{parentName:"p"},"texture coordinates")," for each vertex,\nin the same order as the vertices: Bottom left, bottom right, top left,\ntop right. We name this Vector2f array ",Object(o.b)("inlineCode",{parentName:"p"},"texCoord[]")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"Vector2f[] texCoord = new Vector2f[4];\ntexCoord[0] = new Vector2f(0,0);\ntexCoord[1] = new Vector2f(1,0);\ntexCoord[2] = new Vector2f(0,1);\ntexCoord[3] = new Vector2f(1,1);\n")),Object(o.b)("p",null,"This syntax means, when you apply a texture to this mesh, the texture\nwill fill the quad from corner to corner at 100% percent size.\nEspecially when you stitch together a larger mesh, you use this to tell\nthe renderer whether, and how exactly, you want to cover the whole mesh.\nE.g. if you use .5f or 2f as texture coordinates instead of 1f, textures\nwill be stretched or shrunk accordingly."),Object(o.b)("h2",{id:"connecting-the-dots"},"Connecting the Dots"),Object(o.b)("p",null,"Next we turn these unrelated coordinates into ",Object(o.b)("strong",{parentName:"p"},"triangles"),": We define\nthe order in which each triangle is constructed. Think of these indexes\nas coming in groups of three. Each group of indexes describes one\ntriangle. If the corners are identical, you can (and should!) reuse an\nindex for several triangles."),Object(o.b)("p",null,"Remember that you must specify the vertices counter-clockwise."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"int [] indexes = { 2,0,1, 1,3,2 };\n")),Object(o.b)("p",null,"This syntax means:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"The indices 0,1,2,3 stand for the four vertices that you specified\nfor the quad in ",Object(o.b)("inlineCode",{parentName:"p"},"vertices[]"),".")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"The 2,0,1 triangle starts at top left, continues bottom left, and\nends at bottom right.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"The 1,3,2 triangle start at bottom right, continues top right, and\nends at top left."))),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-{=html}"}),"\x3c!-- --\x3e\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"2\\2--3\n| \\  | Counter-clockwise\n|  \\ |\n0--1\\1\n")),Object(o.b)("p",null,"If the shape is more complex, it has more triangles, and therefor also\nmore vertices/indices. Just continue expanding the list by adding groups\nof three indices for each triangle. (For example a three-triangle \"house\nshape has 5 vertices/indices and you'd specify three groups:\n",Object(o.b)("inlineCode",{parentName:"p"},"int [] indexes = { 2,0,1, 1,3,2, 2,3,4 };"),".)"),Object(o.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(o.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(o.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"If you get the order wrong (clockwise) for some of the triangles, then\nthese triangles face backwards. If the\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/advanced/spatial"}),"Spatial"),"\\'s material uses the default\n",Object(o.b)("inlineCode",{parentName:"p"},"FaceCullMode.Back"),' (see "face culling), the broken triangles appear as\nholes in the rendered mesh. You need to identify and fix them in your\ncode.'))),Object(o.b)("h2",{id:"setting-the-mesh-buffer"},"Setting the Mesh Buffer"),Object(o.b)("p",null,"You store the Mesh data in a buffer."),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Using ",Object(o.b)("inlineCode",{parentName:"p"},"com.jme3.util.BufferUtils"),", we create three buffers for the\nthree types of information we have:"),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"vertex coordinates,")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"texture coordinates,")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"indices.")))),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"We assign the data to the appropriate type of buffer inside the\n",Object(o.b)("inlineCode",{parentName:"p"},"Mesh")," object. The three buffer types (",Object(o.b)("inlineCode",{parentName:"p"},"Position"),", ",Object(o.b)("inlineCode",{parentName:"p"},"TextCoord"),",\n",Object(o.b)("inlineCode",{parentName:"p"},"Index"),") are taken from an enum in\n",Object(o.b)("inlineCode",{parentName:"p"},"com.jme3.scene.VertexBuffer.Type"),".")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"The integer parameter describes the number of components of the\nvalues. Vertex postions are 3 float values, texture coordinates are\n2 float values, and the indices are 3 ints representing 3 vertices\nin a triangle.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"To render the mesh in the scene, we need to pre-calculate the\nbounding volume of our new mesh: Call the ",Object(o.b)("inlineCode",{parentName:"p"},"updateBound()")," method on\nit."))),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"mesh.setBuffer(Type.Position, 3, BufferUtils.createFloatBuffer(vertices));\nmesh.setBuffer(Type.TexCoord, 2, BufferUtils.createFloatBuffer(texCoord));\nmesh.setBuffer(Type.Index,    3, BufferUtils.createIntBuffer(indexes));\nmesh.updateBound();\n")),Object(o.b)("p",null,"Our Mesh is ready! Now we want to see it."),Object(o.b)("h1",{id:"using-the-mesh-in-a-scene"},"Using the Mesh in a Scene"),Object(o.b)("p",null,"We create a ",Object(o.b)("inlineCode",{parentName:"p"},"com.jme3.scene.Geometry")," and ",Object(o.b)("inlineCode",{parentName:"p"},"com.jme3.material.Material"),"\nfrom our ",Object(o.b)("inlineCode",{parentName:"p"},"mesh"),", apply a simple color material to it, and attach it to\nthe rootNode to make it appear in the scene."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'Geometry geo = new Geometry("OurMesh", mesh); // using our custom mesh object\nMaterial mat = new Material(assetManager,\n    "Common/MatDefs/Misc/Unshaded.j3md");\nmat.setColor("Color", ColorRGBA.Blue);\ngeo.setMaterial(mat);\nrootNode.attachChild(geo);\n')),Object(o.b)("p",null,"Library for assetManager? Ta-daa!"),Object(o.b)("h1",{id:"using-a-quad-instead"},"Using a Quad instead"),Object(o.b)("p",null,"We created a quad Mesh it can be replace by a Quad such as :"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'Quad quad = new Quad(1,1); // replace the definition of Vertex and Textures Coordinates plus indexes\nGeometry geo = new Geometry("OurQuad", quad); // using Quad object\nMaterial mat = new Material(assetManager,\n    "Common/MatDefs/Misc/Unshaded.j3md");\nmat.setColor("Color", ColorRGBA.Blue);\ngeo.setMaterial(mat);\nrootNode.attachChild(geo);\n')),Object(o.b)("p",null,"If you want to change the Textures Coordinates, in order to change the\nscale of the texture, use :"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"Quad quad = new Quad(1,1);\nquad.scaleTextureCoordinates(new Vector2f(width , height));\n")),Object(o.b)("h1",{id:"dynamic-meshes"},"Dynamic Meshes"),Object(o.b)("p",null,"If you are modifying a mesh dynamically in a way which changes the\nmodel's bounds, you need to update it:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Call ",Object(o.b)("inlineCode",{parentName:"p"},"updateBound()")," on the mesh object, or")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Call ",Object(o.b)("inlineCode",{parentName:"p"},"updateModelBound()")," on the Geometry object containing the\nmesh - which in turns calls ",Object(o.b)("inlineCode",{parentName:"p"},"updateBound()")," on the mesh."))),Object(o.b)("p",null,"The updateModelBound() method warns you about not usually needing to use\nit, but that can be ignored in this special case."),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"N.B.: This does not work on TerrainQuad. Please use the\nTerrainQuad.adjustHeight() function to edit the TerrainQuad mesh\ninstead. Additionally, if you want to use collisions on them afterwards,\nyou need to call TerrainPatch.getMesh().createCollisionData(); to update\nthe collision data, else it will collide with what seems to be the old\nmesh.")),Object(o.b)("h1",{id:"optional-mesh-features"},"Optional Mesh Features"),Object(o.b)("p",null,"There are more vertex buffers in a Mesh than the three shown above. For\nan overview, see also ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/advanced/mesh"}),"mesh"),"."),Object(o.b)("h2",{id:"example-vertex-colors"},"Example: Vertex Colors"),Object(o.b)("p",null,"Vertex coloring is a simple way of coloring meshes. Instead of just\nassigning one solid color, each vertex (corner) has a color assigned.\nThe faces between the vertices are then colored with a gradient. For\nthis demo, you can use the same mesh ",Object(o.b)("inlineCode",{parentName:"p"},"mesh")," object that you defined\nabove."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'Geometry geo = new Geometry ("ColoredMesh", mesh); // using the custom mesh\nMaterial matVC = new Material(assetManager, "Common/MatDefs/Misc/Unshaded.j3md");\nmatVC.setBoolean("VertexColor", true);\n')),Object(o.b)("p",null,"You create a float array color buffer:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Assign 4 color values, RGBA, to each vertex."),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"To loop over the 4 color values, use a color index")))),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-{=html}"}),"\x3c!-- --\x3e\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"int colorIndex = 0;\n")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"The color buffer contains four color values for each vertex."),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"The Quad in this example has 4 vertices.")))),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-{=html}"}),"\x3c!-- --\x3e\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"float[] colorArray = new float[4*4];\n")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Tip: If your mesh has a different number of vertices, you would\nwrite:")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-{=html}"}),"\x3c!-- --\x3e\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"float[] colorArray = new float[yourVertexCount * 4]\n")),Object(o.b)("p",null,"Loop over the colorArray buffer to quickly set some RGBA value for each\nvertex. As usual, RGBA color values range from 0.0f to 1.0f. ",Object(o.b)("strong",{parentName:"p"},"Note that\nthe color values in this example are arbitrarily chosen.")," It's just a\nquick loop to give every vertex a different RGBA value (a purplish gray,\npurple, a greenish gray, green, see screenshot), without writing too\nmuch code. For your own mesh, you'd assign meaningful values for the\ncolor buffer depending on which color you want your mesh to have."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"// note: the red and green values are arbitray in this example\nfor(int i = 0; i < 4; i++){\n   // Red value (is increased by .2 on each next vertex here)\n   colorArray[colorIndex++]= 0.1f+(.2f*i);\n   // Green value (is reduced by .2 on each next vertex)\n   colorArray[colorIndex++]= 0.9f-(0.2f*i);\n   // Blue value (remains the same in our case)\n   colorArray[colorIndex++]= 0.5f;\n   // Alpha value (no transparency set here)\n   colorArray[colorIndex++]= 1.0f;\n}\n")),Object(o.b)("p",null,"Next, set the color buffer. An RGBA color value contains four float\ncomponents, thus the parameter ",Object(o.b)("inlineCode",{parentName:"p"},"4"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"mesh.setBuffer(Type.Color, 4, colorArray);\ngeo.setMaterial(matVC);\n")),Object(o.b)("p",null,"When you run this code, you see a gradient color extending from each\nvertex."),Object(o.b)("h2",{id:"example-using-meshes-with-lightingj3md"},"Example: Using Meshes With Lighting.j3md"),Object(o.b)("p",null,"The previous examples used the mesh together with the ",Object(o.b)("inlineCode",{parentName:"p"},"Unshaded.j3md"),"\nmaterial. If you want to use the mesh with a Phong illuminated material\n(such as ",Object(o.b)("inlineCode",{parentName:"p"},"Lighting.j3md"),"), the mesh must include information about its\nNormals. (Normal Vectors encode in which direction a mesh polygon is\nfacing, which is important for calculating light and shadow!)"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"float[] normals = new float[12];\nnormals = new float[]{0,0,1, 0,0,1, 0,0,1, 0,0,1};\nmesh.setBuffer(Type.Normal, 3, BufferUtils.createFloatBuffer(normals));\n")),Object(o.b)("p",null,"You need to specify as many normals as the polygon has vertices. For a\nflat quad, the four normals point in the same direction. In this case,\nthe direction is the Z unit vector (0,0,1), this means our quad is\nfacing the camera."),Object(o.b)("p",null,"If the mesh is more complex or rounded, calculate cross products of\nneighbouring vertices to identify normal vectors!"),Object(o.b)("h2",{id:"example-point-mode"},"Example: Point Mode"),Object(o.b)("p",null,"Additionally to coloring the faces as just described, you can hide the\nfaces and show only the vertices as colored corner points."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'Geometry coloredMesh = new Geometry ("ColoredMesh", cMesh);\n...\nmesh.setMode(Mesh.Mode.Points);\nmesh.updateBound();\nmesh.setStatic();\nGeometry points = new Geometry("Points", mesh);\npoints.setMaterial(mat);\nrootNode.attachChild(points);\nrootNode.attachChild(geo);\n')),Object(o.b)("p",null,"This will result in a 10 px dot being rendered for each of the four\nvertices. The dot has the vertex color you specified above. The Quad's\nfaces are not rendered at all in this mode. You can use this to\nvisualize a special debugging or editing mode in your game."),Object(o.b)("h1",{id:"debugging-tip-culling"},"Debugging Tip: Culling"),Object(o.b)("p",null,'By default, jME3 optimizes a mesh by "backface culling, this means not\ndrawing the inside. It determines the side of a triangle by the order of\nthe vertices: The frontface is the face where the vertices are specified\ncounter-clockwise.'),Object(o.b)("p",null,"This means for you that, by default, your custom mesh is invisible when\nseen from \"behind or from the inside. This may not be a problem,\ntypically this is even intended, because it's faster. The player will\nnot look at the inside of most things anyway. For example, if your\ncustom mesh is a closed polyhedron, or a flat wallpaper-like object,\nthen rendering the backfaces (the inside of the pillar, the back of the\npainting, etc) would indeed be a waste of resources."),Object(o.b)("p",null,"In case however that your usecase requires the backfaces be visible, you\nhave two options:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"If you have a very simple scene, you can simply deactivate backface\nculling for this one mesh's material.")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-{=html}"}),"\x3c!-- --\x3e\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"mat.getAdditionalRenderState().setFaceCullMode(FaceCullMode.Off);\n")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Another solution for truly double-sided meshes is to specify each\ntriangle twice, the second time with the opposite order of vertices.\nThe second (reversed) triangle is a second frontface that covers up\nthe culled backface.")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-{=html}"}),"\x3c!-- --\x3e\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"int[] indexes = { 2,0,1, 1,3,2, 2,3,1, 1,0,2 };\n")),Object(o.b)("p",null,"See also:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/advanced/spatial"}),"Spatial")," -- contains more info\nabout how to debug custom meshes (that do not render as expected) by\nchanging the default culling behaviour.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/advanced/mesh"}),"Mesh")," -- more details about advanced\nMesh properties"))))}b.isMDXComponent=!0},441:function(e,t,a){"use strict";a.d(t,"a",(function(){return u})),a.d(t,"b",(function(){return p}));var n=a(0),r=a.n(n);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function c(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?c(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):c(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=r.a.createContext({}),b=function(e){var t=r.a.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i({},t,{},e)),a},u=function(e){var t=b(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=Object(n.forwardRef)((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=b(a),d=n,p=u["".concat(c,".").concat(d)]||u[d]||h[d]||o;return a?r.a.createElement(p,i({ref:t},l,{components:a})):r.a.createElement(p,i({ref:t},l))}));function p(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,c=new Array(o);c[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:n,c[1]=i;for(var l=2;l<o;l++)c[l]=a[l];return r.a.createElement.apply(null,c)}return r.a.createElement.apply(null,a)}d.displayName="MDXCreateElement"}}]);