(window.webpackJsonp=window.webpackJsonp||[]).push([[234],{373:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return r})),a.d(t,"metadata",(function(){return l})),a.d(t,"rightToc",(function(){return s})),a.d(t,"default",(function(){return d}));var n=a(1),o=a(9),i=(a(0),a(441)),r={},l={id:"jme3/advanced/jme3_shadernodes",title:"jme3_shadernodes",description:"Motivations",source:"@site/docs/jme3/advanced/jme3_shadernodes.md",permalink:"/wikidemo/docs/jme3/advanced/jme3_shadernodes",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/advanced/jme3_shadernodes.md"},s=[{value:"Example",id:"example",children:[]},{value:"Declare an array",id:"declare-an-array",children:[]}],c={rightToc:s};function d(e){var t=e.components,a=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(n.a)({},c,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h1",{id:"motivations"},"Motivations"),Object(i.b)("p",null,"jME3 material system is entirely based on shaders. While it's pretty\npowerful, this system has some issues and limitations :"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Monolithic shaders have a serious lack of flexibility, and it can be\ndaunting to get into the code for inexperienced users.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Maintenance ease of such shaders is poor. (for example the whole\nlighting shaders represent around 500 lines of code, and it could be\na lot worse with more features)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Adding new features to those shaders decrease the ease of\nmaintenance a lot. This point made us reluctant to do so and some\nfeature were never added (Fog to name it, but many more).")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Users can't add their own feature to the shader unless they fork it,\nand fall back to the same issues explained in previous points."))),Object(i.b)("p",null,'Shader Nodes were designed with this in mind and are the fruit of many\nlong discussions in the core chat balancing the pros and cons of this or\nthat pattern.\\\nAt first this system was referred to as "Shader injection. The basic\nidea was to allow users to inject code into shaders with a tag\nreplacement system.\\\nWe finally came with a different concept called Shader Nodes, that is\ninspired from blender nodes system for textures and post process.\\\n',Object(i.b)("strong",{parentName:"p"},"The final shader is generated at run time by the system by assembling\nshader nodes together.")),Object(i.b)("h1",{id:"what-is-a-shader-node"},"What is a Shader Node?"),Object(i.b)("p",null,"Conceptually, it's just a self sufficient piece of glsl code that\naccepts inputs and produce some outputs.\\\nInputs are glsl variables that may be fed by previous nodes output\nvalues.\\\nOutputs are glsl variables fed with values computed in the shader node\ncode.\\"),Object(i.b)("p",null,"In practice it's a bit more than that.A shader node is declined in\nseveral parts :"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"A shader node definition, defining :"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"The type of shader node (Vertex or Fragment for now)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"The minimal glsl version needed for the shader node")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"The path to the shader file (containing the shader code heh)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"A mandatory documentation block")," for this Shader node. As I\nhope many users will do their own nodes and contribute them back\nthis point is crucial.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"A list of inputs accepted by this shader (typed glsl variable\noptional or needed for the code to run properly)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"A list of outputs produced by this shader (typed glsl variable\ncomputed and fed by the node's code)")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"The actual shader code file (.vert or .frag depending on the node's\ntype like any shader file)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"A shader node declaration having :"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"A unique name(in the shader scope)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"The shader node definition it's based on")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"An optional activation condition (based on the actual define\nsystem)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"A list of input mapping (what will be actually fed to those\ninputs)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"A list of output mapping (what will be output to the global\noutput of the shader)"))))),Object(i.b)("h1",{id:"shader-node-definition"},"Shader Node definition"),Object(i.b)("p",null,"First ShaderNodes have to be defined either in a separate file (j3sn for\njme3 shader node) or directly embed in the Technique block of the j3md\nfile.\\\nPlease refer to this documentation for global structure of a j3md file\n",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/advanced/material_specification"}),"jMonkeyEngine3 Material\nSpecification")),Object(i.b)("p",null,"All is included in a ",Object(i.b)("strong",{parentName:"p"},"ShaderNodeDefinitions")," bloc. This block can have\nseveral nodes defined (it's recommended to define nodes that have strong\ndependencies with each other in the same j3sn file).\\\nA ShaderNode is declared in a ",Object(i.b)("strong",{parentName:"p"},"ShaderNodeDefinition")," block.\\\nThe global structure should look like this :"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"ShaderNodeDefinitions{\n      ShaderNodeDefinition <NodeDefName>{\n            Type : <ShaderType>\n            Shader <ShaderLangAndVersion> : <ShaderPath>\n            [Shader <ShaderLangAndVersion> : <ShaderPath>]\n            [...]\n            Documentation {\n                <DocContent>\n            }\n            Input {\n                <GlslVarType> <VarName>\n                [<GlslVarType> <VarName>]\n                [...]\n            }\n            Output {\n                <GlslVarType> <VarName>\n                [<GlslVarType> <VarName>]\n                [...]\n            }\n      }\n      [ShaderNodeDefinition <NodeDef2Name> {\n         [...]\n      }]\n      [...]\n}\n")),Object(i.b)("p",null,"All that is not between ","[","]"," is mandatory."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"ShaderNodeDefinition : the definition block. You can have several\ndefinition in the same ShaderNodeDefinitions block."),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"NodeDefName")," : The name of this ShaderNodeDefinition"))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Type : define the type of this shader node"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"ShaderType"),' : The type of shader for this definition. For now\nonly "Vertex and "Fragment are supported.'))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Shader : the version and path of the shader code to use. note that\nyou can have several shader with different GLSL version. The\ngenerator will pick the relevant one according to GPU capabilities."),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"ShaderLangAndVersion")," : follows the same syntax than the\nshader declaration in the j3md file : GLSL\\<version",">",", version\nbeing 100 for glsl 1.0 , 130 for glsl 1.3, 150 for glsl 1.5 and\nso on. Note that this is the ",Object(i.b)("strong",{parentName:"p"},"minimum")," glsl version this\nshader supports")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"ShaderPath")," the path to the shader code file (relative to the\nasset folder)")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Documentation : the documentation block. This is mandatory and I\nreally recommend filling this if you want to contribute your shader\nnodes. This documentation will be read buy the SDK and presented to\nusers willing to add this node to their material definitions. This\nshould contain a brief description of the node and a description for\neach input and ouput."),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"\\@input")," can be use to prefix an input name so the sdk\nrecognize it and format it accordingly. the syntax id \\@input\n\\<inputName",">"," \\<description",">",".")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"\\@output")," can be use to prefix an output name so the sdk\nrecognize it and format it accordingly. the syntax id \\@output\n\\<inputName",">"," \\<description",">")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Input : The input block containing all the inputs of this node. A\nnode can have 1 or several inputs."),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"GlslVarType")," : a valid glsl variable type that will be used\nin the shader for this input. see\n",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"http://www.opengl.org/wiki/GLSL_Type"}),"http://www.opengl.org/wiki/GLSL_Type"),' and the "Declare an array\nchapter')),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"VarName")," : the name of the variable. Note that you can't have\nseveral inputs with the same name.")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Output : The output block containing all the outputs of this node. A\nnode can have 1 or several outputs."),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"GlslVarType")," : a valid glsl variable type that will be used\nin the shader for this input. see\n",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"http://www.opengl.org/wiki/GLSL_Type"}),"http://www.opengl.org/wiki/GLSL_Type"),' and the "Declare an array\nchapter')),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"VarName")," : the name of the variable. Note that you can't have\nseveral outputs with the same name."))))),Object(i.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"If you use the same name for an input and an ouput, the generator will\nconsider them as the SAME variable so they should be of the same glsl\ntype."))),Object(i.b)("h2",{id:"example"},"Example"),Object(i.b)("p",null,"Here is a typical shader node definition."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"ShaderNodeDefinitions{\n     ShaderNodeDefinition LightMapping{\n        Type: Fragment\n        Shader GLSL100: Common/MatDefs/ShaderNodes/LightMapping/lightMap.frag\n        Documentation {\n            This Node is responsible for multiplying a light mapping contribution to a given color.\n            @input texCoord the texture coordinates to use for light mapping\n            @input lightMap the texture to use for light mapping\n            @input color the color the lightmap color will be multiplied to\n            @output color the resulting color\n        }\n        Input{\n            vec2 texCoord\n            sampler2D lightMap\n            vec4 color\n        }\n        Output{\n            vec4 color\n        }\n    }\n}\n")),Object(i.b)("h2",{id:"declare-an-array"},"Declare an array"),Object(i.b)("p",null,"To declare an array you have to specify its size between square\nbrackets.\\\n",Object(i.b)("strong",{parentName:"p"},"Constant size"),"\\\nThe size can be an int constant.\\\n",Object(i.b)("em",{parentName:"p"},"Example")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"      float myArray[10]\n")),Object(i.b)("p",null,"This will declare a float array with 10 elements. Any material parameter\nmapped with this array should be of FloatArray type and it's size will\nbe assumed as 10 when the shader is generated."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Material parameter driven size"),"\\\nThe size can be dynamic and driven by a material parameter. GLSL does\nnot support non constant values for array declaration so this material\nparameter will be mapped to a define.\\\n",Object(i.b)("em",{parentName:"p"},"Example")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"     float myArray[NumberOfElements]\n")),Object(i.b)("p",null,"This declares a float array with the size depending on the value of the\nNumberOfElement material parameter.\\\nNumberOfElement ",Object(i.b)("strong",{parentName:"p"},"HAS")," to be declared in the material definition as a\nmaterial parameter. It will be mapped to a define and used in the\nshader."),Object(i.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"If this value change the shader will have to be recompiled, due to the\nfact that it's mapped to a define."))),Object(i.b)("h1",{id:"shader-node-code"},"Shader Node code"),Object(i.b)("p",null,'The shader code associated with a Shader node is similar to any shader\ncode.\\\nThe code for a Vertex shader node should be in a .vert file and the code\nfor a Fragment shader node should be in a .frag file. It has a\ndeclarative part containing variable declaration, function declaration\nand so on... And a main part that is embed in a "void main(){} block.\\\nInput and output variables declared in the shader node definition can be\nused ',Object(i.b)("strong",{parentName:"p"},"without")," being declared in the shader code. ( they shouldn't\neven or you'll have issues).\\\nHere is a the code of the LightMap.frag shader."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"void main(){\n    color *= texture2D(lightMap, texCoord);\n}\n")),Object(i.b)("p",null,"Very simple, it's just a texture fetch, but of course anything can be\ndone.\\\n",Object(i.b)("strong",{parentName:"p"},"Do not declare uniforms, attributes or varyings in a shader node\ncode"),", the Generator will handle this, just use the inputs and outputs\nand optional local variables you may need."),Object(i.b)("h1",{id:"shader-node-declaration"},"Shader Node declaration"),Object(i.b)("p",null,"To create a shader we need to plug shader nodes to each other, but also\ninteract with built in glsl inputs and outputs. Shader nodes are\ndeclared inside the Technique block. The vertex nodes are declared in\nthe VertexShaderNodes block and the fragment nodes are declared in the\nFragmentShaderNodes block.\\\nNote that if the j3md has ember shader nodes definition (in a\nShaderNodesDefinitions block) it ",Object(i.b)("strong",{parentName:"p"},"must")," be declared before the\nVertexShaderNodes and FragmentShaderNodes blocks. Of course there can be\nseveral ShaderNode declaration in those block.\\\nHere is how a ShaderNode declaration should look :"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"ShaderNode <ShaderNodeName>{\n     Definition : <DefinitionName> [: <DefinitionPath>]\n     [Condition : <ActivationCondition>]\n     InputMapping{\n          <InputVariableName>[.<Swizzle>] = <NameSpace>.<VarName>[.<Swizzle>] [: <MappingCondition>]\n          [...]\n     }\n     [OutputMapping{\n          <NameSpace>.<VarName>[.<Swizzle>] = <OutputVariableName>[.<Swizzle>] [: <MappingCondition>]\n          [...]\n     }]\n}\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"ShaderNode the shader node block"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"ShaderNodeName")," the name of this shader node, can be\nanything, but has to be ",Object(i.b)("strong",{parentName:"li"},"unique")," in the shader scope."))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Definition : a reference to the shader node definition."),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"DefinitionName")," : the name of the definition this Node use.\nthis definition can be declared in the same j3md or in its own\nj3sn file.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"DefinitionPath")," : in case the definition is declared in it's\nown j3sn file, you have to set the path to this file here.")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Condition a condition that dictates if the node is active or not."),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"ActivationCondition"),' : The condition for this node to be\nused. Today we use Defines to use different blocks of code used\ndepending on the state of a Material Parameter. The condition\nhere use the exact same paradigm. A valid condition must be the\nname of a material parameter or any combinations using logical\noperators "',"|","|",',"&&,"! or grouping characters "( and "). The\ngenerator will create the corresponding define and the shader\nnode code will be embed into and ',"#","ifdef statement.")))),Object(i.b)("p",null,"For example, let's say we have a Color and ColorMap material parameter,\nthis condition \"Color ","|","|"," ColorMap will generate this statement :"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"        #if defined(COLOR) || defined(COLORMAP)\n            ...\n        #endif\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"InputMapping the wiring of the inputs of this node, coming from\nprevious node's outputs or from built in glsl inputs."),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"InputVariableName")," : the name of the variable to map as\ndeclared in the definition.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Swizzle")," : Swizling for the preceding variable. More\ninformation on glsl swizzling on this page\n",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"http://www.opengl.org/wiki/GLSL_Type"}),"http://www.opengl.org/wiki/GLSL_Type"),".")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"NameSpace")," : The generator will use variable name space to\navoid collision between variable names. Name space can be one of\nthese values :"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"MatParam")," : the following variable is a Material\nParameter declared in the MaterialParameters block of the\nmaterialDefinition.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"WorldParam")," : the following variable is a World Parameter\ndeclared in the WorldParameters block of the current\ntechnique block. World parameters can be one of those\ndeclared in this file :\n",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-core/src/main/java/com/jme3/shader/UniformBinding.java"}),"https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-core/src/main/java/com/jme3/shader/UniformBinding.java"))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Attr")," : the following variable is a shader attribute. It\ncan be one those declared in the Type enum of the\nVertexBuffer class\n",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-core/src/main/java/com/jme3/scene/VertexBuffer.java"}),"https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-core/src/main/java/com/jme3/scene/VertexBuffer.java"),".")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Global")," : the variable is a global variable to the\nshader. Global variables will be assign at the end of the\nshader to glsl built in outputs : gl","_","Position for the\nvertex shader, or to one of the possible outputs of the\nfragment shader (for example gl","_","FragColor). The global\nvariable can have what ever name pleases you, it will\nassigned in the order they've been found in the declaration\nto the shader output. ",Object(i.b)("strong",{parentName:"p"},"Global variables can be inputs of a\nshader node. Global variables are forced to be vec4 and are\ndefaulted to the value of the attribute inPosition in the\nvertex shader and vec4(1.0)(opaque white color) in the\nfragment shader"),".")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"The name of a previous shader node")," : this must be\nfollowed by and output variable of a the named shader node.\nThis is what allows one to plug outputs from a node to\ninputs of another.")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"VarName")," : the name of the variable to assign to the input.\nThis variable must be known in name space declared before.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"MappingCondition")," : Follows the same rules as the activation\ncondition for the shaderNode, this mapping will be embed in a\n","#","ifdef statement n the resulting shader.")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"OutputMapping : This block is optional, as mapping of output will be\ndone in input mapping block of following shaderNodes, ecept if you\nwant to output a value to the Global output of the shader."),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"NameSpace"),' : the name space of the output to assign, this can\nonly be "Global here.')),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"VarName")," : the name of a global output (can be anything, just\nbe aware that 2 different names result in 2 different outputs).")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"OutputVariable")," : Must be an output of the current node's\ndefinition.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"MappingCondition")," : Same as before."))))),Object(i.b)("h1",{id:"complete-material-definition-and-shader-nodes-example"},"Complete material definition and Shader Nodes example"),Object(i.b)("p",null,"Here is an example of a very simple Material definition that just\ndisplays a solid color (controlled by a material parameter) on a mesh."),Object(i.b)("p",null,"::: {.important}\nShader Nodes only work if there is no shader declared in the technique.\nIf you want to bypass the Shader Nodes, you can put a VertexShader and a\nFragmentShader statement in the technique and the shader nodes will be\nignored.\n:::"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"MaterialDef Simple {\n    MaterialParameters {\n        Color Color\n    }\n    Technique {\n        WorldParameters {\n            WorldViewProjectionMatrix\n        }\n        VertexShaderNodes {\n            ShaderNode CommonVert {\n                Definition : CommonVert : Common/MatDefs/ShaderNodes/Common/CommonVert.j3sn\n                InputMappings {\n                    worldViewProjectionMatrix = WorldParam.WorldViewProjectionMatrix\n                    modelPosition = Global.position.xyz\n                }\n                OutputMappings {\n                    Global.position = projPosition\n                }\n            }\n        }\n        FragmentShaderNodes {\n            ShaderNode ColorMult {\n                Definition : ColorMult : Common/MatDefs/ShaderNodes/Basic/ColorMult.j3sn\n                InputMappings {\n                    color1 = MatParam.Color\n                    color2 = Global.color\n                }\n                OutputMappings {\n                    Global.color = outColor\n                }\n            }\n        }\n    }\n}\n")),Object(i.b)("p",null,"This Material definition has one Default technique with 2 node\ndeclarations.\\\n",Object(i.b)("strong",{parentName:"p"},"CommonVert Definition"),"\\\nCommonVert is a vertex shader node that has commonly used input and\noutputs of a vertex shader. It also computes the position of the vertex\nin projection space.\\\nHere is the definition content\n(Common/MatDefs/ShaderNodes/Common/CommonVert.j3sn) :"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"ShaderNodesDefinitions {\n    ShaderNodeDefinition CommonVert {\n        Type: Vertex\n        Shader GLSL100: Common/MatDefs/ShaderNodes/Common/commonVert.vert\n        Documentation {\n            This Node is responsible for computing vertex position in projection space.\n            It also can pass texture coordinates 1 & 2, and vertexColor to the frgment shader as varying (or inputs for glsl >=1.3)\n            @input modelPosition the vertex position in model space (usually assigned with Attr.inPosition or Global.position)\n            @input worldViewProjectionMatrix the World View Projection Matrix transforms model space to projection space.\n            @input texCoord1 The first texture coordinates of the vertex (usually assigned with Attr.inTexCoord)\n            @input texCoord2 The second texture coordinates of the vertex (usually assigned with Attr.inTexCoord2)\n            @input vertColor The color of the vertex (usually assigned with Attr.inColor)\n            @output projPosition Position of the vertex in projection space.(usually assigned to Global.position)\n            @output vec2 texCoord1 The first texture coordinates of the vertex (output as a varying)\n            @output vec2 texCoord2 The second texture coordinates of the vertex (output as a varying)\n            @output vec4 vertColor The color of the vertex (output as a varying)\n        }\n        Input{\n            vec3 modelPosition\n            mat4 worldViewProjectionMatrix\n            vec2 texCoord1\n            vec2 texCoord2\n            vec4 vertColor\n        }\n        Output{\n            vec4 projPosition\n            vec2 texCoord1\n            vec2 texCoord2\n            vec4 vertColor\n        }\n    }\n}\n")),Object(i.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"Note that texCoord1/2 and vertColor are declared both as input and\noutput. The generator will use the same variables for them."))),Object(i.b)("p",null,"Here is the shader Node code (\nCommon/MatDefs/ShaderNodes/Common/commonVert.vert)."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"void main(){\n    projPosition = worldViewProjectionMatrix * vec4(modelPosition, 1.0);\n}\n")),Object(i.b)("p",null,"As you can see all the inputs and outputs are not used. That's because\nmost of them are attributes meant to be passed to the fragment shader as\nvaryings. All the wiring will be handled by the generator only if those\nvariables are used in an input or output mapping."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"CommonVert input mapping"),"\\\nHere we have the most basic yet mandatory thing in a vertex shader,\ncomputing vertex position in projection space. For this we have 2\nmappings :"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"worldViewProjectionMatrix = WorldParam.WorldViewProjectionMatrix"),"\n: the input parameter worldViewProjectionMatrix is assigned with the\nWorldViewProjectionMatrix World parameter declared in the\nWorlParameters block of the technique.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"modelPosition = Global.position.xyz")," : the modelPosition\n(understand the vertex position in the model coordinate space) is\nassigned with the Global position variable."))),Object(i.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"As mentioned before Global position is initialized with the attribute\ninPosition, so this is equivalent to :"),Object(i.b)("pre",{parentName:"div"},Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"modelPosition = Attr.inPosition.xyz\n")))),Object(i.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"Also note the swizzle of the Global.position variable. ModelPosition is\na vec3 and GlobalPosition is a vec4 so we just take the first 3\ncomponents."))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"CommonVert output mapping"),"\\"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Global.position = projPosition")," : The result of the\nmultiplication of the worldViewProjectionMatrix and the\nmodelPosition is assigned to the Globale position.")),Object(i.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"The Global.position variable will be assigned to the gl","_","Position glsl\nbuilt in output at the end of the shader."))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"ColorMult Definition"),"\\\nColorMult is a very basic Shader Node that takes two colors as input and\nmultiply them. Here is the definition content\n(Common/MatDefs/ShaderNodes/Basic/ColorMult.j3sn) :"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"ShaderNodeDefinitions{\n    ShaderNodeDefinition ColorMult {\n        Type: Fragment\n        Shader GLSL100: Common/MatDefs/ShaderNodes/Basic/colorMult.frag\n        Documentation{\n            Multiplies two colors\n            @input color1 the first color\n            @input color2 the second color\n            @output outColor the resulting color\n        }\n        Input {\n            vec4 color1\n            vec4 color2\n        }\n        Output {\n            vec4 outColor\n        }\n    }\n}\n")),Object(i.b)("p",null,"Here is the shader Node code\n(Common/MatDefs/ShaderNodes/Basic/colorMult.frag)."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"void main(){\n    outColor = color1 * color2;\n}\n")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"ColorMult input mapping"),"\\\nAll inputs are mapped here :"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"color1 = MatParam.Color")," : The first color is assigned to the\nColor Material parameter declared in the MaterialParameter block of\nthe material definition.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"color2 = Global.color")," : The second color is assigned with the\nGlobal color variable. this is defaulted to vec4(1.0) (opaque\nwhite)."))),Object(i.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"In a very complex material def this variable could already have been\nassigned with a previous Shader Node output."))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"ColorMult output mapping"),"\\"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Global.color = outColor")," : the resulting color is assigned to the\nGlobal color variable.")),Object(i.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"Note that the Global.color variable will be assigned to gl","_","FragColor\n(glsl \\< 1.5) or declared as a Global ouput of the shader (glsl ",">","=\n1.5)."))),Object(i.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"Also note that in case several Global variables are declared, the\ngenerator will assign them gl","_","FragData","[","i","]","(glsl \\< 1.5) i being the\norder the variable has been found in the material def. For glsl ",">","= 1.5\nthe veriable will just all be declared as shader output in the order\nthey've been found in the declaration."))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Generated shader code")),Object(i.b)("p",null,"::: {.important}\nDon't take this code as carved in stone, the generated code can change\nas optimization of the shader generator goes on.\n:::"),Object(i.b)("p",null,"Vertex Shader (glsl 1.0)"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"uniform mat4 g_WorldViewProjectionMatrix;\n\nattribute vec4 inPosition;\n\nvoid main(){\n        vec4 Global_position = inPosition;\n\n        //CommonVert : Begin\n        vec3 CommonVert_modelPosition = Global_position.xyz;\n        vec4 CommonVert_projPosition;\n        vec2 CommonVert_texCoord1;\n        vec2 CommonVert_texCoord2;\n        vec4 CommonVert_vertColor;\n\n        CommonVert_projPosition = g_WorldViewProjectionMatrix * vec4(CommonVert_modelPosition, 1.0);\n        Global_position = CommonVert_projPosition;\n        //CommonVert : End\n\n        gl_Position = Global_position;\n}\n")),Object(i.b)("p",null,"All materials parameter, world parameters, attributes varying are\ndeclared first. then for each shader node, the declarative part is\nappended.\\\nFor the main function, for each shader node, the input mappings are\ndeclared and assigned, the output are declared.\\\nThen the variable names are replaced in the sahder node code with there\ncomplete name (NameSpace","_","varName), material parameters are replaced in\nthe shader code as is.\\\nThen, the output are mapped."),Object(i.b)("p",null,"As you can see texCoord1/2 and vertColor are declared but never used.\nThat's because the generator is not aware of that. By default it will\ndeclare all inputs in case they are used in the shaderNode code. Note\nthat most glsl compiler will optimize this when compiling the shader on\nthe GPU."),Object(i.b)("p",null,"Fragment Shader (glsl 1.0)"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"uniform vec4 m_Color;\n\nvoid main(){\n        vec4 Global_color = vec4(1.0);\n\n        //ColorMult : Begin\n        vec4 ColorMult_color2 = Global_color;\n        vec4 ColorMult_outColor;\n\n        ColorMult_outColor = m_Color * ColorMult_color2;\n        Global_color = ColorMult_outColor;\n        //ColorMult : End\n\n        gl_FragColor = Global_color;\n}\n")),Object(i.b)("p",null,"Same as for the Vertex shader. Note that the color1 is not declared,\nbecause it's directly replaced by the material parameter."),Object(i.b)("p",null,"::: {.important}\nAs a rule of thumb you should not assign a value to an input. Inputs are\nlikely to be material paramters or outputs from other shaders and\nmodifying them may cause unexpected behavior, even failure in your\nresulting shader.\n:::"),Object(i.b)("p",null,"For more explanations and design decisions please refer to the spec here\n",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://docs.google.com/document/d/1S6xO3d1TBz0xcKe_MPTqY9V-QI59AKdg1OGy3U-HeVY/edit?usp=sharing"}),"https://docs.google.com/document/d/1S6xO3d1TBz0xcKe_MPTqY9V-QI59AKdg1OGy3U-HeVY/edit?usp=sharing"),"."),Object(i.b)("p",null,"Thank you for the brave ones that came through all this reading. I'm not\ngonna offer you a prize in exchange of a password, because we ran out of\nJME thongs..."))}d.isMDXComponent=!0},441:function(e,t,a){"use strict";a.d(t,"a",(function(){return b})),a.d(t,"b",(function(){return h}));var n=a(0),o=a.n(n);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var c=o.a.createContext({}),d=function(e){var t=o.a.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):l({},t,{},e)),a},b=function(e){var t=d(e.components);return o.a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},m=Object(n.forwardRef)((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,r=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),b=d(a),m=n,h=b["".concat(r,".").concat(m)]||b[m]||p[m]||i;return a?o.a.createElement(h,l({ref:t},c,{components:a})):o.a.createElement(h,l({ref:t},c))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,r=new Array(i);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:n,r[1]=l;for(var c=2;c<i;c++)r[c]=a[c];return o.a.createElement.apply(null,r)}return o.a.createElement.apply(null,a)}m.displayName="MDXCreateElement"}}]);