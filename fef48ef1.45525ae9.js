(window.webpackJsonp=window.webpackJsonp||[]).push([[299],{438:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return p}));var o=n(1),a=n(9),r=(n(0),n(441)),i={},s={id:"sdk/development/scene",title:"scene",description:"To reduce system overhead the jMonkeyEngine SDK Core supplies one",source:"@site/docs/sdk/development/scene.md",permalink:"/wikidemo/docs/sdk/development/scene",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/sdk/development/scene.md"},c=[],l={rightToc:c};function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(o.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"To reduce system overhead the jMonkeyEngine SDK Core supplies one\nscene/jme3 application that is shared between plugins. Furthermore\nthere's the \"SceneExplorer that shows a visual representation of the\nscenegraph and its objects properties across plugins."),Object(r.b)("h1",{id:"how-to-access-the-scene"},"How to access the Scene"),Object(r.b)("p",null,"There are several ways for your plugin to interact with the Scene:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"It listens for selected spatials / objects and offers options for\nthose")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"It requests the whole scene for itself and loads/arranges the\ncontent in it (e.g. a terrain editor or model animation plugin)."))),Object(r.b)("h1",{id:"listening-for-node-selection"},"Listening for Node selection"),Object(r.b)("p",null,'In the jMonkeyEngine SDK, all objects are wrapped into NetBeans "Nodes\n(different thing than jme Nodes!). Such nodes can have properties and\nicons and can be displayed and selected in the jMonkeyEngine SDK UI. The\nSceneExplorer shows a tree of Nodes that wrap the Spatials of the\ncurrent scene and allows manipulating their properties on selection. A\njME "Spatial is wrapped by a "JmeSpatial node, for example. One\nadvantage of these Nodes is that one can manipulate properties of\nSpatials directly from the AWT thread.'),Object(r.b)("p",null,"To listen to the current selection, implement\norg.openide.util.LookupListener and register like this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-java"}),'private final Result<JmeSpatial> result;\n\n//method to register the listener;\nprivate void registerListener(){\n    result = Utilities.actionsGlobalContext().lookupResult(JmeSpatial.class);\n    result.addLookupListener(this);\n}\n\n//implements org.openide.util.LookupListener (called from AWT thread)\npublic void resultChanged(LookupEvent ev) {\n    Collection<JmeSpatial> items = (Collection<JmeSpatial>) result.allInstances();\n    for (JmeSpatial jmeSpatial : items) {\n        //Using the JmeSpatials properties you can modify the spatial directly from the AWT thread:\n        jmeSpatial.getPropertySets()[0].setValue("Local Translation", Vector3f.ZERO);\n        return;\n    }\n}\n')),Object(r.b)("p",null,'You can also access the "real spatial but since its part of the\nscenegraph you will have to modify it on that thread:'),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-java"}),'//retrieve the "real" spatial class from the JmeNode\nfor (JmeSpatial jmeSpatial : items) {\n    //the spatial is stored inside the JmeSpatials "Lookup", a general container for Objects\n    final Spatial realSpatial = jmeSpatial.getLookup().lookup(Spatial.class);\n    //use a Callable to execute on the render thread:\n    SceneApplication.getApplication().enqueue(new Callable() {\n        public Object call() throws Exception {\n            realSpatial.setLocalTranslation(Vector3f.ZERO);\n            return null;\n        }\n    });\n    return;\n}\n')),Object(r.b)("h1",{id:"requesting-the-scene"},"Requesting the Scene"),Object(r.b)("p",null,"If your plugin wants to use the scene by itself, it first has to\nimplement SceneListener and register at the scene and then send a\nSceneRequest to the SceneApplication. When the SceneRequest has been\napproved and the current Scene has been closed, the SceneListener (your\nclass) is called with its own SceneRequest as a parameter. When another\nplugin sends a SceneRequest it is also reported to you and its a hint\nthat your RootNode has been removed from the Scene and you are no longer\nin control of it. You could also hook into the SceneRequests of other\nplugins to see if/when they are activated to display add-on plugins for\nthat plugin."),Object(r.b)("p",null,"+",' The SceneRequest object has to contain several things. A thing that\nyou must supply is a jme "Node wrapped into a "JmeNode object. This is\nyour rootNode that you use to display and build your scene. As soon as\nyou control the scene, you will have to control the camera etc.\nyourself.'),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-java"}),'com.jme3.scene.Node rootNode = new com.jme3.scene.Node("MyRootNode");\n\nprivate void registerSceneListener(){\n    SceneApplication.getApplication().addSceneListener(this);\n}\n\nprivate void requestScene(){\n    //create a jmeNode from the rootNode using the NodeUtility\n    JmeNode jmeNode = NodeUtility.createNode(rootNode);\n    //create the scene request\n    SceneRequest request=new SceneRequest(this, jmeNode, assetManager);\n    //request the scene\n    SceneApplication.getApplication().openScene(request);\n}\n\n//implements SceneListener (called from AWT thread)\npublic void sceneOpened(SceneRequest request){\n    //check if its our request\n    if (request.getRequester() == this) {\n        //we now own the scene, any operations on the scene have to be done via Callables\n    }\n}\n\npublic void sceneClosed(SceneRequest request) {\n    if (request.getRequester() == this) {\n        //we have to close the scene,  any operations on the scene have to be done via Callables\n    }\n}\n')),Object(r.b)("h1",{id:"undoredo-support"},"Undo/Redo support"),Object(r.b)("p",null,"The jMonkeyEngine SDK has a global undo/redo queue that activates the\nundo/redo buttons. To use it in your TopComponent, add the following\nmethod:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-java"}),"@Override\npublic UndoRedo getUndoRedo() {\nreturn Lookup.getDefault().lookup(SceneUndoRedoManager.class);\n}\n")),Object(r.b)("p",null,"To add a undo/redo event that modifies objects on the Scenegraph, theres\na special version of AbstractUndoableEdit which executes the undo/redo\ncalls on the scene thread. Simply implement that class and add it to the\nqueue like this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-java"}),"Lookup.getDefault().lookup(SceneUndoRedoManager.class).addEdit(this, new AbstractUndoableSceneEdit() {\n\n@Override\npublic void sceneUndo() {\n    //undo stuff in scene here\n}\n\n@Override\npublic void sceneRedo() {\n    //redo stuff in scene here\n}\n\n@Override\npublic void awtUndo() {\n    //undo stuff on awt thread here (updating of visual nodes etc, called post scene edit)\n}\n\n@Override\npublic void awtRedo() {\n    //redo stuff on awt thread here\n}\n});\n")),Object(r.b)("p",null,"Note: Its important that you use the method addEdit(Object source,\nUndoableEdit edit);"))}p.isMDXComponent=!0},441:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return b}));var o=n(0),a=n.n(o);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=a.a.createContext({}),p=function(e){var t=a.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s({},t,{},e)),n},u=function(e){var t=p(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},h=Object(o.forwardRef)((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),u=p(n),h=o,b=u["".concat(i,".").concat(h)]||u[h]||d[h]||r;return n?a.a.createElement(b,s({ref:t},l,{components:n})):a.a.createElement(b,s({ref:t},l))}));function b(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<r;l++)i[l]=n[l];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);