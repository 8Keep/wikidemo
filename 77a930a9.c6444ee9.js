(window.webpackJsonp=window.webpackJsonp||[]).push([[142],{281:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return r})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return p}));var a=n(1),i=n(9),o=(n(0),n(441)),l={},r={id:"jme3/beginner/hello_collision",title:"hello_collision",description:"Previous: [Hello Picking](../../jme3/beginner/hello_picking), Next:",source:"@site/docs/jme3/beginner/hello_collision.md",permalink:"/wikidemo/docs/jme3/beginner/hello_collision",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/beginner/hello_collision.md",sidebar:"main",previous:{title:"hello_picking",permalink:"/wikidemo/docs/jme3/beginner/hello_picking"},next:{title:"hello_terrain",permalink:"/wikidemo/docs/jme3/beginner/hello_terrain"}},s=[{value:"The Physics-Controlled Scene",id:"the-physics-controlled-scene",children:[]},{value:"The Physics-Controlled Player",id:"the-physics-controlled-player",children:[]},{value:"PhysicsSpace",id:"physicsspace",children:[]}],c={rightToc:s};function p(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Previous: ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/beginner/hello_picking"}),"Hello Picking"),", Next:\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/beginner/hello_terrain"}),"Hello Terrain")),Object(o.b)("p",null,"This tutorial demonstrates how you load a scene model and give it solid\nwalls and floors for a character to walk around. You use a\n",Object(o.b)("inlineCode",{parentName:"p"},"RigidBodyControl")," for the static collidable scene, and a\n",Object(o.b)("inlineCode",{parentName:"p"},"CharacterControl")," for the mobile first-person character. You also learn\nhow to set up the default first-person camera to work with\nphysics-controlled navigation. You can use the solution shown here for\nfirst-person shooters, mazes, and similar games."),Object(o.b)("p",null,Object(o.b)("img",Object(a.a)({parentName:"p"},{src:"../../../images/jme3/beginner/beginner-scene.png",alt:"beginner-scene.png"}))),Object(o.b)("h1",{id:"sample-code"},"Sample Code"),Object(o.b)("p",null,"If you don't have it yet, ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/wiki/raw/master/src/docs/resources/Scenes/Town/town.zip"}),"download the\ntown.zip"),"\nsample scene."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),"jMonkeyProjects$ ls -1 BasicGame\nassets/\nbuild.xml\ntown.zip\nsrc/\n")),Object(o.b)("p",null,"Place town.zip in the root directory of your JME3 project. Here is the\ncode:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'package jme3test.helloworld;\n\nimport com.jme3.app.SimpleApplication;\nimport com.jme3.asset.plugins.ZipLocator;\nimport com.jme3.bullet.BulletAppState;\nimport com.jme3.bullet.collision.shapes.CapsuleCollisionShape;\nimport com.jme3.bullet.collision.shapes.CollisionShape;\nimport com.jme3.bullet.control.CharacterControl;\nimport com.jme3.bullet.control.RigidBodyControl;\nimport com.jme3.bullet.util.CollisionShapeFactory;\nimport com.jme3.input.KeyInput;\nimport com.jme3.input.controls.ActionListener;\nimport com.jme3.input.controls.KeyTrigger;\nimport com.jme3.light.AmbientLight;\nimport com.jme3.light.DirectionalLight;\nimport com.jme3.math.ColorRGBA;\nimport com.jme3.math.Vector3f;\nimport com.jme3.scene.Node;\nimport com.jme3.scene.Spatial;\n\n/**\n * Example 9 - How to make walls and floors solid.\n * This collision code uses Physics and a custom Action Listener.\n * @author normen, with edits by Zathras\n */\npublic class HelloCollision extends SimpleApplication\n        implements ActionListener {\n\n  private Spatial sceneModel;\n  private BulletAppState bulletAppState;\n  private RigidBodyControl landscape;\n  private CharacterControl player;\n  private Vector3f walkDirection = new Vector3f();\n  private boolean left = false, right = false, up = false, down = false;\n\n  //Temporary vectors used on each frame.\n  //They here to avoid instanciating new vectors on each frame\n  private Vector3f camDir = new Vector3f();\n  private Vector3f camLeft = new Vector3f();\n\n  public static void main(String[] args) {\n    HelloCollision app = new HelloCollision();\n    app.start();\n  }\n\n  public void simpleInitApp() {\n    /** Set up Physics */\n    bulletAppState = new BulletAppState();\n    stateManager.attach(bulletAppState);\n    //bulletAppState.setDebugEnabled(true);\n\n    // We re-use the flyby camera for rotation, while positioning is handled by physics\n    viewPort.setBackgroundColor(new ColorRGBA(0.7f, 0.8f, 1f, 1f));\n    flyCam.setMoveSpeed(100);\n    setUpKeys();\n    setUpLight();\n\n    // We load the scene from the zip file and adjust its size.\n    assetManager.registerLocator("town.zip", ZipLocator.class);\n    sceneModel = assetManager.loadModel("main.scene");\n    sceneModel.setLocalScale(2f);\n\n    // We set up collision detection for the scene by creating a\n    // compound collision shape and a static RigidBodyControl with mass zero.\n    CollisionShape sceneShape =\n            CollisionShapeFactory.createMeshShape(sceneModel);\n    landscape = new RigidBodyControl(sceneShape, 0);\n    sceneModel.addControl(landscape);\n\n    /**\n     * We set up collision detection for the player by creating\n     * a capsule collision shape and a CharacterControl.\n     * The CharacterControl offers extra settings for\n     * size, stepheight, jumping, falling, and gravity.\n     * We also put the player in its starting position.\n     */\n    CapsuleCollisionShape capsuleShape = new CapsuleCollisionShape(1.5f, 6f, 1);\n    player = new CharacterControl(capsuleShape, 0.05f);\n    player.setJumpSpeed(20);\n    player.setFallSpeed(30);\n\n    // We attach the scene and the player to the rootnode and the physics space,\n    // to make them appear in the game world.\n    rootNode.attachChild(sceneModel);\n    bulletAppState.getPhysicsSpace().add(landscape);\n    bulletAppState.getPhysicsSpace().add(player);\n\n    // You can change the gravity of individual physics objects before or after\n    //they are added to the PhysicsSpace, but it must be set before MOVING the\n    //physics location.\n    player.setGravity(new Vector3f(0,-30f,0));\n    player.setPhysicsLocation(new Vector3f(0, 10, 0));\n  }\n\n  private void setUpLight() {\n    // We add light so we see the scene\n    AmbientLight al = new AmbientLight();\n    al.setColor(ColorRGBA.White.mult(1.3f));\n    rootNode.addLight(al);\n\n    DirectionalLight dl = new DirectionalLight();\n    dl.setColor(ColorRGBA.White);\n    dl.setDirection(new Vector3f(2.8f, -2.8f, -2.8f).normalizeLocal());\n    rootNode.addLight(dl);\n  }\n\n  /** We over-write some navigational key mappings here, so we can\n   * add physics-controlled walking and jumping: */\n  private void setUpKeys() {\n    inputManager.addMapping("Left", new KeyTrigger(KeyInput.KEY_A));\n    inputManager.addMapping("Right", new KeyTrigger(KeyInput.KEY_D));\n    inputManager.addMapping("Up", new KeyTrigger(KeyInput.KEY_W));\n    inputManager.addMapping("Down", new KeyTrigger(KeyInput.KEY_S));\n    inputManager.addMapping("Jump", new KeyTrigger(KeyInput.KEY_SPACE));\n    inputManager.addListener(this, "Left");\n    inputManager.addListener(this, "Right");\n    inputManager.addListener(this, "Up");\n    inputManager.addListener(this, "Down");\n    inputManager.addListener(this, "Jump");\n  }\n\n  /** These are our custom actions triggered by key presses.\n   * We do not walk yet, we just keep track of the direction the user pressed. */\n  public void onAction(String binding, boolean isPressed, float tpf) {\n    if (binding.equals("Left")) {\n      left = isPressed;\n    } else if (binding.equals("Right")) {\n      right= isPressed;\n    } else if (binding.equals("Up")) {\n      up = isPressed;\n    } else if (binding.equals("Down")) {\n      down = isPressed;\n    } else if (binding.equals("Jump")) {\n      if (isPressed) { player.jump(new Vector3f(0,20f,0));}\n    }\n  }\n\n  /**\n   * This is the main event loop--walking happens here.\n   * We check in which direction the player is walking by interpreting\n   * the camera direction forward (camDir) and to the side (camLeft).\n   * The setWalkDirection() command is what lets a physics-controlled player walk.\n   * We also make sure here that the camera moves with player.\n   */\n  @Override\n    public void simpleUpdate(float tpf) {\n        camDir.set(cam.getDirection()).multLocal(0.6f);\n        camLeft.set(cam.getLeft()).multLocal(0.4f);\n        walkDirection.set(0, 0, 0);\n        if (left) {\n            walkDirection.addLocal(camLeft);\n        }\n        if (right) {\n            walkDirection.addLocal(camLeft.negate());\n        }\n        if (up) {\n            walkDirection.addLocal(camDir);\n        }\n        if (down) {\n            walkDirection.addLocal(camDir.negate());\n        }\n        player.setWalkDirection(walkDirection);\n        cam.setLocation(player.getPhysicsLocation());\n    }\n}\n')),Object(o.b)("p",null,"Run the sample. You should see a town square with houses and a monument.\nUse the WASD keys and the mouse to navigate around with a first-person\nperspective. Run forward and jump by pressing W and Space. Note how you\nstep over the sidewalk, and up the steps to the monument. You can walk\nin the alleys between the houses, but the walls are solid. Don't walk\nover the edge of the world! emoji:smiley","[","]"),Object(o.b)("h1",{id:"understanding-the-code"},"Understanding the Code"),Object(o.b)("p",null,"Let's start with the class declaration:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"public class HelloCollision extends SimpleApplication\n        implements ActionListener { ... }\n")),Object(o.b)("p",null,"You already know that SimpleApplication is the base class for all jME3\ngames. You make this class implement the ",Object(o.b)("inlineCode",{parentName:"p"},"ActionListener")," interface\nbecause you want to customize the navigational inputs later."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"  private Spatial sceneModel;\n  private BulletAppState bulletAppState;\n  private RigidBodyControl landscape;\n  private CharacterControl player;\n  private Vector3f walkDirection = new Vector3f();\n  private boolean left = false, right = false, up = false, down = false;\n\n  //Temporary vectors used on each frame.\n  //They here to avoid instanciating new vectors on each frame\n  private Vector3f camDir = new Vector3f();\n  private Vector3f camLeft = new Vector3f();\n")),Object(o.b)("p",null,"You initialize a few private fields:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"The BulletAppState gives this SimpleApplication access to physics\nfeatures (such as collision detection) supplied by jME3's Bullet\nintegration")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"The Spatial sceneModel is for loading an OgreXML model of a town.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"You need a RigidBodyControl to make the town model solid.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"The (invisible) first-person player is represented by a\nCharacterControl object.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"The fields ",Object(o.b)("inlineCode",{parentName:"p"},"walkDirection")," and the four Booleans are used for\nphysics-controlled navigation.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"camDir and camLeft are temporary vectors used later when computing\nthe walkingDirection from the cam position and rotation"))),Object(o.b)("p",null,"Let's have a look at all the details:"),Object(o.b)("h1",{id:"initializing-the-game"},"Initializing the Game"),Object(o.b)("p",null,"As usual, you initialize the game in the ",Object(o.b)("inlineCode",{parentName:"p"},"simpleInitApp()")," method."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"    viewPort.setBackgroundColor(new ColorRGBA(0.7f,0.8f,1f,1f));\n    flyCam.setMoveSpeed(100);\n    setUpKeys();\n    setUpLight();\n")),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"You set the background color to light blue, since this is a scene\nwith a sky.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},'You repurpose the default camera control "flyCam" as first-person\ncamera and set its speed.')),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"The auxiliary method ",Object(o.b)("inlineCode",{parentName:"p"},"setUpLights()")," adds your light sources.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"The auxiliary method ",Object(o.b)("inlineCode",{parentName:"p"},"setUpKeys()")," configures input mappings--we\nwill look at it later."))),Object(o.b)("h2",{id:"the-physics-controlled-scene"},"The Physics-Controlled Scene"),Object(o.b)("p",null,"Currently, jMonkeyEngine has two versions of ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://pybullet.org/wordpress/"}),"Bullet\nPhysics"),". A java port,\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://jbullet.advel.cz/"}),"jBullet"),", and\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Java_Native_Interface"}),"JNI")," (native)\nimplementation. Although both accomplish the same goal of adding physics\nto your game, how you interact with each is quite different. This\ntutorial and it's examples use the JNI (native) implementation of\nphysics. Which you choose is up to you."),Object(o.b)("p",null,"See the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/jme3_source_structure.xml#physics"}),"source structure"),"\npage for details on how to add each library to your game."),Object(o.b)("p",null,"How you initialize each is the same, only the methods used for\nmanipulating objects is different. The first thing you do in every\nphysics game is create a BulletAppState object. It gives you access to\nthe jME3 Bullet integration which handles physical forces and\ncollisions."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"    bulletAppState = new BulletAppState();\n    stateManager.attach(bulletAppState);\n")),Object(o.b)("p",null,"For the scene, you load the ",Object(o.b)("inlineCode",{parentName:"p"},"sceneModel")," from a zip file, and adjust the\nsize."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'    assetManager.registerLocator("town.zip", ZipLocator.class);\n    sceneModel = assetManager.loadModel("main.scene");\n    sceneModel.setLocalScale(2f);\n')),Object(o.b)("p",null,"The file ",Object(o.b)("inlineCode",{parentName:"p"},"town.zip")," is included as a sample model in the JME3 sources --\nyou can ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/wiki/raw/master/src/docs/resources/Scenes/Town/town.zip"}),"download it\nhere"),".\n(Optionally, use any OgreXML scene of your own.) For this sample, place\nthe zip file in the application's top level directory (that is, next to\nsrc/, assets/, build)."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"    CollisionShape sceneShape =\n      CollisionShapeFactory.createMeshShape((Node) sceneModel);\n    landscape = new RigidBodyControl(sceneShape, 0);\n    sceneModel.addControl(landscape);\n    rootNode.attachChild(sceneModel);\n")),Object(o.b)("p",null,"To use collision detection, you add a RigidBodyControl to the\n",Object(o.b)("inlineCode",{parentName:"p"},"sceneModel")," Spatial. The RigidBodyControl for a complex model takes two\narguments: A Collision Shape, and the object's mass."),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"JME3 offers a ",Object(o.b)("inlineCode",{parentName:"p"},"CollisionShapeFactory")," that precalculates a\nmesh-accurate collision shape for a Spatial. You choose to generate\na ",Object(o.b)("inlineCode",{parentName:"p"},"CompoundCollisionShape")," (which has MeshCollisionShapes as its\nchildren) because this type of collision shape is optimal for\nimmobile objects, such as terrain, houses, and whole shooter levels.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"You set the mass to zero since a scene is static and its mass is\nirrevelant.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Add the control to the Spatial to give it physical properties.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"As always, attach the sceneModel to the rootNode to make it visible."))),Object(o.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"Remember to add a light source so you can see the scene."))),Object(o.b)("h2",{id:"the-physics-controlled-player"},"The Physics-Controlled Player"),Object(o.b)("p",null,"A first-person player is typically invisible. When you use the default\nflyCam as first-person cam, it does not even test for collisons and runs\nthrough walls. This is because the flyCam control does not have any\nphysical shape assigned. In this code sample, you represent the\nfirst-person player as an (invisible) physical shape. You use the WASD\nkeys to steer this physical shape around, while the physics engine\nmanages for you how it walks along solid walls and on solid floors and\njumps over solid obstacles. Then you simply make the camera follow the\nwalking shape's location -- and you get the illusion of being a physical\nbody in a solid environment seeing through the camera."),Object(o.b)("p",null,"So let's set up collision detection for the first-person player."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"    CapsuleCollisionShape capsuleShape = new CapsuleCollisionShape(1.5f, 6f, 1);\n")),Object(o.b)("p",null,"Again, you create a CollisionShape: This time you choose a\nCapsuleCollisionShape, a cylinder with a rounded top and bottom. This\nshape is optimal for a person: It's tall and the roundness helps to get\nstuck less often on obstacles."),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Supply the CapsuleCollisionShape constructor with the desired radius\nand height of the bounding capsule to fit the shape of your\ncharacter. In this example the character is 1.5f units wide, and 6f\nunits tall.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"The final integer argument specifies the orientation of the\ncylinder: 1 is the Y-axis, which fits an upright person. For animals\nwhich are longer than high you would use 0 or 2 (depending on how it\nis rotated)."))),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"    player = new CharacterControl(capsuleShape, 0.05f);\n")),Object(o.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},'"Does that CollisionShape make me look fat?" If you ever get confusing\nphysics behaviour, remember to have a look at the collision shapes. Add\nthe following line after the bulletAppState initialization to make the\nshapes visible:'),Object(o.b)("pre",{parentName:"div"},Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"bulletAppState.setDebugEnabled(true);\n")))),Object(o.b)("p",null,"Now you use the CollisionShape to create a ",Object(o.b)("inlineCode",{parentName:"p"},"CharacterControl")," that\nrepresents the first-person player. The last argument of the\nCharacterControl constructor (here ",Object(o.b)("inlineCode",{parentName:"p"},".05f"),") is the size of a step that\nthe character should be able to surmount."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"    player.setJumpSpeed(20);\n    player.setFallSpeed(30);\n    player.setGravity(new Vector3f(0,-30f,0));\n")),Object(o.b)("p",null,"Apart from step height and character size, the ",Object(o.b)("inlineCode",{parentName:"p"},"CharacterControl")," lets\nyou configure jumping, falling, and gravity speeds. Adjust the values to\nfit your game situation. There are some important nuances when setting\nthese variable that are explained in greater detail in the\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/beginner/hello_collision.xml#2-onaction"}),"onAction()")," topic\nlater."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"    player.setPhysicsLocation(new Vector3f(0, 10, 0));\n")),Object(o.b)("p",null,"Finally we put the player in its starting position and update its state\n-- remember to use ",Object(o.b)("inlineCode",{parentName:"p"},"setPhysicsLocation()")," instead of\n",Object(o.b)("inlineCode",{parentName:"p"},"setLocalTranslation()")," now, since you are dealing with a physical\nobject."),Object(o.b)("p",null,"::: {.important}\nYou can set the gravity before or after adding the object to the physics\nspace, but gravity must be set BEFORE moving the physics location."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"player.setGravity(new Vector3f(0,-30f,0));\nplayer.setPhysicsLocation(new Vector3f(0, 10, 0));\n")),Object(o.b)("p",null,":::"),Object(o.b)("h2",{id:"physicsspace"},"PhysicsSpace"),Object(o.b)("p",null,"Remember, in physical games, you must register all solid objects\n(usually the characters and the scene) to the PhysicsSpace!"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"    bulletAppState.getPhysicsSpace().add(landscape);\n    bulletAppState.getPhysicsSpace().add(player);\n")),Object(o.b)("p",null,"The invisible body of the character just sits there on the physical\nfloor. It cannot walk yet -- you will deal with that next."),Object(o.b)("h1",{id:"navigation"},"Navigation"),Object(o.b)("p",null,"The default camera controller ",Object(o.b)("inlineCode",{parentName:"p"},"cam")," is a third-person camera. JME3 also\noffers a first-person controller, ",Object(o.b)("inlineCode",{parentName:"p"},"flyCam"),", which we use here to handle\ncamera rotation. The ",Object(o.b)("inlineCode",{parentName:"p"},"flyCam")," control moves the camera using\n",Object(o.b)("inlineCode",{parentName:"p"},"setLocation()"),"."),Object(o.b)("p",null,"However, you must redefine how walking (camera movement) is handled for\nphysics-controlled objects: When you navigate a non-physical node (e.g.\nthe default flyCam), you simply specify the ",Object(o.b)("em",{parentName:"p"},"target location"),". There are\nno tests that prevent the flyCam from getting stuck in a wall! When you\nmove a PhysicsControl, you want to specify a ",Object(o.b)("em",{parentName:"p"},"walk direction")," instead.\nThen the PhysicsSpace can calculate for you how far the character can\nactually move in the desired direction -- or whether an obstacle\nprevents it from going any further."),Object(o.b)("p",null,"In short, you must re-define the flyCam's navigational key mappings to\nuse ",Object(o.b)("inlineCode",{parentName:"p"},"setWalkDirection()")," instead of ",Object(o.b)("inlineCode",{parentName:"p"},"setLocalTranslation()"),". Here are\nthe steps:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"inputManager")),Object(o.b)("hr",null),Object(o.b)("p",null,"In the ",Object(o.b)("inlineCode",{parentName:"p"},"simpleInitApp()")," method, you re-configure the familiar WASD\ninputs for walking, and Space for jumping."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'private void setUpKeys() {\n    inputManager.addMapping("Left", new KeyTrigger(KeyInput.KEY_A));\n    inputManager.addMapping("Right", new KeyTrigger(KeyInput.KEY_D));\n    inputManager.addMapping("Up", new KeyTrigger(KeyInput.KEY_W));\n    inputManager.addMapping("Down", new KeyTrigger(KeyInput.KEY_S));\n    inputManager.addMapping("Jump", new KeyTrigger(KeyInput.KEY_SPACE));\n    inputManager.addListener(this, "Left");\n    inputManager.addListener(this, "Right");\n    inputManager.addListener(this, "Up");\n    inputManager.addListener(this, "Down");\n    inputManager.addListener(this, "Jump");\n}\n')),Object(o.b)("p",null,"You can move this block of code into an auxiliary method ",Object(o.b)("inlineCode",{parentName:"p"},"setupKeys()"),"\nand call this method from ",Object(o.b)("inlineCode",{parentName:"p"},"simpleInitApp()"),"-- to keep the code more\nreadable."),Object(o.b)("ol",{start:2},Object(o.b)("li",{parentName:"ol"},"onAction()")),Object(o.b)("hr",null),Object(o.b)("p",null,"Remember that this class implements the ",Object(o.b)("inlineCode",{parentName:"p"},"ActionListener")," interface, so\nyou can customize the flyCam inputs. The ",Object(o.b)("inlineCode",{parentName:"p"},"ActionListener")," interface\nrequires you to implement the ",Object(o.b)("inlineCode",{parentName:"p"},"onAction()")," method: You re-define the\nactions triggered by navigation key presses to work with physics."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'  public void onAction(String binding, boolean value, float tpf) {\n    if (binding.equals("Left")) {\n      if (value) { left = true; } else { left = false; }\n    } else if (binding.equals("Right")) {\n      if (value) { right = true; } else { right = false; }\n    } else if (binding.equals("Up")) {\n      if (value) { up = true; } else { up = false; }\n    } else if (binding.equals("Down")) {\n      if (value) { down = true; } else { down = false; }\n    } else if (binding.equals("Jump")) {\n      if (isPressed) { player.jump(new Vector3f(0,20f,0));}\n    }\n  }\n')),Object(o.b)("p",null,"The only movement that you do not have to implement yourself is the\njumping action. The call ",Object(o.b)("inlineCode",{parentName:"p"},"player.jump(new Vector3f(0,20f,0))")," is a\nspecial method that handles a correct jumping motion for your\n",Object(o.b)("inlineCode",{parentName:"p"},"PhysicsCharacterNode"),"."),Object(o.b)("p",null,"Remember when we set this variable earlier?"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"player.setJumpSpeed(20);\n")),Object(o.b)("p",null,"Here, ",Object(o.b)("inlineCode",{parentName:"p"},"player.setJumpSpeed(20)")," has no visible effect because its value\nis overridden when ",Object(o.b)("inlineCode",{parentName:"p"},"jump(new Vector3f(0,20f,0)")," is invoked in the\nonAction(). If you were to replace ",Object(o.b)("inlineCode",{parentName:"p"},"jump(new Vector3f(0,20f,0)")," with\n",Object(o.b)("inlineCode",{parentName:"p"},"jump(new Vector3f(0f,60f,0f))"),", then the player jumps faster and\nhigher, as would be expected."),Object(o.b)("p",null,'If you were using the "jBullet" library for physics, you would\nmanipulate the jump speed and calling jump would have the same effect.'),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"player.setJumpSpeed(60);\nplayer.jump();\n")),Object(o.b)("p",null,'This is just one of the differences you see when using "jBullet" vs the\n"Native" bullet implementations.'),Object(o.b)("p",null,"Another is when using the ",Object(o.b)("inlineCode",{parentName:"p"},"setFallSpeed()")," method. This sets the maximum\nfall speed, what's sometimes called the terminal velocity. In the town\nsetting, the easiest way to fall faster while jumping is to supply\nlarger values to both setFallSpeed() and jump(). For instance, with\n",Object(o.b)("inlineCode",{parentName:"p"},"setFallSpeed(300f)")," and ",Object(o.b)("inlineCode",{parentName:"p"},"jump(new Vector3f(0,200f,0))"),", the player\nreaches a speed of 200 wu/second just before landing. Using jBullet,\njust setting the fall speed accomplishes the same effect."),Object(o.b)("p",null,"For all other directions: Every time the user presses one of the WASD\nkeys, you ",Object(o.b)("em",{parentName:"p"},"keep track"),' of the direction the user wants to go, by storing\nthis info in four directional Booleans. No actual walking happens here\nyet. The update loop is what acts out the directional info stored in the\nbooleans, and makes the player move, as shown in the next topic,\n"setWalkDirection()".'),Object(o.b)("ol",{start:3},Object(o.b)("li",{parentName:"ol"},"setWalkDirection()")),Object(o.b)("hr",null),Object(o.b)("p",null,"Previously in the ",Object(o.b)("inlineCode",{parentName:"p"},"onAction()"),' method, you have collected the info in\nwhich direction the user wants to go in terms of "forward" or "left". In\nthe update loop, you repeatedly poll the current rotation of the camera.\nYou calculate the actual vectors to which "forward" or "left"\ncorresponds in the coordinate system.'),Object(o.b)("p",null,"This last and most important code snippet goes into the ",Object(o.b)("inlineCode",{parentName:"p"},"simpleUpdate()"),"\nmethod."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"})," public void simpleUpdate(float tpf) {\n        camDir.set(cam.getDirection()).multLocal(0.6f);\n        camLeft.set(cam.getLeft()).multLocal(0.4f);\n        walkDirection.set(0, 0, 0);\n        if (left) {\n            walkDirection.addLocal(camLeft);\n        }\n        if (right) {\n            walkDirection.addLocal(camLeft.negate());\n        }\n        if (up) {\n            walkDirection.addLocal(camDir);\n        }\n        if (down) {\n            walkDirection.addLocal(camDir.negate());\n        }\n        player.setWalkDirection(walkDirection);\n        cam.setLocation(player.getPhysicsLocation());\n    }\n")),Object(o.b)("p",null,"This is how the walking is triggered:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Initialize the vector ",Object(o.b)("inlineCode",{parentName:"p"},"walkDirection")," to zero. This is where you\nwant to store the calculated walk direction."),Object(o.b)("p",{parentName:"li"},"a.  Add to ",Object(o.b)("inlineCode",{parentName:"p"},"walkDirection")," the recent motion vectors that you polled\nfrom the camera. This way it is posible for a character to move\nforward and to the left simultaneously, for example!"),Object(o.b)("p",{parentName:"li"},'b.  This one last line does the "walking" magic:'),Object(o.b)("pre",{parentName:"li"},Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),"```java\nplayer.setWalkDirection(walkDirection);\n```\n\nAlways use `setWalkDirection()` to make a physics-controlled\nobject move continuously, and the physics engine handles\ncollision detection for you.\n")),Object(o.b)("p",{parentName:"li"},"c.  Make the first-person camera object follow along with the\nphysics-controlled player:"),Object(o.b)("pre",{parentName:"li"},Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),"```java\ncam.setLocation(player.getPhysicsLocation());\n```\n")))),Object(o.b)("p",null,"::: {.important}\nAgain, do not use ",Object(o.b)("inlineCode",{parentName:"p"},"setLocalTranslation()")," to walk the player around. You\nwill get it stuck by overlapping with another physical object. You can\nput the player in a start position with ",Object(o.b)("inlineCode",{parentName:"p"},"setPhysicalLocation()")," if you\nmake sure to place it a bit above the floor and away from obstacles.\n:::"),Object(o.b)("h1",{id:"conclusion"},"Conclusion"),Object(o.b)("p",null,'You have learned how to load a "solid" physical scene model and walk\naround in it with a first-person perspective. You learned to speed up\nthe physics calculations by using the CollisionShapeFactory to create\nefficient CollisionShapes for complex Geometries. You know how to add\nPhysicsControls to your collidable geometries and you register them to\nthe PhysicsSpace. You also learned to use\n',Object(o.b)("inlineCode",{parentName:"p"},"player.setWalkDirection(walkDirection)")," to move collision-aware\ncharacters around, and not ",Object(o.b)("inlineCode",{parentName:"p"},"setLocalTranslation()"),"."),Object(o.b)("p",null,"Terrains are another type of scene in which you will want to walk\naround. Let's proceed with learning ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/beginner/hello_terrain"}),"how to generate\nterrains")," now."),Object(o.b)("p",null,"Related info:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"How to load models and scenes: ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/beginner/hello_asset"}),"Hello\nAsset"),", ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../../sdk/scene_explorer"}),"Scene\nExplorer"),", ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../../sdk/scene_composer"}),"Scene\nComposer"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/advanced/terrain_collision"}),"Terrain Collision"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"To learn more about complex physics scenes, where several mobile\nphysical objects bump into each other, read ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/beginner/hello_physics"}),"Hello\nPhysics"),".")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"FYI, there are simpler collision detection solutions without\nphysics, too. Have a look at\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/collision/TestTriangleCollision.java"}),"jme3test.collision.TestTriangleCollision.java"),"."))))}p.isMDXComponent=!0},441:function(e,t,n){"use strict";n.d(t,"a",(function(){return h})),n.d(t,"b",(function(){return m}));var a=n(0),i=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),p=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r({},t,{},e)),n},h=function(e){var t=p(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},d=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=p(n),d=a,m=h["".concat(l,".").concat(d)]||h[d]||b[d]||o;return n?i.a.createElement(m,r({ref:t},c,{components:n})):i.a.createElement(m,r({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,l=new Array(o);l[0]=d;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:a,l[1]=r;for(var c=2;c<o;c++)l[c]=n[c];return i.a.createElement.apply(null,l)}return i.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);