(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{240:function(e,a,t){"use strict";t.r(a),t.d(a,"frontMatter",(function(){return i})),t.d(a,"metadata",(function(){return l})),t.d(a,"rightToc",(function(){return c})),t.d(a,"default",(function(){return h}));var n=t(1),o=t(9),r=(t(0),t(441)),i={},l={id:"jme3/advanced/walking_character",title:"walking_character",description:"In the [Hello Collision](../../jme3/beginner/hello_collision)",source:"@site/docs/jme3/advanced/walking_character.md",permalink:"/wikidemo/docs/jme3/advanced/walking_character",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/advanced/walking_character.md"},c=[{value:"Code Skeleton",id:"code-skeleton",children:[]},{value:"Overview",id:"overview",children:[]},{value:"Activate Physics",id:"activate-physics",children:[]},{value:"Initialize the Scene",id:"initialize-the-scene",children:[]},{value:"Create the Animated Character",id:"create-the-animated-character",children:[]},{value:"Set Up AnimControl and AnimChannels",id:"set-up-animcontrol-and-animchannels",children:[]},{value:"Add ChaseCam / CameraNode",id:"add-chasecam--cameranode",children:[]},{value:"Handle Navigation",id:"handle-navigation",children:[]}],s={rightToc:c};function h(e){var a=e.components,t=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(n.a)({},s,t,{components:a,mdxType:"MDXLayout"}),Object(r.b)("p",null,"In the ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/beginner/hello_collision"}),"Hello Collision"),"\ntutorial and the\n",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/bullet/TestQ3.java"}),"TestQ3.java"),"\ncode sample you have seen how to create collidable landscapes and walk\naround in a first-person perspective. The first-person camera is\nenclosed by a collision shape and is steered by the\nBetterCharacterControl."),Object(r.b)("p",null,"Other games however require a third-person perspective of the character:\nIn these cases you use a CharacterControl on a Spatial. This example\nalso shows how to set up custom navigation controls, so you can press\nWASD to make the third-person character walk; and how to implement\ndragging the mouse to rotate."),Object(r.b)("h1",{id:"sample-code"},"Sample Code"),Object(r.b)("p",null,"Several related code samples can be found here:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/bullet/TestPhysicsCharacter.java"}),"TestPhysicsCharacter.java"),"\n(third-person view)")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/bullet/TestWalkingChar.java"}),"TestWalkingChar.java"),"\n(third-person view)"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"Uses also\n",Object(r.b)("a",Object(n.a)({parentName:"li"},{href:"https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/bullet/BombControl.java"}),"BombControl.java")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/bullet/TestQ3.java"}),"TestQ3.java"),"\n(first-person view)")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/helloworld/HelloCollision.java"}),"HelloCollision.java"),"\n(first-person view)"))),Object(r.b)("p",null,"The code in this tutorial is a combination of these samples."),Object(r.b)("h1",{id:"bettercharactercontrol"},"BetterCharacterControl"),Object(r.b)("p",null,"Motivation: When you load a character model, give it a RigidBodyControl,\nand use forces to push it around, you do not get the desired behaviour:\nRigidBodyControl'ed objects (such as cubes and spheres) roll or tip over\nwhen pushed by physical forces. This is not the behaviour that you\nexpect of a walking character. JME3's BulletPhysics integration offers a\nBetterCharacterControl with a ",Object(r.b)("inlineCode",{parentName:"p"},"setWalkDirection()")," method. You use it to\ncreate simple characters that treat floors and walls as solid, and\nalways stays locked upright while moving."),Object(r.b)("p",null,"To use the BetterCharacterControl, you may load your character like\nthis:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'// Load any model\nSpatial playerSpatial = assetManager.loadModel("Models/Oto/Oto.mesh.xml");\nplayer =  (Node)playerSpatial; // You can set the model directly to the player. (We just wanted to explicitly show that it\'s a spatial.)\nNode playerNode = new Node(); // You can create a new node to wrap your player to adjust the location. (This allows you to solve issues with character sinking into floor, etc.)\nplayerNode.attachChild(player); // add it to the wrapper\nplayer.move(0,3.5f,0); // adjust position to ensure collisions occur correctly.\nplayer.setLocalScale(0.5f); // optionally adjust scale of model\n// setup animation:\ncontrol = player.getControl(AnimControl.class);\ncontrol.addListener(this);\nchannel = control.createChannel();\nchannel.setAnim("stand");\nplayerControl = new BetterCharacterControl(1.5f, 6f, 1f); // construct character. (If your character bounces, try increasing height and weight.)\nplayerNode.addControl(playerControl); // attach to wrapper\n// set basic physical properties:\nplayerControl.setJumpForce(new Vector3f(0,5f,0));\nplayerControl.warp(new Vector3f(0,10,10)); // warp character into landscape at particular location\n// add to physics state\nbulletAppState.getPhysicsSpace().add(playerControl);\nbulletAppState.getPhysicsSpace().addAll(playerNode);\n// You can change the gravity of individual physics objects after they are\n// added to the PhysicsSpace.\nplayerControl.setGravity(new Vector3f(0,-1f,0));\n\nrootNode.attachChild(playerNode); // add wrapper to root\n')),Object(r.b)("p",null,"This table doesn't contain all of the methods of the\nBetterCharacterControl class, just the commonly used ones. For a full\nlist, see the ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"%7Blink-javadoc%7D/com/jme3/bullet/control/BetterCharacterControl.html"}),"java\ndoc"),"."),Object(r.b)("p",null,"+-----------------------------------+-----------------------------------+\n| BetterCharacterControl Method     | Property                          |\n+===================================+===================================+\n| warp(new Vector3f(0,10,10)        | Move the character somewhere.     |\n|                                   | Note the character also takes the |\n|                                   | location of any spatial its being |\n|                                   | attached to at the moment it is   |\n|                                   | attached.                         |\n+-----------------------------------+-----------------------------------+\n| jump()                            | Makes the character jump with the |\n|                                   | set jump force.                   |\n+-----------------------------------+-----------------------------------+\n| setJumpForce(new Vector3f(0,5f,0) | Set the jump force as a Vector3f. |\n|                                   | The jump force is local to the    |\n|                                   | characters coordinate system,     |\n|                                   | which normally is always          |\n|                                   | z-forward (in world coordinates,  |\n|                                   | parent coordinates when set to    |\n|                                   | applyLocalPhysics)                |\n+-----------------------------------+-----------------------------------+\n| isOnGround()                      | Check if the character is on the  |\n|                                   | ground. This is determined by a   |\n|                                   | ray test in the center of the     |\n|                                   | character and might return false  |\n|                                   | even if the character is not      |\n|                                   | falling yet.                      |\n+-----------------------------------+-----------------------------------+\n| setDucked(true)                   | Toggle character ducking. When    |\n|                                   | ducked the characters capsule     |\n|                                   | collision shape height will be    |\n|                                   | multiplied by duckedFactor to     |\n|                                   | make the capsule smaller. When    |\n|                                   | unducking, the character will     |\n|                                   | check with a ray test if it can   |\n|                                   | in fact unduck and only do so     |\n|                                   | when its possible. You can check  |\n|                                   | the state of the unducking by     |\n|                                   | checking isDucked().              |\n+-----------------------------------+-----------------------------------+\n| setDuckedFactor(2.0f)             | The factor by which the height    |\n|                                   | should be multiplied when         |\n|                                   | ducking.                          |\n+-----------------------------------+-----------------------------------+\n| setWalkDirection(new              | Sets the walk direction of the    |\n| Vector3f(0f,0f,0.1f))             | character. This parameter is      |\n|                                   | frame rate independent and the    |\n|                                   | character will move continuously  |\n|                                   | in the direction given by the     |\n|                                   | vector with the speed given by    |\n|                                   | the vector length in m/s.         |\n+-----------------------------------+-----------------------------------+\n| setViewDirection(new              | Sets the view direction for the   |\n| Vector3f(0f,0f,0.1f))             | character. Note this only defines |\n|                                   | the rotation of the spatial in    |\n|                                   | the local x/z plane of the        |\n|                                   | character.                        |\n+-----------------------------------+-----------------------------------+\n| resetForward(new                  | Realign the local forward vector  |\n| Vector3f(0f,0f,0.1f))             | to given direction vector, if     |\n|                                   | null is supplied Vector3f.UNIT","_",'Z |\n|                                   | is used. Input vector has to be   |\n|                                   | perpendicular to current gravity  |\n|                                   | vector. This normally only needs  |\n|                                   | to be called when the gravity     |\n|                                   | direction changed continuously    |\n|                                   | and the local forward vector is   |\n|                                   | off due to drift. E.g. after      |\n|                                   | walking around on a sphere        |\n|                                   | \\"planet\\" for a while and then   |\n|                                   | going back to a y-up coordinate   |\n|                                   | system the local z-forward might  |\n|                                   | not be 100% aligned with Z axis.  |\n+-----------------------------------+-----------------------------------+\n| setGravity(new Vector3f(0,-1f,0)) | Set the gravity for this          |\n|                                   | character. Note that this also    |\n|                                   | realigns the local coordinate     |\n|                                   | system of the character so that   |\n|                                   | continuous changes in gravity     |\n|                                   | direction are possible while      |\n|                                   | maintaining a sensible control    |\n|                                   | over the character. Only takes    |\n|                                   | effect if the individual physics  |\n|                                   | object has already been added to  |\n|                                   | the PhysicsSpace, otherwise it    |\n|                                   | adopts the PhysicsSpace gravity.  |\n+-----------------------------------+-----------------------------------+\n| setPhysicsDamping(0.9f)           | Sets how much the physics forces  |\n|                                   | in the local x/z plane should be  |\n|                                   | dampened. 0 = no dampening, 1 =   |\n|                                   | no external force, default = 0.9  |\n+-----------------------------------+-----------------------------------+\n| setHeightPercent(float percent)   | This actually sets a new          |\n|                                   | collision shape to the character  |\n|                                   | to change the height of the       |\n|                                   | capsule.                          |\n+-----------------------------------+-----------------------------------+'),Object(r.b)("h1",{id:"character-control"},"Character Control"),Object(r.b)("p",null,"This code sample creates a simple upright Character using a\nCharacterControl:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'// Load any model\nNode myCharacter = (Node) assetManager.loadModel("Models/myCharacterModel.mesh.xml");\nrootNode.attachChild(myCharacter);\n// Create a appropriate physical shape for it\nCapsuleCollisionShape capsuleShape = new CapsuleCollisionShape(1.5f, 6f, 1);\nCharacterControl myCharacter_phys = new CharacterControl(capsuleShape, 0.01f);\n// Attach physical properties to model and PhysicsSpace\nmyCharacter.addControl(myCharacter_phys);\nbulletAppState.getPhysicsSpace().add(myCharacter_phys);\n')),Object(r.b)("p",null,'::: {.important}\nThe BulletPhysics CharacterControl only collides with "real"\nPhysicsControls (RigidBody). It does not detect collisions with other\nCharacterControls! If you need additional collision checks, add\nGhostControls to your characters and create a custom ',Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/advanced/physics_listeners"}),"collision\nlistener")," to respond.\n:::"),Object(r.b)("p",null,'A CharacterControl is a special kinematic object with restricted\nmovement. CharacterControls have a fixed "upward" axis, this means they\ndo not topple over when walking over an obstacle (as opposed to\nRigidBodyControls), which simulates a being\'s ability to balance\nupright. A CharacterControl can jump and fall along its upward axis, and\nit can scale steps of a certain height/steepness.'),Object(r.b)("p",null,'+-----------------------------------+-----------------------------------+\n| CharacterControl Method           | Property                          |\n+===================================+===================================+\n| setUpAxis(1)                      | Fixed upward axis. Values: 0 = X  |\n|                                   | axis , 1 = Y axis , 2 = Z axis.\\  |\n|                                   | Default: 1, because for           |\n|                                   | characters and vehicles, up is    |\n|                                   | typically along the Y axis.       |\n+-----------------------------------+-----------------------------------+\n| setJumpSpeed(10f)                 | Jump speed (movement along        |\n|                                   | upward-axis)                      |\n+-----------------------------------+-----------------------------------+\n| setFallSpeed(20f)                 | Fall speed (movement opposite to  |\n|                                   | upward-axis)                      |\n+-----------------------------------+-----------------------------------+\n| setMaxSlope(1.5f)                 | How steep the slopes and steps    |\n|                                   | are that the character can climb  |\n|                                   | without considering them an       |\n|                                   | obstacle. Higher obstacles need   |\n|                                   | to be jumped. Vertical height in  |\n|                                   | world units.                      |\n+-----------------------------------+-----------------------------------+\n| setGravity(1f)                    | The intensity of gravity for this |\n|                                   | CharacterControl\'ed entity. Tip:  |\n|                                   | To change the direction of        |\n|                                   | gravity for a character, modify   |\n|                                   | the up axis.                      |\n+-----------------------------------+-----------------------------------+\n| setWalkDirection(new              | (CharacterControl only) Make a    |\n| Vector3f(0f,0f,0.1f))             | physical character walk           |\n|                                   | continuously while checking for   |\n|                                   | floors and walls as solid         |\n|                                   | obstacles. This should probably   |\n|                                   | be called                         |\n|                                   | "setPo                            |\n|                                   | sitionIncrementPerSimulatorStep". |\n|                                   | This argument is neither a        |\n|                                   | direction nor a velocity, but the |\n|                                   | amount to increment the position  |\n|                                   | each physics tick: vector length  |\n|                                   | = accuracy',"*","speed in m/s.\\        |\n|                                   | Use                               |\n|                                   | ",Object(r.b)("inlineCode",{parentName:"p"},"setWalkDirection(Vector3f.ZERO)")," |\n|                                   | to stop a directional motion.     |\n+-----------------------------------+-----------------------------------+"),Object(r.b)("p",null,"For best practices on how to use ",Object(r.b)("inlineCode",{parentName:"p"},"setWalkDirection()"),", see the\nNavigation Inputs example below."),Object(r.b)("h1",{id:"walking-character-demo"},"Walking Character Demo"),Object(r.b)("h2",{id:"code-skeleton"},"Code Skeleton"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"public class WalkingCharacterDemo extends SimpleApplication\n        implements ActionListener, AnimEventListener {\n\n  public static void main(String[] args) {\n    WalkingCharacterDemo app = new WalkingCharacterDemo();\n    app.start();\n  }\n\n  public void simpleInitApp() { }\n\n  public void simpleUpdate(float tpf) { }\n\n  public void onAction(String name, boolean isPressed, float tpf) { }\n\n  public void onAnimCycleDone(AnimControl control, AnimChannel channel, String animName) { }\n\n  public void onAnimChange(AnimControl control, AnimChannel channel, String animName) { }\n")),Object(r.b)("h2",{id:"overview"},"Overview"),Object(r.b)("p",null,"To create a walking character:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"(Unless you already have it) Activate physics in the scene by adding\na ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/advanced/physics"}),"BulletAppState"),".")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Init the scene by loading the game level model (terrain or\nfloor/buildings), and giving the scene a MeshCollisionShape.")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Create the animated character:"),Object(r.b)("p",{parentName:"li"},"a.  Load an animated character model."),Object(r.b)("p",{parentName:"li"},"b.  Add a CharacterControl to the model.")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Set up animation channel and controllers.")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Add a ChaseCam or CameraNode.")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Handle navigational inputs."))),Object(r.b)("h2",{id:"activate-physics"},"Activate Physics"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"private BulletAppState bulletAppState;\n...\npublic void simpleInitApp() {\n    bulletAppState = new BulletAppState();\n    //bulletAppState.setThreadingType(BulletAppState.ThreadingType.PARALLEL);\n    stateManager.attach(bulletAppState);\n    ...\n}\n")),Object(r.b)("h2",{id:"initialize-the-scene"},"Initialize the Scene"),Object(r.b)("p",null,"In the simpleInitApp() method you initialize the scene and give it a\nMeshCollisionShape. The sample in the jme3 sources uses a custom helper\nclass that simply creates a flat floor and drops some cubes and spheres\non it:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"public void simpleInitApp() {\n  ...\n  PhysicsTestHelper.createPhysicsTestWorld(rootNode,\n      assetManager, bulletAppState.getPhysicsSpace());\n  ...\n")),Object(r.b)("p",null,"In a real game, you would load a scene model here instead of a test\nworld. You can load a model from a local or remote zip file, and scale\nand position it:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'private Node gameLevel;\n..\npublic void simpleInitApp() {\n  ...\n  //assetManager.registerLocator("quake3level.zip", ZipLocator.class);\n  assetManager.registerLocator(\n  "http://jmonkeyengine.googlecode.com/files/quake3level.zip",\n    HttpZipLocator.class);\n  MaterialList matList = (MaterialList) assetManager.loadAsset("Scene.material");\n  OgreMeshKey key = new OgreMeshKey("main.meshxml", matList);\n  gameLevel = (Node) assetManager.loadAsset(key);\n  gameLevel.setLocalTranslation(-20, -16, 20);\n  gameLevel.setLocalScale(0.10f);\n  gameLevel.addControl(new RigidBodyControl(0));\n  rootNode.attachChild(gameLevel);\n  bulletAppState.getPhysicsSpace().addAll(gameLevel);\n  ...\n')),Object(r.b)("p",null,"Also, add a light source to be able to see the scene."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"  AmbientLight light = new AmbientLight();\n  light.setColor(ColorRGBA.White.mult(2));\n  rootNode.addLight(light);\n")),Object(r.b)("h2",{id:"create-the-animated-character"},"Create the Animated Character"),Object(r.b)("p",null,"You create an animated model, such as Oto.mesh.xml."),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},'Place the "Oto" model into the ',Object(r.b)("inlineCode",{parentName:"p"},"assets/Models/Oto/")," directory of\nyour project.")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Create the CollisionShape and adjust the capsule radius and height\nto fit your character model.")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Create the CharacterControl and adjust the stepheight (here 0.05f)\nto the height that the character can climb up without jumping.")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Load the visible model. Make sure its start position does not\noverlap with scene objects.")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Add the CharacterControl to the model and register it to the\nphysicsSpace.")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Attach the visible model to the rootNode."))),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'private CharacterControl character;\nprivate Node model;\n...\npublic void simpleInitApp() {\n  ...\n  CapsuleCollisionShape capsule = new CapsuleCollisionShape(3f, 4f);\n  character = new CharacterControl(capsule, 0.05f);\n  character.setJumpSpeed(20f);\n  model = (Node) assetManager.loadModel("Models/Oto/Oto.mesh.xml");\n  model.addControl(character);\n  bulletAppState.getPhysicsSpace().add(character);\n  rootNode.attachChild(model);\n  ...\n')),Object(r.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(r.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},Object(r.b)("strong",{parentName:"p"},"Did you know?")," A CapsuleCollisionShape is a cylinder with rounded top\nand bottom. A capsule rotated upright is a good collision shape for a\nhumanoid character since its roundedness reduces the risk of getting\nstuck on obstacles."))),Object(r.b)("h2",{id:"set-up-animcontrol-and-animchannels"},"Set Up AnimControl and AnimChannels"),Object(r.b)("p",null,"Create several AnimChannels, one for each animation that can happen\nsimultaneously. In this example, you create one channel for walking and\none for attacking. (Because the character can attack with its arms and\nwalk with the rest of the body at the same time.)"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'private AnimChannel animationChannel;\nprivate AnimChannel attackChannel;\nprivate AnimControl animationControl;\n...\npublic void simpleInitApp() {\n  ...\n  animationControl = model.getControl(AnimControl.class);\n  animationControl.addListener(this);\n  animationChannel = animationControl.createChannel();\n  attackChannel = animationControl.createChannel();\n  attackChannel.addBone(animationControl.getSkeleton().getBone("uparm.right"));\n  attackChannel.addBone(animationControl.getSkeleton().getBone("arm.right"));\n  attackChannel.addBone(animationControl.getSkeleton().getBone("hand.right"));\n  ...\n')),Object(r.b)("p",null,"The attackChannel only controls one arm, while the walking channels\ncontrols the whole character."),Object(r.b)("h2",{id:"add-chasecam--cameranode"},"Add ChaseCam / CameraNode"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"private ChaseCamera chaseCam;\n\n...\n\npublic void simpleInitApp() {\n  ...\n  flyCam.setEnabled(false);\n  chaseCam = new ChaseCamera(cam, model, inputManager);\n  ...\n")),Object(r.b)("h2",{id:"handle-navigation"},"Handle Navigation"),Object(r.b)("p",null,"Configure custom key bindings for WASD keys that you will use to make\nthe character walk. Then calculate the vector where the user wants the\ncharacter to move. Note the use of the special ",Object(r.b)("inlineCode",{parentName:"p"},"setWalkDirection()"),"\nmethod below."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'// track directional input, so we can walk left-forward etc\nprivate boolean left = false, right = false, up = false, down = false;\n...\n\npublic void simpleInitApp() {\n  ...\n  // configure mappings, e.g. the WASD keys\n  inputManager.addMapping("CharLeft", new KeyTrigger(KeyInput.KEY_A));\n  inputManager.addMapping("CharRight", new KeyTrigger(KeyInput.KEY_D));\n  inputManager.addMapping("CharForward", new KeyTrigger(KeyInput.KEY_W));\n  inputManager.addMapping("CharBackward", new KeyTrigger(KeyInput.KEY_S));\n  inputManager.addMapping("CharJump", new KeyTrigger(KeyInput.KEY_RETURN));\n  inputManager.addMapping("CharAttack", new KeyTrigger(KeyInput.KEY_SPACE));\n  inputManager.addListener(this, "CharLeft", "CharRight");\n  inputManager.addListener(this, "CharForward", "CharBackward");\n  inputManager.addListener(this, "CharJump", "CharAttack");\n  ...\n}\n')),Object(r.b)("p",null,"Respond to the key bindings by setting variables that track in which\ndirection you will go. This allows us to steer the character forwards\nand to the left at the same time. ",Object(r.b)("strong",{parentName:"p"},"Note that no actual walking happens\nhere yet!")," We just track the input."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'@Override\npublic void onAction(String binding, boolean value, float tpf) {\n  if (binding.equals("CharLeft")) {\n      if (value) left = true;\n      else left = false;\n  } else if (binding.equals("CharRight")) {\n      if (value) right = true;\n      else right = false;\n  } else if (binding.equals("CharForward")) {\n      if (value) up = true;\n      else up = false;\n  } else if (binding.equals("CharBackward")) {\n      if (value) down = true;\n      else down = false;\n  } else if (binding.equals("CharJump"))\n      character.jump();\n  if (binding.equals("CharAttack"))\n    attack();\n}\n')),Object(r.b)("p",null,"The player can attack and walk at the same time. ",Object(r.b)("inlineCode",{parentName:"p"},"Attack()")," is a custom\nmethod that triggers an attack animation in the arms. Here you should\nalso add custom code to play an effect and sound, and to determine\nwhether the hit was successful."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'private void attack() {\n    attackChannel.setAnim("Dodge", 0.1f);\n    attackChannel.setLoopMode(LoopMode.DontLoop);\n}\n')),Object(r.b)("p",null,"Finally, the update loop looks at the directional variables and moves\nthe character accordingly. Since this is a special kinematic\nCharacterControl, we use the ",Object(r.b)("inlineCode",{parentName:"p"},"setWalkDirection()")," method."),Object(r.b)("p",null,"The variable ",Object(r.b)("inlineCode",{parentName:"p"},"airTime")," tracks how long the character is off the ground\n(e.g. when jumping or falling) and adjusts the walk and stand animations\nacccordingly."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'private Vector3f walkDirection = new Vector3f(0,0,0); // stop\n\nprivate float airTime = 0;\n\npublic void simpleUpdate(float tpf) {\n  Vector3f camDir = cam.getDirection().clone();\n  Vector3f camLeft = cam.getLeft().clone();\n  camDir.y = 0;\n  camLeft.y = 0;\n  camDir.normalizeLocal();\n  camLeft.normalizeLocal();\n  walkDirection.set(0, 0, 0);\n\n  if (left)  walkDirection.addLocal(camLeft);\n  if (right) walkDirection.addLocal(camLeft.negate());\n  if (up) walkDirection.addLocal(camDir);\n  if (down) walkDirection.addLocal(camDir.negate());\n\n  if (!character.onGround()) { // use !character.isOnGround() if the character is a BetterCharacterControl type.\n      airTime += tpf;\n  } else {\n      airTime = 0;\n  }\n\n  if (walkDirection.lengthSquared() == 0) { //Use lengthSquared() (No need for an extra sqrt())\n      if (!"stand".equals(animationChannel.getAnimationName())) {\n        animationChannel.setAnim("stand", 1f);\n      }\n  } else {\n      character.setViewDirection(walkDirection);\n      if (airTime > .3f) {\n        if (!"stand".equals(animationChannel.getAnimationName())) {\n          animationChannel.setAnim("stand");\n        }\n      } else if (!"Walk".equals(animationChannel.getAnimationName())) {\n        animationChannel.setAnim("Walk", 0.7f);\n      }\n    }\n\n  walkDirection.multLocal(25f).multLocal(tpf);// The use of the first multLocal here is to control the rate of movement multiplier for character walk speed. The second one is to make sure the character walks the same speed no matter what the frame rate is.\n  character.setWalkDirection(walkDirection); // THIS IS WHERE THE WALKING HAPPENS\n}\n')),Object(r.b)("p",null,"This method resets the walk animation."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'public void onAnimCycleDone(AnimControl control, AnimChannel channel, String animName) {\n        if (channel == attackChannel) channel.setAnim("stand");\n}\n\npublic void onAnimChange(AnimControl control, AnimChannel channel, String animName) { }\n')),Object(r.b)("p",null,"See also:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(n.a)({parentName:"li"},{href:"https://hub.jmonkeyengine.org/t/bettercharactercontrol-in-the-works/25242"}),"https://hub.jmonkeyengine.org/t/bettercharactercontrol-in-the-works/25242"))))}h.isMDXComponent=!0},441:function(e,a,t){"use strict";t.d(a,"a",(function(){return p})),t.d(a,"b",(function(){return b}));var n=t(0),o=t.n(n);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function i(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function l(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?i(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function c(e,a){if(null==e)return{};var t,n,o=function(e,a){if(null==e)return{};var t,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||(o[t]=e[t]);return o}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=o.a.createContext({}),h=function(e){var a=o.a.useContext(s),t=a;return e&&(t="function"==typeof e?e(a):l({},a,{},e)),t},p=function(e){var a=h(e.components);return o.a.createElement(s.Provider,{value:a},e.children)},d={inlineCode:"code",wrapper:function(e){var a=e.children;return o.a.createElement(o.a.Fragment,{},a)}},m=Object(n.forwardRef)((function(e,a){var t=e.components,n=e.mdxType,r=e.originalType,i=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),p=h(t),m=n,b=p["".concat(i,".").concat(m)]||p[m]||d[m]||r;return t?o.a.createElement(b,l({ref:a},s,{components:t})):o.a.createElement(b,l({ref:a},s))}));function b(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var r=t.length,i=new Array(r);i[0]=m;var l={};for(var c in a)hasOwnProperty.call(a,c)&&(l[c]=a[c]);l.originalType=e,l.mdxType="string"==typeof e?e:n,i[1]=l;for(var s=2;s<r;s++)i[s]=t[s];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);