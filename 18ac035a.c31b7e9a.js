(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{175:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return p})),t.d(n,"rightToc",(function(){return s})),t.d(n,"default",(function(){return c}));var r=t(1),a=t(9),i=(t(0),t(441)),o={},p={id:"jme3/beginner/hello_input_system/timekeypressed",title:"timekeypressed",description:"Parent: [jMonkeyEngine 3 Tutorial (5) - Hello Input",source:"@site/docs/jme3/beginner/hello_input_system/timekeypressed.md",permalink:"/wikidemo/docs/jme3/beginner/hello_input_system/timekeypressed",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/beginner/hello_input_system/timekeypressed.md"},s=[],l={rightToc:s};function c(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Parent: ",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"../../../jme3/beginner/hello_input_system"}),"jMonkeyEngine 3 Tutorial (5) - Hello Input\nSystem")),Object(i.b)("p",null,"Here is a sample of a program where the camera accelerates if the key is\nkept pressed."),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),'import com.jme3.app.SimpleApplication;\nimport com.jme3.bounding.BoundingBox;\nimport com.jme3.font.BitmapText;\nimport com.jme3.input.KeyInput;\nimport com.jme3.input.controls.ActionListener;\nimport com.jme3.input.controls.KeyTrigger;\nimport com.jme3.light.DirectionalLight;\nimport com.jme3.light.PointLight;\nimport com.jme3.material.Material;\nimport com.jme3.math.ColorRGBA;\nimport com.jme3.math.Vector3f;\nimport com.jme3.scene.Geometry;\nimport com.jme3.terrain.geomipmap.TerrainLodControl;\nimport com.jme3.terrain.geomipmap.TerrainQuad;\nimport com.jme3.terrain.geomipmap.lodcalc.DistanceLodCalculator;\nimport com.jme3.terrain.heightmap.AbstractHeightMap;\nimport com.jme3.terrain.heightmap.ImageBasedHeightMap;\nimport com.jme3.texture.Texture;\nimport com.jme3.texture.Texture.WrapMode;\n\npublic class Accelerate extends SimpleApplication implements ActionListener {\n\n    private TerrainQuad terrain;\n    Material matTerrain;\n    Material matWire;\n    boolean wireframe = false;\n    boolean triPlanar = false;\n    boolean wardiso = false;\n    boolean minnaert = false;\n    protected BitmapText hintText;\n    PointLight pl;\n    Geometry lightMdl;\n    private float dirtScale = 16;\n\n    private enum Actions {\n\n        LEFT, RIGHT, UP, DOWN;\n    }\n    private final int CAMERA_HEIGHT = 250;\n    private final int STARTING_CAM_SPEED = 1;\n    private final Vector3f CAM_DIRECTION = new Vector3f(0, -0.3f, 1f);\n    private final Vector3f CAM_LOCATION = new Vector3f(-1, 0, -CAMERA_HEIGHT);\n    private final Vector3f walkDirection = new Vector3f();\n    private boolean left = false;\n    private boolean right = false;\n    private boolean up = false;\n    private boolean down = false;\n    private float camSpeed = STARTING_CAM_SPEED;\n\n    private void initCamera() {\n        cam.setLocation(CAM_LOCATION);\n        cam.lookAtDirection(CAM_DIRECTION.normalizeLocal(), Vector3f.UNIT_Y.clone().addLocal(0, 2, 0));\n    }\n\n    public static void main(String[] args) {\n        Accelerate app = new Accelerate();\n        app.start();\n    }\n\n    @Override\n    public void simpleInitApp() {\n        setupKeys();\n        initTerrain();\n        initCamera();\n    }\n\n    @Override\n    public void simpleUpdate(float tpf) {\n        updateMovement(tpf);\n    }\n\n    private void updateMovement(float tpf) {\n        if (left || right || up || down) {\n            // here we increment the speed using the tpf\n            camSpeed += tpf * 2;\n            System.out.print("Camera speed " + camSpeed + ";  Location:" + cam.getLocation().toString()\n                    + ";  direction:"+cam.getDirection()+"walkDirection:" + walkDirection.toString());\n        }\n        Vector3f camDir = cam.getDirection().clone().multLocal(camSpeed);\n        Vector3f camLeft = cam.getLeft().clone().multLocal(camSpeed);\n        // adjust position of rigid body for collisions\n        walkDirection.set(cam.getLocation().clone());\n        if (left) {\n            walkDirection.addLocal(camLeft);\n        }\n        if (right) {\n            walkDirection.addLocal(camLeft.negate());\n        }\n        if (up) {\n            walkDirection.addLocal(camDir);\n        }\n        if (down) {\n            walkDirection.addLocal(camDir.negate());\n        }\n//        player.setWalkDirection(walkDirection);\n        cam.setLocation(walkDirection);\n        if (left || right || up || down) {\n            System.out.println("; new walkDirection:" + walkDirection);\n        }\n    }\n\n    private void initTerrain() {\n        // First, we load up our textures and the heightmap texture for the terrain\n\n        // TERRAIN TEXTURE material\n        matTerrain = new Material(assetManager, "Common/MatDefs/Terrain/TerrainLighting.j3md");\n        matTerrain.setBoolean("useTriPlanarMapping", false);\n        matTerrain.setFloat("Shininess", 0.0f);\n\n        // ALPHA map (for splat textures)\n        matTerrain.setTexture("AlphaMap", assetManager.loadTexture("Textures/Terrain/splat/alpha1.png"));\n        matTerrain.setTexture("AlphaMap_1", assetManager.loadTexture("Textures/Terrain/splat/alpha2.png"));\n\n        // HEIGHTMAP image (for the terrain heightmap)\n        Texture heightMapImage = assetManager.loadTexture("Textures/Terrain/splat/mountains512.png");\n\n        // GRASS texture\n        Texture grass = assetManager.loadTexture("Textures/Terrain/splat/grass.jpg");\n        grass.setWrap(WrapMode.Repeat);\n\n        // DIRT texture\n        Texture dirt = assetManager.loadTexture("Textures/Terrain/splat/dirt.jpg");\n        dirt.setWrap(WrapMode.Repeat);\n        matTerrain.setTexture("DiffuseMap", dirt);\n        matTerrain.setFloat("DiffuseMap_0_scale", dirtScale);\n\n        // ROCK texture\n        Texture rock = assetManager.loadTexture("Textures/Terrain/splat/road.jpg");\n        rock.setWrap(WrapMode.Repeat);\n\n        // BRICK texture\n        Texture brick = assetManager.loadTexture("Textures/Terrain/BrickWall/BrickWall.jpg");\n        brick.setWrap(WrapMode.Repeat);\n\n        // RIVER ROCK texture\n        Texture riverRock = assetManager.loadTexture("Textures/Terrain/Pond/Pond.jpg");\n        riverRock.setWrap(WrapMode.Repeat);\n\n        // WIREFRAME material\n        matWire = new Material(assetManager, "Common/MatDefs/Misc/Unshaded.j3md");\n        matWire.getAdditionalRenderState().setWireframe(true);\n        matWire.setColor("Color", ColorRGBA.Green);\n\n\n        // CREATE HEIGHTMAP\n        AbstractHeightMap heightmap = null;\n        try {\n            heightmap = new ImageBasedHeightMap(heightMapImage.getImage(), 0.5f);\n            heightmap.load();\n            heightmap.smooth(0.9f, 1);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        /*\n         * Here we create the actual terrain. The tiles will be 65x65, and the total size of the\n         * terrain will be 513x513. It uses the heightmap we created to generate the height values.\n         */\n        /**\n         * Optimal terrain patch size is 65 (64x64).\n         * The total size is up to you. At 1025 it ran fine for me (200+FPS), however at\n         * size=2049, it got really slow. But that is a jump from 2 million to 8 million triangles...\n         */\n        terrain = new TerrainQuad("terrain", 65, 513, heightmap.getHeightMap());//, new LodPerspectiveCalculatorFactory(getCamera(), 4)); // add this in to see it use entropy for LOD calculations\n        TerrainLodControl control = new TerrainLodControl(terrain, getCamera());\n        control.setLodCalculator(new DistanceLodCalculator(65, 2.7f)); // patch size, and a multiplier\n        terrain.addControl(control);\n        terrain.setMaterial(matTerrain);\n        terrain.setModelBound(new BoundingBox());\n        terrain.updateModelBound();\n        terrain.setLocalTranslation(0, -100, 0);\n        terrain.setLocalScale(1f, 1f, 1f);\n        rootNode.attachChild(terrain);\n\n\n        DirectionalLight light = new DirectionalLight();\n        light.setDirection((new Vector3f(-0.5f, -0.5f, -0.5f)).normalize());\n        rootNode.addLight(light);\n    }\n\n    private void setupKeys() {\n        inputManager.addMapping(Actions.LEFT.name(), new KeyTrigger(KeyInput.KEY_A));\n        inputManager.addMapping(Actions.RIGHT.name(), new KeyTrigger(KeyInput.KEY_D));\n        inputManager.addMapping(Actions.UP.name(), new KeyTrigger(KeyInput.KEY_W));\n        inputManager.addMapping(Actions.DOWN.name(), new KeyTrigger(KeyInput.KEY_S));\n        inputManager.addListener(this, Actions.LEFT.name());\n        inputManager.addListener(this, Actions.RIGHT.name());\n        inputManager.addListener(this, Actions.UP.name());\n        inputManager.addListener(this, Actions.DOWN.name());\n    }\n\n    /**\n     * These are our custom actions triggered by key presses. We do not walk yet, we just keep track of the direction\n     * the user pressed.\n     */\n    @Override\n    public void onAction(String name, boolean keyPressed, float tpf) {\n        System.out.println("name:" + name + "; keyPressed:" + keyPressed);\n        if (name.equals(Actions.LEFT.name())) {\n            left = keyPressed;\n            if (!keyPressed) { // if the key isn\'t pressed anymore reset the speed to the initial value\n                camSpeed = STARTING_CAM_SPEED;\n            }\n        } else if (name.equals(Actions.RIGHT.name())) {\n            right = keyPressed;\n            if (!keyPressed) {\n                camSpeed = STARTING_CAM_SPEED;\n            }\n        } else if (name.equals(Actions.UP.name())) {\n            up = keyPressed;\n            if (!keyPressed) {\n                camSpeed = STARTING_CAM_SPEED;\n            }\n        } else if (name.equals(Actions.DOWN.name())) {\n            down = keyPressed;\n            if (!keyPressed) {\n                camSpeed = STARTING_CAM_SPEED;\n            }\n        }\n    }\n}\n')))}c.isMDXComponent=!0},441:function(e,n,t){"use strict";t.d(n,"a",(function(){return m})),t.d(n,"b",(function(){return g}));var r=t(0),a=t.n(r);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function p(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=a.a.createContext({}),c=function(e){var n=a.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):p({},n,{},e)),t},m=function(e){var n=c(e.components);return a.a.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},u=Object(r.forwardRef)((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),m=c(t),u=r,g=m["".concat(o,".").concat(u)]||m[u]||d[u]||i;return t?a.a.createElement(g,p({ref:n},l,{components:t})):a.a.createElement(g,p({ref:n},l))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=u;var p={};for(var s in n)hasOwnProperty.call(n,s)&&(p[s]=n[s]);p.originalType=e,p.mdxType="string"==typeof e?e:r,o[1]=p;for(var l=2;l<i;l++)o[l]=t[l];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"}}]);