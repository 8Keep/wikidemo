(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{249:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return h}));var a=n(1),i=n(9),o=(n(0),n(441)),r={},l={id:"jme3/advanced/light_and_shadow",title:"light_and_shadow",description:"![Examples of shading and",source:"@site/docs/jme3/advanced/light_and_shadow.md",permalink:"/wikidemo/docs/jme3/advanced/light_and_shadow",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/advanced/light_and_shadow.md"},s=[{value:"PointLight",id:"pointlight",children:[]},{value:"DirectionalLight",id:"directionallight",children:[]},{value:"SpotLight",id:"spotlight",children:[]},{value:"AmbientLight",id:"ambientlight",children:[]}],c={rightToc:s};function h(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,Object(o.b)("img",Object(a.a)({parentName:"p"},{src:"../../jme3/advanced/shading-ani.gif",alt:"Examples of shading and\nlighting."}))),Object(o.b)("p",null,"Light and Shadow are two separate things in 3D engines, although we\npercieve them together in real life:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Lighting means that an object is brighter on the side facing the\nlight direction, and darker on the backside. Computationally, this\nis relatively easy.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Lighting does not mean that objects cast a shadow on the floor or\nother objects: Activating shadow processing is an additional step\ndescribed here. Since casting shadows has an impact on performance,\ndrop shadows and ambient occlusion shading are not activated by\ndefault."))),Object(o.b)("p",null,"::: {.important}\nA light source with a direction or location is required for all\nGeometries with Lighting.j3md-based Materials. An ambient light is not\nsufficient. In a scene with no appropriate light sources, Geometries\nwith Lighting.j3md-based Materials do not render. Only Geometries with\nUnshaded.j3md-based Materials are visible independent of any light\nsources.\n:::"),Object(o.b)("h1",{id:"light-sources-and-colors"},"Light Sources and Colors"),Object(o.b)("p",null,Object(o.b)("img",Object(a.a)({parentName:"p"},{src:"/images/jme3/advanced/light-sources.png",alt:"A lit scene with multiple light\nsources"}))),Object(o.b)("p",null,"You can add several types of light sources to a scene using\n",Object(o.b)("inlineCode",{parentName:"p"},"rootNode.addLight(mylight)"),"."),Object(o.b)("p",null,"The available light sources in ",Object(o.b)("inlineCode",{parentName:"p"},"com.\u200bjme3.\u200blight")," are:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"SpotLight")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"PointLight")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"AmbientLight")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"DirectionalLight"))),Object(o.b)("p",null,"You control the color and intensity of each light source. Typically you\nset the color to white (",Object(o.b)("inlineCode",{parentName:"p"},"new ColorRGBA(1.0f,1.0f,1.0f,1.0f)")," or\n",Object(o.b)("inlineCode",{parentName:"p"},"ColorRGBA.White"),"), which makes all scene elements appear in their\nnatural color."),Object(o.b)("p",null,"You can choose to use lights in other colors than white, or darker\ncolors. This influences the scene's atmosphere and will make the scene\nappear colder (e.g. ",Object(o.b)("inlineCode",{parentName:"p"},"ColorRGBA.Cyan"),") or warmer (",Object(o.b)("inlineCode",{parentName:"p"},"ColorRGBA.Yellow"),"),\nbrighter (higher values) or darker (lower values)."),Object(o.b)("p",null,"You can get a list of all lights added to a Spatial by calling\n",Object(o.b)("inlineCode",{parentName:"p"},"getWorldLightList()")," (includes inherited lights) or\n",Object(o.b)("inlineCode",{parentName:"p"},"getLocalLightList()")," (only directly added lights), and iterating over\nthe result."),Object(o.b)("h2",{id:"pointlight"},"PointLight"),Object(o.b)("p",null,"An elephant model illuminated by pointlights"),Object(o.b)("p",null,"A PointLight has a location and shines from there in all directions as\nfar as its radius reaches. The light intensity decreases with increased\ndistance from the light source. A PointLight can be used to cast shadows\nalong with a PointLightShadowRenderer (see the Casting Shadows section)"),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Typical example:")," Lamp, lightbulb, torch, candle."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"PointLight lamp_light = new PointLight();\nlamp_light.setColor(ColorRGBA.Yellow);\nlamp_light.setRadius(4f);\nlamp_light.setPosition(new Vector3f(lamp_geo.getLocalTranslation()));\nrootNode.addLight(lamp_light);\n")),Object(o.b)("h2",{id:"directionallight"},"DirectionalLight"),Object(o.b)("p",null,"A house model illuminated with a sun-like directional light"),Object(o.b)("p",null,'A DirectionalLight has no position, only a direction. It sends out\nparallel beams of light and is considered "infinitely far away. You\ntypically have one directional light per scene. A DirectionalLight can\nbe used together with shadows.'),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Typically example:")," Sun light."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"DirectionalLight sun = new DirectionalLight();\nsun.setColor(ColorRGBA.White);\nsun.setDirection(new Vector3f(-.5f,-.5f,-.5f).normalizeLocal());\nrootNode.addLight(sun);\n")),Object(o.b)("h2",{id:"spotlight"},"SpotLight"),Object(o.b)("p",null,"Spotlight"),Object(o.b)("p",null,"A SpotLight sends out a distinct beam or cone of light. A SpotLight has\na direction, a position, distance (range) and two angles. The inner\nangle is the central maximum of the light cone, the outer angle the edge\nof the light cone. Everything outside the light cone's angles is not\naffected by the light."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Typical Example:")," Flashlight"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"SpotLight spot = new SpotLight();\nspot.setSpotRange(100f);                           // distance\nspot.setSpotInnerAngle(15f * FastMath.DEG_TO_RAD); // inner light cone (central beam)\nspot.setSpotOuterAngle(35f * FastMath.DEG_TO_RAD); // outer light cone (edge of the light)\nspot.setColor(ColorRGBA.White.mult(1.3f));         // light color\nspot.setPosition(cam.getLocation());               // shine from camera loc\nspot.setDirection(cam.getDirection());             // shine forward from camera loc\nrootNode.addLight(spot);\n")),Object(o.b)("p",null,"If you want the spotlight to follow the flycam, repeat the\nsetDirection(...) and setPosition(...) calls in the update loop, and kee\nsyncing them with the camera position and direction."),Object(o.b)("h2",{id:"ambientlight"},"AmbientLight"),Object(o.b)("p",null,"An AmbientLight simply influences the brightness and color of the scene\nglobally. It has no direction and no location and shines equally\neverywhere. An AmbientLight does not cast any shadows, and it lights all\nsides of Geometries evenly, which makes 3D objects look unnaturally\nflat; this is why you typically do not use an AmbientLight alone without\none of the other lights."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Typical example:")," Regulate overall brightness, tinge the whole scene\nin a warm or cold color."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"AmbientLight al = new AmbientLight();\nal.setColor(ColorRGBA.White.mult(1.3f));\nrootNode.addLight(al);\n")),Object(o.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"You can increase the brightness of a light source gradually by\nmultiplying the light color to values greater than 1.0f.\\\nExample: ",Object(o.b)("inlineCode",{parentName:"p"},"mylight.setColor(ColorRGBA.White.mult(1.3f));")))),Object(o.b)("h1",{id:"light-follows-spatial"},"Light Follows Spatial"),Object(o.b)("p",null,"You can use a ",Object(o.b)("inlineCode",{parentName:"p"},"com.jme3.scene.control.LightControl")," to make a SpotLight\nor PointLight follow a Spatial. This can be used for a flashlight being\ncarried by a character, or for car headlights, or an aircraft's\nspotlight, etc."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"PointLight myLight = new PointLight();\nrootNode.addLight(myLight);\nLightControl lightControl = new LightControl(myLight);\nspatial.addControl(lightControl); // this spatial controls the position of this light.\n")),Object(o.b)("p",null,"Obviously, this does not apply to AmbientLights, which have no position."),Object(o.b)("h1",{id:"casting-shadows"},"Casting Shadows"),Object(o.b)("p",null,"For each type of non-ambient light source, JME3 implements two ways to\nsimulate geometries casting shadows on other geometries:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"a shadow renderer (which you apply to a viewport) and")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"a shadow filter (which you can add to a viewport's filter\npost-processor)."))),Object(o.b)("p",null,"+----------------------+----------------------+-----------------------+\n| light source class   | shadow renderer      | shadow filter class   |\n|                      | class                |                       |\n+======================+======================+=======================+\n| DirectionalLight     | Directiona           | Directi               |\n|                      | lLightShadowRenderer | onalLightShadowFilter |\n+----------------------+----------------------+-----------------------+\n| PointLight           | Poin                 | P                     |\n|                      | tLightShadowRenderer | ointLightShadowFilter |\n+----------------------+----------------------+-----------------------+\n| SpotLight            | Spo                  | SpotLightShadowFilter |\n|                      | tLightShadowRenderer |                       |\n+----------------------+----------------------+-----------------------+\n| AmbientLight         | (not applicable)     | (not applicable)      |\n+----------------------+----------------------+-----------------------+"),Object(o.b)("p",null,"You only need one shadow simulation per light source: if you use shadow\nrendering, you won't need a shadow filter and vice versa. Which way is\nmore efficient depends partly on the complexity of your scene. All six\nshadow simulation classes have similar interfaces, so once you know how\nto use one, you can easily figure out the rest."),Object(o.b)("p",null,"Shadow calculations (cast and receive) have a performance impact, so use\nthem sparingly. With shadow renderers, you can turn off shadow casting\nand/or shadow receiving for individual geometries, for portions of the\nscene graph, or for the entire scene:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"spatial.setShadowMode(ShadowMode.Inherit);     // This is the default setting for new spatials.\nrootNode.setShadowMode(ShadowMode.Off);        // Disable shadows for the whole scene, except where overridden.\nwall.setShadowMode(ShadowMode.CastAndReceive); // The wall can cast shadows and also receive them.\nfloor.setShadowMode(ShadowMode.Receive);       // Any shadows cast by the floor would be hidden by it.\nairplane.setShadowMode(ShadowMode.Cast);       // There's nothing above the airplane to cast shadows on it.\nghost.setShadowMode(ShadowMode.Off);           // The ghost is translucent: it neither casts nor receives shadows.\n")),Object(o.b)("p",null,"Both shadow renderers and shadow filters use shadow modes to determine\nwhich objects can cast shadows. However, only the shadow renderers pay\nattention to shadow modes when determining which objects receive\nshadows. With a shadow filter, shadow modes have no effect on which\nobjects receive shadows."),Object(o.b)("p",null,"Here's a sample application which demonstrates both\nDirectionalLightShadowRenderer and DirectionalLightShadowFilter:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/light/TestDirectionalLightShadow.java"}),"TestDirectionalLightShadow.java"))),Object(o.b)("p",null,"Here is the key code fragment:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"DirectionalLight sun = new DirectionalLight();\nsun.setColor(ColorRGBA.White);\nsun.setDirection(cam.getDirection());\nrootNode.addLight(sun);\n\n/* Drop shadows */\nfinal int SHADOWMAP_SIZE=1024;\nDirectionalLightShadowRenderer dlsr = new DirectionalLightShadowRenderer(assetManager, SHADOWMAP_SIZE, 3);\ndlsr.setLight(sun);\nviewPort.addProcessor(dlsr);\n\nDirectionalLightShadowFilter dlsf = new DirectionalLightShadowFilter(assetManager, SHADOWMAP_SIZE, 3);\ndlsf.setLight(sun);\ndlsf.setEnabled(true);\nFilterPostProcessor fpp = new FilterPostProcessor(assetManager);\nfpp.addFilter(dlsf);\nviewPort.addProcessor(fpp);\n")),Object(o.b)("p",null,"Constructor arguments:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Your AssetManager object.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Size of the rendered shadow maps, in pixels per side (512, 1024,\n2048, etc...).")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"The number of shadow maps rendered (more shadow maps = better\nquality, but slower)."))),Object(o.b)("p",null,"Properties you can set:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"setDirection(Vector3f) -- the direction of the light")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"setLambda(0.65f) -- to reduce the split size")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"setShadowIntensity(0.7f) -- shadow darkness (1=black, 0=invisible)")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"setShadowZextend(float) -- distance from camera to which shadows\nwill be computed"))),Object(o.b)("h1",{id:"screen-space-ambient-occlusion"},"Screen Space Ambient Occlusion"),Object(o.b)("p",null,"Full sample code"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/post/TestSSAO.java"}),"TestSSAO.java"),"\n-- Screen-Space Ambient Occlusion shadows")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/post/TestTransparentSSAO.java"}),"TestTransparentSSAO.java"),"\n-- Screen-Space Ambient Occlusion shadows plus transparancy")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://hub.jmonkeyengine.org/t/ssao-for-monkeys/13369"}),"Screen Space Ambient Occlusion for jMonkeyEngine\n(article)")))),Object(o.b)("p",null,"Ambient Occlusion refers to the shadows which nearby objects cast on\neach other under an ambient lighting. Screen Space Ambient Occlusion\n(SSAO) approximates how light radiates in real life."),Object(o.b)("p",null,"In JME3, SSAO is implemented by adding an instance of\n",Object(o.b)("inlineCode",{parentName:"p"},"com.jme3.post.SSAOFilter")," to a viewport which already simulates shadows\nusing another method such as DirectionalLightShadowRenderer."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"FilterPostProcessor fpp = new FilterPostProcessor(assetManager);\nSSAOFilter ssaoFilter = new SSAOFilter(12.94f, 43.92f, 0.33f, 0.61f);\nfpp.addFilter(ssaoFilter);\nviewPort.addProcessor(fpp);\n")),Object(o.b)("p",null,Object(o.b)("img",Object(a.a)({parentName:"p"},{src:"../../jme3/advanced/shading-textured-ani.gif",alt:"Shading with and without Ambient\nOcclusion"}))))}h.isMDXComponent=!0},441:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return g}));var a=n(0),i=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),h=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l({},t,{},e)),n},d=function(e){var t=h(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},p=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=h(n),p=a,g=d["".concat(r,".").concat(p)]||d[p]||b[p]||o;return n?i.a.createElement(g,l({ref:t},c,{components:n})):i.a.createElement(g,l({ref:t},c))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var c=2;c<o;c++)r[c]=n[c];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);