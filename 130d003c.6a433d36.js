(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{170:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return o})),a.d(t,"metadata",(function(){return s})),a.d(t,"rightToc",(function(){return l})),a.d(t,"default",(function(){return c}));var n=a(1),i=a(9),p=(a(0),a(441)),o={},s={id:"jme3/advanced/application_states",title:"application_states",description:"The `com.jme3.app.state.AppState` class is a customizable jME3 interface",source:"@site/docs/jme3/advanced/application_states.md",permalink:"/wikidemo/docs/jme3/advanced/application_states",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/advanced/application_states.md"},l=[{value:"Use Case Examples",id:"use-case-examples",children:[]},{value:"Supported Features",id:"supported-features",children:[]},{value:"Usage",id:"usage",children:[]},{value:"Code Samples",id:"code-samples",children:[]},{value:"Communication Among AppStates",id:"communication-among-appstates",children:[]},{value:"Initialize Familiar Class Fields",id:"initialize-familiar-class-fields",children:[]}],r={rightToc:l};function c(e){var t=e.components,a=Object(i.a)(e,["components"]);return Object(p.b)("wrapper",Object(n.a)({},r,a,{components:t,mdxType:"MDXLayout"}),Object(p.b)("p",null,"The ",Object(p.b)("inlineCode",{parentName:"p"},"com.jme3.app.state.AppState")," class is a customizable jME3 interface\nthat allows you to control the global game logic, the overall game\nmechanics. (To control the behaviour of a Spatial, see ",Object(p.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/advanced/custom_controls"}),"Custom\nControls")," instead. Controls and\nAppStates can be used together.)"),Object(p.b)("h1",{id:"overview"},"Overview"),Object(p.b)("h2",{id:"use-case-examples"},"Use Case Examples"),Object(p.b)("p",null,"There are situations during your game development where you think:"),Object(p.b)("ul",null,Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},"Mouse and key inputs are handled differently in-game versus in the\nmain menu. Can I group a set of input handler settings, and activate\nand deactivate them all in one step?")),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},"I have the in-game scene, and a character editor, and a Captain's\nQuarters screen. Can I group a set of nodes and behaviours, and swap\nthem in and out in one step?")),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},'When I pause the game, I want the character\'s "idle" animation to\ncontinue, but all other loops and game events should stop. How do I\ndefine what happens when the game is paused/unpaused?')),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},"I have a conditional block that takes up a lot of space in my\nsimpleUpdate() loop. Can I wrap up this block of code, and switch it\non and off in one step?")),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},'Can I package everything that belongs in-game, and everything that\nbelongs to the menu screen, and switch between these two "big"\nstates in one step?'))),Object(p.b)("p",null,"You can! This is what AppStates are there for. An AppState class is\nsubset of (or an extension to) your application. Every AppState class\nhas access to all fields in your main application (AssetManager,\nViewPort, StateManager, InputManager, RootNode, GuiNode, etc) and hooks\ninto the main update loop. An AppState can contain:"),Object(p.b)("ul",null,Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},"a subset of class fields, functions, methods (game state data and\naccessors),")),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},"a subset of GUI elements and their listeners,")),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},"a subset of input handlers and mappings,")),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},"a subset of nodes that you load and attach to the rootNode,")),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},"a subset of conditional actions that you branch to in the\nsimpleUpdate() loop,")),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},"a subset of other AppStates and Controls")),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},"... or combinations thereof."))),Object(p.b)("h2",{id:"supported-features"},"Supported Features"),Object(p.b)("p",null,"Each AppState lets you define what happens to it in the following\nsituations:"),Object(p.b)("ul",null,Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},Object(p.b)("strong",{parentName:"p"},"The AppState is initialized:")," You load and initialize game data,\nInputHandlers, AppStates and Controls and attach nodes.\\\nThe AppState executes its own simpleInitApp() method when it is\nattached, so to speak.")),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},Object(p.b)("strong",{parentName:"p"},"The AppState has been enabled (unpaused):")," This toggles a boolean\nisEnabled() to true. Here you attach nodes and listeners that should\nbecome active while it's running.")),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},Object(p.b)("strong",{parentName:"p"},"While the AppState is running/paused:")," You can poll isEnabled()\nto define paused and unpaused game behaviour in the update() loop.\nIn update(), you poll and modify the game state, modify the scene\ngraph, and trigger events. Test if ",Object(p.b)("inlineCode",{parentName:"p"},"!isEnabled()"),", and write code\nthat skips the running sections of this AppState's ",Object(p.b)("inlineCode",{parentName:"p"},"update()")," loop.\\\nEach AppState has its own update loop, which hooks into the main\nsimpleUpdate() loop (callback).")),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},Object(p.b)("strong",{parentName:"p"},"The AppState has been disabled (paused):"),' This toggles a boolean\nisEnabled() to false. Here you switch all objects to their specific\n"paused" behaviour.')),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},Object(p.b)("strong",{parentName:"p"},"The AppState is cleaned up:")," Here you decide what happens when\nthe AppState is detached. Save this AppState's game state,\nunregister Controls and InputHandlers, detach related AppStates,\ndetach nodes from the rootNode, etc."))),Object(p.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(p.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(p.b)("h5",{parentName:"div"},Object(p.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(p.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(p.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(p.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(p.b)("p",{parentName:"div"},"AppStates are extremely handy to swap out, or pause/unpause whole sets\nof other AppStates. For example, an InGameState (loads in-game GUI,\nactivates click-to-shoot input mappings, inits game content, starts game\nloop) versus MainScreenState (stops game loop, saves and detaches game\ncontent, switches to menu screen GUI, switches to click-to-select input\nmappings)."))),Object(p.b)("h2",{id:"usage"},"Usage"),Object(p.b)("p",null,"To implement game logic:"),Object(p.b)("ol",null,Object(p.b)("li",{parentName:"ol"},Object(p.b)("p",{parentName:"li"},"Create one AbstractAppState instance for each set of game mechanics.")),Object(p.b)("li",{parentName:"ol"},Object(p.b)("p",{parentName:"li"},"Implement game behaviour in the AppState's update() method."),Object(p.b)("ul",{parentName:"li"},Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},"You can pass custom data as arguments in the constructor.")),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},"The AppState has access to everything inside the app's scope via\nthe Application ",Object(p.b)("inlineCode",{parentName:"p"},"app")," object.")))),Object(p.b)("li",{parentName:"ol"},Object(p.b)("p",{parentName:"li"},"Create and attach the AppState to the AppStateManager\n(",Object(p.b)("inlineCode",{parentName:"p"},"stateManager.attach(myAppState);"),") and initialize it.")),Object(p.b)("li",{parentName:"ol"},Object(p.b)("p",{parentName:"li"},"Enable and disable (unpause and pause) the AppStates that you need\nduring the game.")),Object(p.b)("li",{parentName:"ol"},Object(p.b)("p",{parentName:"li"},"Detach the AppState from the AppStateManager\n(",Object(p.b)("inlineCode",{parentName:"p"},"stateManager.detach(myAppState);"),") and clean it up."))),Object(p.b)("p",null,"When you add several AppStates to one Application and activate them,\ntheir initialize() methods and update() loops are executed in the order\nin which the AppStates were added to the AppStateManager."),Object(p.b)("h2",{id:"code-samples"},"Code Samples"),Object(p.b)("p",null,"JME3 comes with a BulletAppState that implements Physical behaviour\n(using the jBullet library). You, for example, could write an Artificial\nIntelligence AppState to control all your enemy units. Existing examples\nin the code base include:"),Object(p.b)("ul",null,Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},Object(p.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-bullet/src/common/java/com/jme3/bullet/BulletAppState.java"}),"BulletAppState"),"\ncontrols physical behaviour in PhysicsControl'ed Spatials.")),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},Object(p.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/app/state/TestAppStates.java"}),"TestAppStates.java"),"\nan example of a custom AppState"),Object(p.b)("ul",{parentName:"li"},Object(p.b)("li",{parentName:"ul"},Object(p.b)("a",Object(n.a)({parentName:"li"},{href:"https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/app/state/RootNodeState.java"}),"RootNodeState.java"))))),Object(p.b)("h1",{id:"appstate"},"AppState"),Object(p.b)("p",null,"The AppState interface lets you initialize sets of objects, and hook a\nset of continuously executing code into the main loop."),Object(p.b)("p",null,"+-----------------+-----------------------------------------------------+\n| AppState Method | Usage                                               |\n+=================+=====================================================+\n| init            | When this AppState is added to the game, the        |\n| ialize(asm,app) | RenderThread initializes the AppState and then      |\n|                 | calls this method. You can modify the scene graph   |\n|                 | from here (e.g. attach nodes). To get access to the |\n|                 | main app, call:                                     |\n|                 |                                                     |\n|                 | ",Object(p.b)("inlineCode",{parentName:"p"},"java                                         |\n|                 | super.initialize(stateManager, app);                |\n|                 | this.app = (SimpleApplication) app;                 |\n|                 | "),"                                                 |\n+-----------------+-----------------------------------------------------+\n| cleanup()       | This method is executed after you remove the        |\n|                 | AppState from the game. Here you implement clean-up |\n|                 | code for when this state is detached. You can       |\n|                 | modify the scene graph from here (e.g. detach       |\n|                 | nodes).                                             |\n+-----------------+-----------------------------------------------------+\n| update(float    | Here you implement the behaviour that you want to   |\n| tpf)            | hook into the simpleUpdate() loop while this state  |\n|                 | is attached to the game. You can modify the scene   |\n|                 | graph from here.                                    |\n+-----------------+-----------------------------------------------------+\n| isInitialized() | Your implementations of this interface should       |\n|                 | return the correct respective boolean value. (See   |\n|                 | AbstractAppState)                                   |\n+-----------------+-----------------------------------------------------+\n| se              | Temporarily enables or disables an AppState. (See   |\n| tEnabled(true)\\ | AbstractAppState)                                   |\n| se              |                                                     |\n| tEnabled(false) |                                                     |\n+-----------------+-----------------------------------------------------+\n| isEnabled()     | Test whether AppState is enabled or disabled. Your  |\n|                 | implementation should consider the boolean. (See    |\n|                 | AbstractAppState)                                   |\n+-----------------+-----------------------------------------------------+\n| stat            | The AppState knows when it is attached to, or       |\n| eAttached(asm)\\ | detached from, the AppStateManager, and triggers    |\n| sta             | these two methods. Don't modify the scene graph     |\n| teDetached(asm) | from here! (Typically not used.)                    |\n+-----------------+-----------------------------------------------------+\n| rende           | Renders the state, plus your optional               |\n| r(RenderManager | customizations. (Typically not used.)               |\n| rm)             |                                                     |\n+-----------------+-----------------------------------------------------+\n| postRender()    | Called after all rendering commands are flushed,    |\n|                 | including your optional customizations. (Typically  |\n|                 | not used.)                                          |\n+-----------------+-----------------------------------------------------+"),Object(p.b)("h1",{id:"abstractappstate"},"AbstractAppState"),Object(p.b)("p",null,"The\n",Object(p.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-core/src/main/java/com/jme3/app/state/AbstractAppState.java"}),"AbstractAppState"),"\nclass already implements some common methods\n(",Object(p.b)("inlineCode",{parentName:"p"},"isInitialized(), setEnabled(), isEnabled()"),") and makes creation of\ncustom AppStates a bit easier. We recommend you extend AbstractAppState\nand override the remaining AppState methods:\n",Object(p.b)("inlineCode",{parentName:"p"},"initialize(), setEnabled(), cleanup()"),"."),Object(p.b)("p",null,"Definition:"),Object(p.b)("pre",null,Object(p.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'public class MyAppState extends AbstractAppState {\n\n    private SimpleApplication app;\n\n    private Node x = new Node("x");  // some custom class fields...\n    public Node getX(){ return x; }  // some custom methods...\n\n    @Override\n    public void initialize(AppStateManager stateManager, Application app) {\n      super.initialize(stateManager, app);\n      this.app = (SimpleApplication)app;          // cast to a more specific class\n\n      // init stuff that is independent of whether state is PAUSED or RUNNING\n      this.app.getRootNode().attachChild(getX()); // modify scene graph...\n      this.app.doSomething();                     // call custom methods...\n   }\n\n   @Override\n    public void cleanup() {\n      super.cleanup();\n      // unregister all my listeners, detach all my nodes, etc...\n      this.app.getRootNode().detachChild(getX()); // modify scene graph...\n      this.app.doSomethingElse();                 // call custom methods...\n    }\n\n    @Override\n    public void setEnabled(boolean enabled) {\n      // Pause and unpause\n      super.setEnabled(enabled);\n      if(enabled){\n        // init stuff that is in use while this state is RUNNING\n        this.app.getRootNode().attachChild(getX()); // modify scene graph...\n        this.app.doSomethingElse();                 // call custom methods...\n      } else {\n        // take away everything not needed while this state is PAUSED\n        ...\n      }\n    }\n\n    // Note that update is only called while the state is both attached and enabled.\n    @Override\n    public void update(float tpf) {\n      // do the following while game is RUNNING\n      this.app.getRootNode().getChild("blah").scale(tpf); // modify scene graph...\n      x.setUserData(...);                                 // call some methods...\n    }\n\n}\n')),Object(p.b)("h1",{id:"baseappstate"},"BaseAppState"),Object(p.b)("p",null,"A new\n",Object(p.b)("a",Object(n.a)({parentName:"p"},{href:"%7Blink-javadoc%7D/com/jme3/app/state/BaseAppState.html"}),"BaseAppState"),"\nclass was introduced as part of the\n",Object(p.b)("a",Object(n.a)({parentName:"p"},{href:"https://hub.jmonkeyengine.org/t/jmonkeyengine-3-1-alpha-4-released/35478"}),"updates"),"\nbeing made to the AppState interface. AbstractAppState is the most\nminimal of the minimal implementations of the AppState interface. You\nessentially still need to do everything yourself, including getting the\nfunky enable/disable/initialized/terminate logic right. Now you just\nextend BaseAppState and you get onEnable() and onDisable() already\nworked out for you."),Object(p.b)("p",null,"Definition:"),Object(p.b)("pre",null,Object(p.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"public class MyBaseAppState extends BaseAppState {\xa0\xa0\xa0 \xa0\xa0\xa0\n    @Override\xa0\xa0\xa0\n    protected void initialize(Application app) {\xa0\xa0\xa0\xa0\xa0\xa0\xa0\n        //It is technically safe to do all initialization and cleanup in the \xa0\xa0\xa0\xa0\xa0\xa0\xa0\n        //onEnable()/onDisable() methods. Choosing to use initialize() and \xa0\xa0\xa0\xa0\xa0\xa0\xa0\n        //cleanup() for this is a matter of performance specifics for the \xa0\xa0\xa0\xa0\xa0\xa0\xa0\n        //implementor.\xa0\xa0\xa0\xa0\xa0\xa0\xa0\n        //TODO: initialize your AppState, e.g. attach spatials to rootNode\xa0\xa0\xa0\n    }\n\n    @Override\xa0\xa0\xa0\n    protected void cleanup(Application app) {\xa0\xa0\xa0\xa0\xa0\xa0\xa0\n        //TODO: clean up what you initialized in the initialize method,\xa0\xa0\xa0\xa0\xa0\xa0\xa0\n        //e.g. remove all spatials from rootNode\xa0\xa0\xa0\n    }\n\n \xa0  //onEnable()/onDisable() can be used for managing things that should \xa0\xa0\xa0\n    //only exist while the state is enabled. Prime examples would be scene \xa0\xa0\xa0\n    //graph attachment or input listener attachment.\xa0\xa0\xa0\n    @Override\xa0\xa0\xa0\n    protected void onEnable() {\xa0\xa0\xa0\xa0\xa0\xa0\xa0\n        //Called when the state is fully enabled, ie: is attached and \xa0\xa0\xa0\xa0\xa0\xa0\xa0\n        //isEnabled() is true or when the setEnabled() status changes after the \xa0\xa0\xa0\xa0\xa0\xa0\xa0\n        //state is attached.\xa0\xa0\xa0\n    }\n \xa0 \xa0\n \xa0  @Override\xa0\xa0\xa0\n    protected void onDisable() {\xa0\xa0\xa0\xa0\xa0\xa0\xa0\n        //Called when the state was previously enabled but is now disabled \xa0\xa0\xa0\xa0\xa0\xa0\xa0\n        //either because setEnabled(false) was called or the state is being \xa0\xa0\xa0\xa0\xa0\xa0\xa0\n        //cleaned up.\xa0\xa0\xa0\n    }\xa0\xa0\xa0 \xa0\xa0\xa0\n\n    @Override\xa0\xa0\xa0\n    public void update(float tpf) {\xa0\xa0\xa0\xa0\xa0\xa0\xa0\n        //TODO: implement behavior during runtime\xa0\xa0\xa0\n    }\n \xa0 \xa0\n}\n")),Object(p.b)("p",null,"Notable BaseAppState changes are as follows:"),Object(p.b)("ul",null,Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},"You no longer need to call super.initialize(stateManager, app)\nbecause it is now called by BaseAppState upon initialization for\nyou.")),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},"You no longer have to cast SimpleApplication to have access to\nAssetManager, AppStateManager, and you can even get a State\ndirectly. The getters getApplication(), getAssetManager(),\ngetState(type) and their methods are available to you immediately.\nHowever, you still have to cast SimpleApplication to get rootNode.")),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},"You no longer call super during cleanup, its done for you now.")),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},"It's now safe to do all initialization and cleanup in the\nonEnable()/onDisable() methods.")),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},"Cleanup and setEnabled now have logging built in."))),Object(p.b)("p",null,"You use BaseAppState as you would AbstractAppState, other than mentioned\nabove, and which one you use is entirely up to you. However,\nBaseAppState makes your life easier and is the recommended one to use\nnow."),Object(p.b)("p",null,"See ",Object(p.b)("a",Object(n.a)({parentName:"p"},{href:"%7Blink-javadoc%7D/com/jme3/app/state/BaseAppState.html"}),"BaseAppState"),"\nfor more information."),Object(p.b)("h1",{id:"pausing-and-unpausing"},"Pausing and Unpausing"),Object(p.b)("p",null,"You define what an AppState does when Paused or Unpaused, in the\n",Object(p.b)("inlineCode",{parentName:"p"},"setEnabled()")," and ",Object(p.b)("inlineCode",{parentName:"p"},"update()")," methods. Call ",Object(p.b)("inlineCode",{parentName:"p"},"myState.setEnabled(false)"),"\non all states that you want to pause. Call ",Object(p.b)("inlineCode",{parentName:"p"},"myState.setEnabled(true)")," on\nall states that you want to unpause."),Object(p.b)("h1",{id:"appstatemanager"},"AppStateManager"),Object(p.b)("p",null,"The com.jme3.app.state.AppStateManager holds the list of AppStates for\nan application. AppStateManager ensures that active AppStates can modify\nthe scene graph, and that the update() loops of active AppStates is\nexecuted. There is one AppStateManager per application. You typically\nattach several AppStates to one AppStateManager, but the same state can\nonly be attached once."),Object(p.b)("p",null,"+-----------------------------------+-----------------------------------+\n| AppStateManager Method            | Usage                             |\n+===================================+===================================+\n| hasState(myState)                 | Is AppState object \\'myState\\'    |\n|                                   | attached?                         |\n+-----------------------------------+-----------------------------------+\n| getState(MyAppState.class)        | Returns the first attached state  |\n|                                   | that is an instance of a subclass |\n|                                   | of ",Object(p.b)("inlineCode",{parentName:"p"},"MyAppState.class"),".            |\n+-----------------------------------+-----------------------------------+"),Object(p.b)("p",null,"The AppStateManager's ",Object(p.b)("inlineCode",{parentName:"p"},"render(), postRender(), cleanup()")," methods are\ninternal, ignore them, users never call them directly."),Object(p.b)("ul",null,Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},"If a detached AppState is attached then initialize() will be called\non the following render pass.")),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},"If an attached AppState is detached then cleanup() will be called on\nthe following render pass.")),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},"If you attach an already-attached AppState then the second attach is\na no-op and will return false.")),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},"If you both attach and detach an AppState within one frame then\nneither initialize() or cleanup() will be called, although if either\nis called both will be.")),Object(p.b)("li",{parentName:"ul"},Object(p.b)("p",{parentName:"li"},"If you both detach and then re-attach an AppState within one frame\nthen on the next update pass its cleanup() and initialize() methods\nwill be called in that order."))),Object(p.b)("h1",{id:"best-practices"},"Best Practices"),Object(p.b)("h2",{id:"communication-among-appstates"},"Communication Among AppStates"),Object(p.b)("p",null,"You can only access other AppStates (read from and write to them) from\ncertain places: From a Control's update() method, from an AppState's\nupdate() method, and from the SimpleApplication's simpleUpdate() loop.\nDon't mess with the AppState from other places, because from other\nmethods you have no control over the order of modifications; the game\ncan go out of sync because you can't know when (during which\nhalf-finished step of another state change) your modification will be\nperformed."),Object(p.b)("p",null,"You can use custom accessors to get data from AppStates, to set data in\nAppStates, or to trigger methods in AppStates."),Object(p.b)("pre",null,Object(p.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"this.app.getStateManager().getState(MyAppState.class).doSomeCustomStuffInThisState();\n")),Object(p.b)("h2",{id:"initialize-familiar-class-fields"},"Initialize Familiar Class Fields"),Object(p.b)("p",null,"To access class fields of the SimpleApplication the way you are used to,\ninitialize them to local variables, as shown in the following AppState\ntemplate:"),Object(p.b)("pre",null,Object(p.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"private SimpleApplication app;\nprivate Node              rootNode;\nprivate AssetManager      assetManager;\nprivate AppStateManager   stateManager;\nprivate InputManager      inputManager;\nprivate ViewPort          viewPort;\nprivate BulletAppState    physics;\n\npublic class MyAppState extends AbstractAppState {\n  @Override\n  public void initialize(AppStateManager stateManager, Application app) {\n    super.initialize(stateManager, app);\n    this.app = (SimpleApplication) app; // can cast Application to something more specific\n    this.rootNode     = this.app.getRootNode();\n    this.assetManager = this.app.getAssetManager();\n    this.stateManager = this.app.getStateManager();\n    this.inputManager = this.app.getInputManager();\n    this.viewPort     = this.app.getViewPort();\n    this.physics      = this.stateManager.getState(BulletAppState.class);\n  }\n}\n")))}c.isMDXComponent=!0},441:function(e,t,a){"use strict";a.d(t,"a",(function(){return d})),a.d(t,"b",(function(){return m}));var n=a(0),i=a.n(n);function p(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){p(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},p=Object.keys(e);for(n=0;n<p.length;n++)a=p[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var p=Object.getOwnPropertySymbols(e);for(n=0;n<p.length;n++)a=p[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var r=i.a.createContext({}),c=function(e){var t=i.a.useContext(r),a=t;return e&&(a="function"==typeof e?e(t):s({},t,{},e)),a},d=function(e){var t=c(e.components);return i.a.createElement(r.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},h=Object(n.forwardRef)((function(e,t){var a=e.components,n=e.mdxType,p=e.originalType,o=e.parentName,r=l(e,["components","mdxType","originalType","parentName"]),d=c(a),h=n,m=d["".concat(o,".").concat(h)]||d[h]||b[h]||p;return a?i.a.createElement(m,s({ref:t},r,{components:a})):i.a.createElement(m,s({ref:t},r))}));function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var p=a.length,o=new Array(p);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:n,o[1]=s;for(var r=2;r<p;r++)o[r]=a[r];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,a)}h.displayName="MDXCreateElement"}}]);