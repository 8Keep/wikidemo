(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{177:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return l})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return p}));var r=t(1),i=t(9),a=(t(0),t(441)),o={},l={id:"jme3/contributions/particles/reference",title:"reference",description:"The Parameters for a ParticleController are:",source:"@site/docs/jme3/contributions/particles/reference.md",permalink:"/wikidemo/docs/jme3/contributions/particles/reference",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/contributions/particles/reference.md"},c=[],s={rightToc:c};function p(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(a.b)("wrapper",Object(r.a)({},s,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("p",null,"The Parameters for a ParticleController are:"),Object(a.b)("p",null,"+-----------------------------------+-----------------------------------+\n| name                              | The name to use for the geometry  |\n|                                   | in the scene graph                |\n+===================================+===================================+\n| mesh                              | The mesh to use (Usually either   |\n|                                   | PointMesh or QuadMesh)            |\n+-----------------------------------+-----------------------------------+\n| maxParticles                      | The maximum number of particles   |\n|                                   | to allow active at any one time   |\n+-----------------------------------+-----------------------------------+\n| lifeMin                           | The minimum amount of time (in    |\n|                                   | seconds) for which each particle  |\n|                                   | lives                             |\n+-----------------------------------+-----------------------------------+\n| lifeMax                           | The maximum amount of time (in    |\n|                                   | seconds) for which each particle  |\n|                                   | lives                             |\n+-----------------------------------+-----------------------------------+\n| source                            | The source from which the         |\n|                                   | particles are spawned             |\n+-----------------------------------+-----------------------------------+\n| emissionController                | The frequency and timing with     |\n|                                   | which particles are spawned. If   |\n|                                   | null then no particles are        |\n|                                   | automatically spawned and they    |\n|                                   | must be triggered manually using  |\n|                                   | emitNextParticle() or             |\n|                                   | emitAllParticles()                |\n+-----------------------------------+-----------------------------------+\n| influencers                       | Zero or more ParticleInfluencers, |\n|                                   | each of which changes the         |\n|                                   | behaviour of the particles.       |\n+-----------------------------------+-----------------------------------+"),Object(a.b)("p",null,"All of the following classes have defined Interfaces or Abstract Classes\nto allow custom implementations and behaviour to easily be plugged into\nthe system."),Object(a.b)("p",null,"Javadoc for the system can be found at\n",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"http://www.zero-separation.com/particles/javadoc"}),"http://www.zero-separation.com/particles/javadoc")),Object(a.b)("h1",{id:"mesh"},"Mesh"),Object(a.b)("p",null,"The Mesh options are:"),Object(a.b)("p",null,"+-----------------------------------+-----------------------------------+\n| PointMesh                         | Fastest and most efficient, but   |\n|                                   | also most limited                 |\n+===================================+===================================+\n| QuadMesh                          | Much more flexible than point     |\n|                                   | mesh, all particles are           |\n|                                   | represented as 2-dimensional      |\n|                                   | quads                             |\n+-----------------------------------+-----------------------------------+\n| TemplateMesh                      | Allows particles to be full 3d    |\n|                                   | objects, with the mesh for each   |\n|                                   | particle being generated from one |\n|                                   | of any number of template meshes. |\n|                                   | This allows fully 3d particles    |\n|                                   | and takes in texture co-ordinates |\n|                                   | and even (if required) vertex     |\n|                                   | colours and normals from the      |\n|                                   | original mesh converting them as  |\n|                                   | required.                         |\n+-----------------------------------+-----------------------------------+"),Object(a.b)("h1",{id:"source"},"Source"),Object(a.b)("p",null,"The Source options are:"),Object(a.b)("p",null,"+-----------------------------------+-----------------------------------+\n| PointSource                       | Generates all particles from a    |\n|                                   | specific point with a random      |\n|                                   | velocity. The point itself is a   |\n|                                   | spatial so can be attached to the |\n|                                   | scene graph and will move with    |\n|                                   | it.                               |\n+===================================+===================================+\n| MeshSource                        | Generates all particles from a    |\n|                                   | randomly selected point on the    |\n|                                   | given mesh. A random triangle is  |\n|                                   | selected and then the particle    |\n|                                   | emitter from a random point       |\n|                                   | within that triangle along the    |\n|                                   | triangle's normal vector.         |\n+-----------------------------------+-----------------------------------+\n| WeightedMeshSource                | Provides the same functionality   |\n|                                   | as MeshSource but weights         |\n|                                   | triangles based on their relative |\n|                                   | size, larger triangles will tend  |\n|                                   | to emit more particles. This      |\n|                                   | provides a more even spread but   |\n|                                   | uses more resources and needs to  |\n|                                   | be kept updated if the mesh       |\n|                                   | changes.                          |\n+-----------------------------------+-----------------------------------+\n| ParticleParticleSource            | Emits particles from another      |\n|                                   | ParticleController. The particle  |\n|                                   | is emitted from a randomly        |\n|                                   | selected active particle and the  |\n|                                   | new particle starts with          |\n|                                   | identical velocity, rotation, etc |\n|                                   | as the particle it is being       |\n|                                   | emitted from.                     |\n+-----------------------------------+-----------------------------------+"),Object(a.b)("h1",{id:"emissioncontrollers"},"EmissionControllers"),Object(a.b)("p",null,"+-----------------------------------+-----------------------------------+\n| NULL                              | The NULL EmissionController does  |\n|                                   | not automatically emit any        |\n|                                   | particles, they must be emitted   |\n|                                   | externally by a call to the       |\n|                                   | ParticleController                |\n|                                   | emitNextParticle() or             |\n|                                   | emitAllParticles(). Note that if  |\n|                                   | the ParticleController is not in  |\n|                                   | use for an extended period of     |\n|                                   | time it is recommended that to    |\n|                                   | save resources you pause it by    |\n|                                   | either disabling the controller   |\n|                                   | or removing the Geometry from the |\n|                                   | scene graph.                      |\n+===================================+===================================+\n| RegularEmission                   | This EmissionController just      |\n|                                   | emits particles at regular        |\n|                                   | intervals, it will emit multiple  |\n|                                   | particles in one frame if more    |\n|                                   | than one interval has passed      |\n|                                   | since the previous frame.         |\n+-----------------------------------+-----------------------------------+"),Object(a.b)("h1",{id:"influencers"},"Influencers"),Object(a.b)("p",null,"+-----------------------------------+-----------------------------------+\n| ColorInfluencer                   | Modify the particle's color over  |\n|                                   | time                              |\n+===================================+===================================+\n| GravityInfluencer                 | Apply steady acceleration in a    |\n|                                   | specified direction over time     |\n+-----------------------------------+-----------------------------------+\n| MultiColorInfluencer              | Modify the particle's color       |\n|                                   | through multiple colors over time |\n+-----------------------------------+-----------------------------------+\n| PreferredDestinationInfluencer    | Move the particle towards a       |\n|                                   | specified point                   |\n+-----------------------------------+-----------------------------------+\n| PreferredDirectionInfluencer      | Rotate the particles velocity     |\n|                                   | towards the given direction over  |\n|                                   | time                              |\n+-----------------------------------+-----------------------------------+\n| RandomImpulseInfluencer           | Apply a random impulse to the     |\n|                                   | particle either at initialization |\n|                                   | or every frame                    |\n+-----------------------------------+-----------------------------------+\n| RandomSpriteInfluencer            | Select a random sprite for the    |\n|                                   | particle from those available     |\n|                                   | when it is initialized            |\n+-----------------------------------+-----------------------------------+\n| RotationInfluencer                | Rotate the particle by picking an |\n|                                   | initial rotational velocity at    |\n|                                   | random and then maintaining it    |\n+-----------------------------------+-----------------------------------+\n| SizeInfluencer                    | Modify the particle's size over   |\n|                                   | time                              |\n+-----------------------------------+-----------------------------------+\n| SpatialDestinationInfluencer      | Move the particle towards a given |\n|                                   | spatial, it will attempt to reach |\n|                                   | the current location of the       |\n|                                   | spatial by the end of the         |\n|                                   | particle's life cycle.            |\n+-----------------------------------+-----------------------------------+\n| SpeedInfluencer                   | Modify the particle's speed over  |\n|                                   | time                              |\n+-----------------------------------+-----------------------------------+\n| SpriteAnimationInfluencer         | Animate the particle through the  |\n|                                   | available sprites over time       |\n+-----------------------------------+-----------------------------------+"))}p.isMDXComponent=!0},441:function(e,n,t){"use strict";t.d(n,"a",(function(){return m})),t.d(n,"b",(function(){return f}));var r=t(0),i=t.n(r);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=i.a.createContext({}),p=function(e){var n=i.a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l({},n,{},e)),t},m=function(e){var n=p(e.components);return i.a.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return i.a.createElement(i.a.Fragment,{},n)}},h=Object(r.forwardRef)((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,o=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),m=p(t),h=r,f=m["".concat(o,".").concat(h)]||m[h]||u[h]||a;return t?i.a.createElement(f,l({ref:n},s,{components:t})):i.a.createElement(f,l({ref:n},s))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,o=new Array(a);o[0]=h;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var s=2;s<a;s++)o[s]=t[s];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,t)}h.displayName="MDXCreateElement"}}]);