(window.webpackJsonp=window.webpackJsonp||[]).push([[291],{430:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return a})),t.d(n,"metadata",(function(){return s})),t.d(n,"rightToc",(function(){return l})),t.d(n,"default",(function(){return d}));var i=t(1),r=t(9),o=(t(0),t(441)),a={},s={id:"jme3/tools/charts",title:"charts",description:"Previous: [Navigation](../../jme3/tools/navigation)",source:"@site/docs/jme3/tools/charts.md",permalink:"/wikidemo/docs/jme3/tools/charts",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/tools/charts.md"},l=[],c={rightToc:l};function d(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(i.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Previous: ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"../../jme3/tools/navigation"}),"Navigation")),Object(o.b)("p",null,"In this tutorial we will have a look at creating a simple 3D cartography\napplication that allows you to display 3D charts at different zoom\nlevels."),Object(o.b)("p",null,"This tutorial assumes that you know:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"About the ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"../../jme3/tools/navigation"}),"Navigation package"),".")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"How to create a ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"../../jme3/beginner/hello_terrain"}),"3D\nlandscape")," using image-based\nheightmaps."))),Object(o.b)("p",null,Object(o.b)("img",Object(i.a)({parentName:"p"},{src:"/images/jme3/tools/mercator_grid_3d_small.png",alt:"mercator_grid_3d_small.png"}))),Object(o.b)("p",null,"You will learn that how to account for distortions that arise when\nmapping of one coordinate system into (i.e. when converting\nlongitude/latitude into JME's World Units), how to construct a tile tree\nand how to render a dynamic mercator grid."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"This article was sponsored by ",Object(o.b)("a",Object(i.a)({parentName:"strong"},{href:"http://planetmayo.com/"}),"PlanetMayo\nLtd"))),Object(o.b)("h1",{id:"displaying-your-first-chart"},"Displaying your first chart"),Object(o.b)("p",null,"Let's think about how we are going to get JME to display our terrain.\nThe easiest way is to use JME's","`","ImageBasedHeightMap","`",". Recall from the\n",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"../../jme3/beginner/hello_terrain"}),"Hello Terrain")," tutorial that\nthese are grayscale images which JME uses to create a terrain quad. So,\nin order to display a chart, we need an image of a (two-dimensional)\nmercator projection (such as the one depicted below), which we then load\nusing:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),'Texture heightMapImage = assetManager.loadTexture(DEFAULT_HEIGHTMAP);\nheightmap = new ImageBasedHeightMap(heightMapImage.getImage());\nheightmap.load();\nterrain = new TerrainQuad("terrain", 257, TERRAIN_SIZE, heightmap.getHeightMap());\napplyDefaultTexture();\n')),Object(o.b)("p",null,Object(o.b)("img",Object(i.a)({parentName:"p"},{src:"/images/jme3/tools/globe.png",alt:"A 256x256 mercator projection of planet\nearth."}))),Object(o.b)("p",null,"In essence, 3D chart visualization is achieved by converting the\npolygons composing planet earth's landmass into float matrices whereby\neach value within the matrix represents a specific terrain height. For\nexample, given a terrain of 100 x 100 world units, we construct a\nheightmap by creating a 100 x 100 matrix. Each cell within the matrix\ncorresponds to a terrain coordinate; each cell's value to that\ncoordinate's desired height. But you already knew that, so where's the\ntricky part? Well, when visualizing a chart an accurate projection\nrequires a translation of latitude/longitude coordinates into their\nequivalent world unit (x,y,z) counterparts. This translation however is\nnot a straight forward mapping of one coordinate system into the other\ndue to the distortion arising from projecting an oblate spheroid onto a\nflat surface (see my previous wiki article\n",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"../../jme3/tools/navigation"}),"here"),"). This means that if one would\nadhere to a linear scale, the Mercator projection would distort the size\nand shape of objects as the object distances itself from the equator,\neventually resulting in infinite scaling as the pole is reached. So the\nfirst task at hand, is to construct accurate 2D projections of planet\nearth which we can then use as heightmaps. We can achieve this using the\njme3.tools.navigation package and co-ordinate sets available at\n",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"http://www.ngdc.noaa.gov/mgg/coast/"}),"noaa.gov"),"."),Object(o.b)("p",null,"As ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"../../jme3/tools/navigation"}),"previously discussed"),", the\ndistortion in latitude is derived by using the difference in meridional\nparts between the chart's centre and the current position as a baseline;\nthrough converting the difference to world units by dividing it by the\nnumber of world units contained within one minute, a latitude's\ny-coordinate can be obtained. Calculating a position's x-coordinate is\nsomewhat easier as the distortion only applies to latitude, not\nlongitude. Therefore x merely equals the sum or difference between\nitself and the viewport's centre coordinate, depending on the relative\nlocation of the position itself and the chart's centre. Despite being\nable to convert between the two coordinate systems, slight precision\nproblems remain once the chart projection is scaled down past a level of\n6 meters. This is caused by the pixel referencing system of modern\ndisplays being integer based; once the ratio of minutes to pixels\nexceeds the aforementioned threshold, slight inaccuracies are introduced\ninto the display. However this is of little relevance to most GIS (such\nas Debrief) as a) the inaccuracies are a matter of meters (or even\ncentimetres) and b) it is impossible to notice this variation as GPS\nexposes a much higher inaccuracy (between 10 - 100 meters)."),Object(o.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(o.b)("div",Object(i.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(i.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(i.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(i.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(o.b)("div",Object(i.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"To lessen the computational load, coordinate system conversion should\nonly takes place when either the chart is re-centered or a change in\nscale / resolution is requested. Once converted, the coordinate sets are\nrendered to a buffer whose contents is then drawn for every UI update\ncycle."))),Object(o.b)("p",null,"."),Object(o.b)("h1",{id:"creating-your-heightmaps"},"Creating your heightmaps"),Object(o.b)("p",null,"There are two ways to create your heightmaps (also referred to as\n\\'tiles\\' as each heightmap is a tile that composes our chart of the\nworld). One is to use third-party software such as\n",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"http://geotools.org/"}),"GeoTools"),". The other is to use the\njme3.tools.navigation package to write a tile generator:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),'public class TileGenerator {\n    private int lineCount;\n\n    /* List of polygons representing the countries that are to be drawn. */\n    private List<PositionContainer> polygons;\n\n    /* The map projection used to generate the chart image. */\n    private MapModel2D map;\n\n    /* The chart\'s resolution in minutes of longitude per pixel. */\n    private double mpp;\n\n    /* The chart\'s centre. */\n    private Position centre;\n\n    /**\n     * Constructs a new instance of TileGenerator.\n     *\n     * @param worldSize         The width of the chart for which tiles are to be\n     *                          generated.\n     * @since 1.0\n     */\n    public TileGenerator(int worldSize, double mpp, Position centre) {\n        File dataDirectory = new File("data");\n        map = new MapModel2D(worldSize);\n        lineCount = 0;\n        File[] files = dataDirectory.listFiles(new FileFilter() {\n\n            public boolean accept(File pathname) {\n                if (pathname.toString().endsWith(".out")) {\n                    return true;\n                }\n                return false;\n            }\n        });\n        loadChartData(files);\n        this.mpp = mpp;\n        this.centre = centre;\n    }\n    public void createImageMap(int worldSize) {\n        map.setCentre(centre);\n        map.calculateMinutesPerPixel(mpp);\n        System.out.println("Generating chart with world width (in pixels): " + worldSize);\n        System.out.println("Generating chart with meters per pixel: " + map.getMetersPerPixel());\n        BufferedImage img = new BufferedImage(worldSize,\n                worldSize, BufferedImage.TYPE_BYTE_GRAY);\n        Graphics2D g = img.createGraphics();\n        Point point1, point2;\n        GeneralPath polygonPath;\n        g.setColor(Color.WHITE);\n        int containerSize;\n\n        for (PositionContainer container : polygons) {\n            polygonPath = new GeneralPath();\n            containerSize = container.getPositions().size();\n            for (int i = 1; i < containerSize; i++) {\n                point1 = map.toPixel(container.getPositions().get(i));\n                point2 = map.toPixel(container.getPositions().get(i - 1));\n                polygonPath.moveTo((double) point1.getX(), (double) point1.getY());\n                polygonPath.lineTo((double) point1.getX(), (double) point1.getY());\n                polygonPath.lineTo((double) point2.getX(), (double) point2.getY());\n            }\n            g.draw(polygonPath);\n        }\n\n        // Write resulting image to file\n        try {\n            ImageIO.write(img, "png", new File("map.png"));\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n\n\n    /**\n     * Draws depth contours.\n     *\n     * @param img           The image to draw to.\n     * @param worldSize     The size of the chart.\n     * @since 1.0\n     */\n    private void drawContours(BufferedImage img, int worldSize) {\n        map.setCentre(centre);\n        map.calculateMinutesPerPixel(mpp);\n        BufferedImage img2 = new BufferedImage(worldSize,\n                worldSize, BufferedImage.TYPE_BYTE_GRAY);\n        Graphics2D g = img2.createGraphics();\n        g.drawImage(img, null, null);\n        Point point1, point2;\n        GeneralPath polygonPath;\n//        g.setColor(new Color(21, 21, 21));\n        g.setColor(Color.WHITE);\n        int containerSize;\n\n        for (PositionContainer container : polygons) {\n            polygonPath = new GeneralPath();\n            containerSize = container.getPositions().size();\n            for (int i = 1; i < containerSize; i++) {\n                point1 = map.toPixel(container.getPositions().get(i));\n                point2 = map.toPixel(container.getPositions().get(i - 1));\n                polygonPath.moveTo((double) point1.getX(), (double) point1.getY());\n                polygonPath.lineTo((double) point1.getX(), (double) point1.getY());\n                polygonPath.lineTo((double) point2.getX(), (double) point2.getY());\n            }\n            g.draw(polygonPath);\n        }\n\n        // Write resulting image to file\n        try {\n            ImageIO.write(img2, "png", new File("map.png"));\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n\n    /**\n     * Loads country border information from .out files, parses the information\n     * and stores it as a PositionContainer which is later used to\n     * produce the .png chart image.\n     *\n     * @param files             A List of files that contain\n     *                          country border data.\n     * @since 1.0\n     */\n    private void loadChartData(File[] files) {\n        Scanner scan;\n        PositionContainer countryBorderPosition;\n        polygons = new ArrayList<PositionContainer>(300);\n        String tmp = "";\n        String tmpLat;\n        String tmpLong;\n        StringTokenizer stk;\n        Position pos;\n        for (File file : files) {\n            try {\n                scan = new Scanner(file);\n                countryBorderPosition = new PositionContainer();\n                while (scan.hasNext()) {\n                    tmp = scan.nextLine();\n                    if (tmp.startsWith("{") || tmp.startsWith("$") || tmp.startsWith(";")) {\n                        continue;\n                    }\n                    if (tmp.equals("-1")) {\n                        polygons.add(countryBorderPosition);\n                        countryBorderPosition = new PositionContainer();\n                        continue;\n                    }\n                    stk = new StringTokenizer(tmp, " +");\n                    while (stk.hasMoreTokens()) {\n                        tmpLat = stk.nextToken().trim();\n                        if (tmpLat.equals("-1")) {\n                            polygons.add(countryBorderPosition);\n                            countryBorderPosition = new PositionContainer();\n                            continue;\n                        }\n                        tmpLong = stk.nextToken().trim();\n                        pos = new Position(Double.parseDouble(tmpLat), Double.parseDouble(tmpLong));\n                        countryBorderPosition.add(pos);\n                        lineCount++;\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.err.println(tmp);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println("Debug 3D Tile Generator");\n        System.out.println("===========================");\n        args = new String[3];\n        args[0] = "1.2";\n        args[1] = "51.8";\n        args[2] = "-8.3";\n        if (args.length < 3 || args.length > 3) {\n            System.err.println("Incorrect argument usage. Should be mpp latitude longitude");\n            System.err.println("Exiting");\n            return;\n        }\n        String mppStr = args[0];\n        String latitudeStr = args[1];\n        String longitudeStr = args[2];\n        double lon, lat, mpp;\n        Position centre;\n        try {\n            mpp = Double.parseDouble(mppStr);\n        } catch (Exception e) {\n            System.err.println("MPP must be of type Double or Integer.");\n            System.err.println("Exiting");\n            return;\n        }\n        try {\n            lat = Double.parseDouble(latitudeStr);\n        } catch (Exception e) {\n            System.err.println("Latitude must be of type Double or Integer.");\n            System.err.println("Exiting");\n            return;\n        }\n        try {\n            lon = Double.parseDouble(longitudeStr);\n        } catch (Exception e) {\n            System.err.println("Longitude must be of type Double or Integer.");\n            System.err.println("Exiting");\n            return;\n        }\n        try {\n            centre = new Position(lat, lon);\n        } catch (InvalidPositionException ipe) {\n            System.err.println("Invalid latitude or longitude coordinates.");\n            System.err.println("Exiting");\n            return;\n        }\n        System.out.println("Generating chart...Please wait...");\n        TileGenerator generator = new TileGenerator(TerrainViewer.TERRAIN_SIZE - 1, mpp, centre);\n        File chart = new File("map.png");\n        if (!chart.exists()) {\n            generator.createImageMap(TerrainViewer.TERRAIN_SIZE - 1);\n        }\n        try {\n            BufferedImage img = ImageIO.read(chart);\n            generator.drawContours(img, TerrainViewer.TERRAIN_SIZE - 1);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        System.out.println("Chart generated. Placed in file \'chart.png\'. Exiting.");\n    }\n}\n')),Object(o.b)("p",null,"...where .out file contains longitude / latitude coordinate pairs\ndefining landmass contours. Here an extract:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{}),"51.79188150756147+-8.25435369629442\n51.79184641740534+-8.254357553715453\n51.79182071886024+-8.254353833180712\n51.79181370477922+-8.254312317813477\n51.79181369284153+-8.254267011113086\n51.79182535405747+-8.254221642581026\n51.79184870922772+-8.254183732747943\n51.79188146269924+-8.254183530764353\n51.79190724220316+-8.254221208836046\n51.79190960635914+-8.254296874457655\n51.79188150756147+-8.25435369629442\n-1\n51.79165344300885+-8.255042583168985\n51.79161872648091+-8.255072177259352\n51.79158175153456+-8.255082912194254\n51.79156558301037+-8.255041382314799\n51.79156556852833+-8.254985072910559\n51.79158171385971+-8.254936452917438\n51.79159555664058+-8.25487274689492\n51.79161403682817+-8.254824070938184\n51.79164411466118+-8.254798004805433\n51.79168584436759+-8.254817161260844\n51.79170675060084+-8.25487006519348\n51.79169051462138+-8.254930145346941\n51.79167197282713+-8.254993914789209\n51.79165344300885+-8.255042583168985\n")),Object(o.b)("p",null,"(-1 acts as a separator, denoting the end of one polygon and the\nbeginning of another)."),Object(o.b)("p",null,"So what's happening here? Well, we basically read the contents of all\nspecified files, whereby each line is broken up into longitude/latitude\npairs, converted into pixel (x,y) coordinates and used to construct a\npolygon which is added to a polygon container once a polygon separator\nis encountered. Once the object's paint method is called, this polygon\ncontainer is iterated and any polygons falling within the canvas (aka\nviewport) bounds are painted to the graphics context. Essentially, this\nalgorithm can be summarized as follows:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{}),"Constructor ( files ):\n   for each file in files\n      for each line in file\n         if line == -1\n            polygonList.add(polygon)\n            new polygon\n         else\n            polygon.add(parse(line))\n\nPaint ( graphics context ):\n   for each polygon in polygonList\n      if polygon inside view bounds\n         graphics context.paint(polygon)\n")),Object(o.b)("p",null,Object(o.b)("img",Object(i.a)({parentName:"p"},{src:"/images/jme3/tools/heightmap_modelling.png",alt:"Summarizing process of visualizing a chart. From left to right: We\ndraw the coordinates downloaded from noaa.gov.\nIdeally"}))," ",Object(o.b)("strong",{parentName:"p"},"Above:"),"\nSummarizing process of visualizing a chart. From left to right: We draw\nthe coordinates downloaded from noaa.gov. Ideally, each polygon should\nbe filled in a light colour, whilst the surrounding ocean remains dark.\nJME uses these images to create an internal representation of the\nterrain (a float matrix)."),Object(o.b)("p",null,"The heightmaps produced by the ",Object(o.b)("inlineCode",{parentName:"p"},"TileGenerator"),' are essentially arrays\ncontaining float values ranging from 0 to 255. For convenience and\nefficiency, JME treats these arrays as Portable Network Graphic (PNG)\nimages (again, see the Hello Terrain tutorial). This allows us to store\neach tile as an image, meaning that each tile will only need to be\nconstructed once. Essentially what the tile generator therefore does is\ndraw a greyscale image of each tile whereby dark colours (i.e. low\nvalues from 0 - 50) are valleys and high values (200 - 255) become\nmountains or hills. In order to maintain scale, these values are scaled\nby dividing the seabed\'s maximum height (in meters) by the meters per\npixel of the current chart. With only a few specified points, JME\ninterpolates the rest, making terrain construction using heightmaps more\nefficient than defining individual vertices for each pixel on the chart.\nA tile\'s texture is defined by its "Alphamap". This is a copy of its\nheightmap, but instead of defining height values, the floats composing\nthe alphamap image define textures. For this purpose, a method known as\n"texture splatting" is employed, whereby texture data is colour coded.\nThat is, assuming that a spatial has two texture layers (let\'s call them\nTex1 and Tex2), each layer is associated with a colour: in the case of\nDebrief 3D, blue refers to a sand texture and red refers to dirt/grass\ntextures. Although such an approach to texturing may sound confusing at\nfirst, it has the advantages that both heightmaps and alphamaps can be\ncreated in one go, and, as they are based on the same principle, can\neasily be modified in batch rather than individually.'),Object(o.b)("h1",{id:"whats-all-this-talk-about-tiles"},"What's all this talk about tiles?"),Object(o.b)("p",null,"A tile tree is our way of keeping track of individual tiles. All that it\nis, is a set of nested sub-directories that holds charts. The top-level\ndirectory (our root) contains a chart of the entire world, and each\nsub-directory an enlarged area of our planet. For example, inside the\nroot, we may have folders that contain a chart just for Ireland, the UK\nand France. As we traverse the tree further, we get the individual\ncounties or provinces for each country. One way for us to represent this\nmess of directories, is via a ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"http://en.wikipedia.org/wiki/Search_tree"}),"Search\nTree"),"."),Object(o.b)("h1",{id:"creating-a-tile-tree"},"Creating a tile tree"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),'try {\n            File resourceDirectory = new File(worldResourcesDirectory);\n            if (!resourceDirectory.isDirectory()) {\n                System.out.println("Resource path must be a directory");\n                System.exit(1);\n            }\n            worldStructure = new TileTree(resourceDirectory);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n')),Object(o.b)("p",null,"Upon initialization, these tiles are read into memory by the ",Object(o.b)("inlineCode",{parentName:"p"},"TileTree"),'\nobject which treats, as the name suggests, the tiles composing the chart\nas a tree whereby the root node refers to the entire globe. Its children\nrefer to sub-sections of the globe, and its children in turn to\nsub-sections of that sub-section. For example, the "Ireland" node is a\ndirect child of the root node. The "Cork Harbour" node in turn is a\ndirect child of the "Ireland" node and represents an enlarged version of\na sub-section of the Irish coast. Each such Node consists of a unique ID\n(used to identify the node), a list of child nodes, a path to the\nheightmap (tile) that it represents, the zoom level (referred to as the\nlongitude level as the zoom is defined by minutes of longitude per\npixel) and a latitude/longitude pair denoting the tile\'s centre.'),Object(o.b)("p",null,"Each heightmap is rendered depending on which ID the user selects (where\neach node in the tree is listed by its unique ID). As an ID is selected,\nthe tree is traversed to find the node matching the given ID. The path\nto its heightmap is extracted and the heightmap is rendered by\nextracting the float array from the loaded image (that is, a texture\nobject is created and loaded with the heightmap. A ImageBasedHeightMap\nobject is then used to convert the heightmap and alphamap into\ncorresponding height and texture arrays). \u2192 again, see JME tutorial on\nterrain."),Object(o.b)("p",null,"The Tile Tree's contents is stored in assets/Heightmaps, and each\ndirectory level is composed of one descriptor file, one heightmap (in\nthe form of a PNG image) and one alphamap (also in the form of a PNG\nimage). The descriptor files end in a.desc filename extension and\ncontain the geo-coordinate centre of the tile as well as the resolution\nof the node that they are representing (as always, the resolution is\nrepresented in minutes per pixel (mpp)). A descriptor file's sole\npurpose is to allow the re-construction of the tile tree upon\napplication initialization. Specifically, this is achieved by the\nChartModel object which instantiates the TileTree, passing a reference\nto ",Object(o.b)("em",{parentName:"p"},"assets/Heightmaps"),", which ",Object(o.b)("inlineCode",{parentName:"p"},"TileTree")," then recursively scans,\nconstructing the tree by interpreting the descriptor files. It is worth\nnoting that all files per level should be named according to the\nheightmap tile that it represents. That is, if your level represents a\nchart of Ireland and your heightmap is named Ireland.png then your\ndescriptor file should be named ",Object(o.b)("em",{parentName:"p"},"Ireland.desc"),", while your alphamap\nshould be named ",Object(o.b)("em",{parentName:"p"},"Ireland.png.Alphamap.png"),"."),Object(o.b)("p",null,Object(o.b)("img",Object(i.a)({parentName:"p"},{src:"/images/jme3/tools/slide1.jpg",alt:"The Tile Tree"}))," ",Object(o.b)("img",Object(i.a)({parentName:"p"},{src:"/images/jme3/tools/slide2.jpg",alt:"Looking inside a\nnode...\u200b"}))," ",Object(o.b)("strong",{parentName:"p"},"Above:"),' A look inside the\n"Ireland node. We can see the heightmap, descriptor file and alphamap.'),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),'/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage util.datastructure;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport jme3tools.navigation.Position;\n\n/**\n * The TileTree handles the storage and retrieval of individual\n * charts. Each Node corresponds to one chart (a node\'s value being\n * the chart\'s absolute path. It\'s ID being the ID under which it is displayed).\n *\n * The tree reflects the application\'s chart directory structure, with the world\n * as its root and individual countries as its children. Sub-children of these nodes\n * represent "close up" version of each country / geographic sub areas of those countries.\n *\n * @author Benjamin Jakobus\n * @since 1.0\n * @version 1.0\n */\npublic class TileTree {\n\n    /* The tree\'s root node. */\n    private Node root;\n\n    /**\n     * Creates a new instance of TileTree. Nodes are generated\n     * depending on the contents of the resource directory.\n     *\n     * @param resourceDirectory         The root of the application\'s resource\n     *                                  directory (the resource directory being the\n     *                                  directory in which all charts (aka Heightmaps)\n     *                                  are being stored).\n     * @since 1.0\n     */\n    public TileTree(File resourceDirectory) {\n        File directory = null;\n        for (File f : resourceDirectory.listFiles()) {\n            if (f.isDirectory()) {\n                directory = f;\n                continue;\n            }\n            if (f.getName().endsWith(".desc")) {\n                root = initNode(f);\n\n            }\n        }\n        initTileTree(directory, root);\n    }\n\n    /**\n     * Initializes the tree\'s children. The root node should be initialized\n     * prior to calling this method.\n     *\n     * @param resourceDirectory         The root of the application\'s resource\n     *                                  directory (the resource directory being the\n     *                                  directory in which all charts (aka Heightmaps)\n     *                                  are being stored).\n     * @param parentNode                The Node to which all\n     *                                  subsequent nodes should be attached.\n     * @since 1.0\n     */\n    private void initTileTree(File resourceDirectory, Node parentNode) {\n        File directory = null;\n        Node node = null;\n        if (parentNode == null || resourceDirectory == null) {\n            return;\n        }\n        for (File f : resourceDirectory.listFiles()) {\n            if (f.isDirectory()) {\n                directory = f;\n                continue;\n            }\n            if (!f.getName().endsWith(".desc")) {\n                continue;\n            } else {\n                node = initNode(f);\n            }\n        }\n        parentNode.attachChild(node);\n        node = parentNode;\n        initTileTree(directory, parentNode);\n    }\n\n    /**\n     * Initializes an individual node depending on the contents of the descriptor\n     * file (for information on descriptor files, refer to the software documentation).\n     *\n     * @param file                          The descriptor File with\n     *                                      which to initialize the node\'s contents.\n     * @return                              A new Node.\n     * @since 1.0\n     */\n    private Node initNode(File file) {\n        Node node = null;\n        Scanner scan;\n        String resourcePath = null;\n        String nodeID = null;\n        String longitudeLevel = null;\n        Position centre = null;\n        int currentLine = 0;\n        if (file == null) {\n            return node;\n        }\n        try {\n            scan = new Scanner(file);\n            resourcePath = file.getAbsolutePath().replace(".desc", ".png");\n            resourcePath = resourcePath.substring(resourcePath.indexOf("assets"));\n            nodeID =  file.getName().replace(".desc", "") + "_" + file.getParentFile().getName();\n            while (scan.hasNextLine()) {\n                if (currentLine == 0) {\n                    String tmp = scan.nextLine();\n                    String[] array = tmp.split("\\\\+");\n                    centre = new Position(Double.parseDouble(array[0]),\n                            Double.parseDouble(array[1]));\n                    currentLine++;\n                } else {\n                    longitudeLevel = scan.nextLine().trim();\n                }\n            }\n            node = new Node(nodeID, resourcePath, longitudeLevel, centre);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return node;\n    }\n\n    /**\n     * Returns the Node matching the given ID.\n     *\n     * @param nodeID                The ID of the Node that you\n     *                              wish to retrieve.\n     * @return                      The Node matching the given ID.\n     * @since 1.0\n     */\n    public Node find(String nodeID) {\n        return find(root, nodeID);\n    }\n\n    /**\n     * Returns the Node matching the given ID. This method is similar\n     * to find() with the exception that it only begins searching from\n     * a certain node downwards.\n     *\n     * @param nodeToSearch          The Node from which to start searching.\n     * @param nodeID                The ID of the Node that you\n     *                              wish to retrieve.\n     * @return                      The Node matching the given ID.\n     * @since 1.0\n     */\n    private Node find(Node nodeToSearch, String nodeID) {\n        Node newNode = null;\n        if (nodeToSearch == null) {\n            return newNode;\n        }\n        if (nodeToSearch.getNodeID().trim().compareTo(nodeID.trim()) == 0) {\n            return nodeToSearch;\n        } else {\n            for (Node n : nodeToSearch.getChildren()) {\n                newNode = find(n, nodeID);\n                if (newNode != null) {\n                    return newNode;\n                }\n            }\n        }\n        return newNode;\n    }\n\n    /**\n     * Retrieves all nodes within the tree.\n     *\n     * @return                      A List of all nodes within the\n     *                              tree.\n     * @since 1.0\n     */\n    public List<Node> getNodes() {\n        List<Node> nodes = new ArrayList<Node>();\n        getNodes(root, nodes);\n        return nodes;\n    }\n\n    /**\n     * Returns all the children of a specific Node.\n     *\n     * @param node                  The Node whose children you want.\n     * @param nodes                 The List to which to add these children.\n     * @since 1.0\n     */\n    private void getNodes(Node node, List<Node> nodes) {\n        if (node == null) {\n            return;\n        }\n        for (Node n : node.getChildren()) {\n            getNodes(n, nodes);\n        }\n        nodes.add(node);\n    }\n}\n')),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},".and the Node:.")),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"package util.datastructure;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport jme3tools.navigation.Position;\n\n/**\n * An individual node within the TileTree. Each Node\n * represents an individual tile (i.e. heightmap + alphamap).\n *\n * @author Benjamin Jakobus\n * @since 1.0\n * @version 1.0\n */\npublic class Node {\n    /* The node's unique identifier. */\n    private String nodeID;\n\n    /* Path to the resource that the node represents (aka the node's value). */\n    private String resource;\n\n    /* The node's children. */\n    private List<Node> children;\n\n    /* The resolution (width in degrees of longitude) represented by this node.\n     * i.e. the resolution of the chart that the node represents.\n     */\n    private double longitudeLevel;\n\n    /* The centre of the chart (aka tile) that the node represents. */\n    private Position centre;\n\n    /**\n     * Constructor.\n     *\n     * @param nodeID                The node's unique identifier.\n     * @param resource              Path to the resource that the node represents\n     *                              (aka the node's value).\n     * @param longitudeLevel        The resolution (width in degrees of longitude)\n     *                              represented by this node.\n     * @param centre                The centre of the chart (aka tile) that the\n     *                              node represents.\n     * @since 1.0\n     */\n    public Node(String nodeID, String resource, String longitudeLevel, Position centre) {\n        this.nodeID = nodeID;\n        this.resource = resource;\n        this.longitudeLevel = Double.parseDouble(longitudeLevel);\n        this.centre = centre;\n        children = new ArrayList<Node>();\n    }\n\n    /**\n     * Returns all of the node's children.\n     *\n     * @return          A List containing all of the node's children.\n     * @since 1.0\n     */\n    public List<Node> getChildren() {\n        return children;\n    }\n\n    /**\n     * Returns the node's ID.\n     *\n     * @return          The node's unique identifier.\n     * @since 1.0\n     */\n    public String getNodeID() {\n        return nodeID;\n    }\n\n    /**\n     * Returns the path to the tile that the node represents.\n     *\n     * @return          The path to the tile that the node represents.\n     * @since 1.0\n     */\n    public String getResource() {\n        return resource;\n    }\n\n    /**\n     * Attaches a child to this node.\n     *\n     * @param child     The Node to attach.\n     * @since 1.0\n     */\n    public void attachChild(Node child) {\n        children.add(child);\n    }\n\n    /**\n     * Returns the width in degrees of longitude of the chart / resource that this\n     * node represents.\n     *\n     * @return          the width in degrees of longitude of the chart / resource\n     *                  that this node represents.\n     * @since 1.0\n     */\n    public double getLongitudeLevel() {\n        return longitudeLevel;\n    }\n\n    /**\n     * The centre coordinate of the tile / chart that this node represents.\n     *\n     * @return          The chart's centre in terms of latitude / longitude.\n     * @since 1.0\n     */\n    public Position getCentre() {\n        return centre;\n    }\n}\n")),Object(o.b)("p",null,"Loading a new chart is simple: all that we need to do is get the\nTileTree to find the chart for us (it'll handle loading the descriptor\nfile and just return a node):"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"Node node = tileTree.find(chartID);\n")),Object(o.b)("p",null,"We then use the returned node, to adjust our zoom-level:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"mapModel.calculateMinutesPerWorldUnit(node.getLongitudeLevel());\nmapModel.setCentre(node.getCentre());\n")),Object(o.b)("h1",{id:"drawing-the-mercator-grid"},"Drawing the Mercator Grid"),Object(o.b)("p",null,"A mercator grid reflects the \"stretching\" of the flat Mercator chart\nthrough the widening of the longitude / latitude lines. Using JME's Mesh\nclass, a 3D representation of the grid can be drawn procedurally (as\nopposed to pre-defining the mesh's vertices using a 3D modelling tool\nsuch as Blender). This is achieved by defining a vector of positions,\nwhereby each entry i within the vector denotes the starting point of a\ngrid line, and i + 1 defining the line's end-point. Next, the the order\nin which the mesh is constructed from these coordinates is defined.\nThese are basically index pairs as the mesh consists of a set of lines,\neach having a start and end point. Finally, the coordinates vector and\nthe indices are added to the mesh, which in turn is used to define the\nGeometry that is added to the scene graph:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),'public void createGrid(double longitudeLevel, float increment) {\n        granularity = increment;\n        Mesh m = new Mesh();\n        m.setMode(Mesh.Mode.Lines);\n        m.setLineWidth(1f);\n\n        float max = (longitudeLevel < 8 ? 2 : 85);\n        float max2 = (longitudeLevel < 8 ? 180 / 8 : 180);\n        Vector3f[] positions = new Vector3f[(int) (Math.ceil(max / increment) * 4) + (int) (Math.ceil(max2 / increment) * 4)];\n        Position pos;\n\n        int i = 0;\n        try {\n            // Calculate initial spacings for the meridians and\n            // parallels\n\n\n            // Approach the grid construction from north to south and\n            // east to west.\n            positions[0] = new Vector3f(0, 0, 0);\n\n            // Latitude lines for northern hemisphere\n            for (float lat = 0; lat < max; lat += increment, i += 2) {\n                pos = new Position(lat, 180);\n                positions[i] = TerrainViewer.mapModel.toWorldUnit(new Position(lat, -180));\n                positions[i + 1] = TerrainViewer.mapModel.toWorldUnit(pos);\n            }\n\n            // Latitude lines for southern hemisphere\n            for (float lat = 0; lat < max; lat += increment, i += 2) {\n                pos = new Position(lat * -1, 180);\n                positions[i] = TerrainViewer.mapModel.toWorldUnit(new Position(lat * -1, -180));\n                positions[i + 1] = TerrainViewer.mapModel.toWorldUnit(pos);\n            }\n\n            max = (longitudeLevel < 8 ? 180 / 8 : 180);\n            // Longitude lines for northern hemisphere\n            for (float lon = 0; lon < max; lon += increment, i += 2) {\n                pos = new Position(85, lon);\n                positions[i] = TerrainViewer.mapModel.toWorldUnit(new Position(-85, lon));\n                positions[i + 1] = TerrainViewer.mapModel.toWorldUnit(pos);\n            }\n\n            // Longitude lines for southern hemisphere\n            for (float lon = 0; lon < max; lon += increment, i += 2) {\n                pos = new Position(85, lon * -1);\n                positions[i] = TerrainViewer.mapModel.toWorldUnit(new Position(-85, lon * -1));\n                positions[i + 1] = TerrainViewer.mapModel.toWorldUnit(pos);\n            }\n        } catch (Exception ipe) {\n\n        }\n\n        int[] indices = new int[i];\n        int v;\n        for (i = 0, v = 0; i < indices.length; i += 2, v++) {\n            indices[i] = i;\n            indices[i + 1] = i + 1;\n        }\n\n        m.setBuffer(Type.Position, 3, BufferUtils.createFloatBuffer(positions));\n\n        m.setBuffer(Type.Index, 1, indices);\n        m.updateBound();\n        m.updateCounts();\n        Material mat = new Material(assetManager, "Common/MatDefs/Misc/Unshaded.j3md");\n        mat.setColor("m_Color", ColorRGBA.Gray);\n        gridGeometry = new Geometry("Grid", m);\n        gridGeometry.setMaterial(mat);\n        Vector3f worldCentre = TerrainViewer.mapModel.getCentreWu();\n        gridGeometry.setLocalTranslation(new Vector3f(worldCentre.getX(),\n                gridHeight, worldCentre.getZ()));\n    }\n')),Object(o.b)("p",null,Object(o.b)("img",Object(i.a)({parentName:"p"},{src:"/images/jme3/tools/screen_shot_2011-12-18_at_13.12.01.png",alt:"screen_shot_2011-12-18_at_13.12.01.png"}))))}d.isMDXComponent=!0},441:function(e,n,t){"use strict";t.d(n,"a",(function(){return h})),t.d(n,"b",(function(){return g}));var i=t(0),r=t.n(i);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=r.a.createContext({}),d=function(e){var n=r.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s({},n,{},e)),t},h=function(e){var n=d(e.components);return r.a.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},u=Object(i.forwardRef)((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,a=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=d(t),u=i,g=h["".concat(a,".").concat(u)]||h[u]||p[u]||o;return t?r.a.createElement(g,s({ref:n},c,{components:t})):r.a.createElement(g,s({ref:n},c))}));function g(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,a=new Array(o);a[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,a[1]=s;for(var c=2;c<o;c++)a[c]=t[c];return r.a.createElement.apply(null,a)}return r.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"}}]);