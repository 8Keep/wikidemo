(window.webpackJsonp=window.webpackJsonp||[]).push([[134],{273:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return r})),n.d(t,"default",(function(){return u}));var a=n(1),o=n(9),i=(n(0),n(441)),s={},l={id:"jme3/advanced/collision_and_intersection",title:"collision_and_intersection",description:"The term collision can be used to refer to [physical",source:"@site/docs/jme3/advanced/collision_and_intersection.md",permalink:"/wikidemo/docs/jme3/advanced/collision_and_intersection",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/advanced/collision_and_intersection.md"},r=[{value:"Code Sample",id:"code-sample",children:[]},{value:"Usage",id:"usage",children:[]}],c={rightToc:r};function u(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"The term collision can be used to refer to ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/advanced/physics_listeners"}),"physical\ninteractions")," (where\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/advanced/physics"}),"physical objects")," collide, push and\nbump off one another), and also to non-physical ",Object(i.b)("em",{parentName:"p"},"intersections")," in 3D\nspace. This article is about the non-physical (mathematical) collisions."),Object(i.b)("p",null,"Non-physical collision detection is interesting because it uses less\ncomputing resources than physical collision detection. The non-physical\ncalculations are faster because they do not have any side effects such\nas pushing other objects or bumping off of them. Tasks such as ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/advanced/mouse_picking"}),"mouse\npicking")," are easily implemented\nusing mathematical techniques such as ray casting and intersections.\nExperienced developers optimize their games by finding ways to simulate\ncertain (otherwise expensive physical) interactions in a non-physical\nway."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")," One example for an optimization is a physical vehicle's\nwheels. You could make the wheels fully physical disks, and have jME\ncalculate every tiny force -- sounds very accurate? It's total overkill\nand too slow for a racing game. A more performant solution is to cast\nfour invisible rays down from the vehicle and calculate the\nintersections with the floor. These non-physical wheels require (in the\nsimplest case) only four calculations per tick to achieve an effect that\nplayers can hardly distinguish from the real thing."),Object(i.b)("h1",{id:"collidable"},"Collidable"),Object(i.b)("p",null,"The interface com.jme3.collision.Collidable declares one method that\nreturns how many collisions were found between two Collidables:\n",Object(i.b)("inlineCode",{parentName:"p"},"collideWith(Collidable other, CollisionResults results)"),"."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"A ",Object(i.b)("inlineCode",{parentName:"p"},"com.jme3.collision.CollisionResults")," object is an ArrayList of\ncomparable ",Object(i.b)("inlineCode",{parentName:"p"},"com.jme3.collision.CollisionResult")," objects.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"You can iterate over the CollisionResults to identify the other\nparties involved in the collision.\\\nNote that jME counts ",Object(i.b)("em",{parentName:"p"},"all")," collisions, this means a ray intersecting\na box will be counted as two hits, one on the front where the ray\nenters, and one on the back where the ray exits."))),Object(i.b)("p",null,"+-----------------------------------+-----------------------------------+\n| CollisionResults Method           | Usage                             |\n+===================================+===================================+\n| size()                            | Returns the number of             |\n|                                   | CollisionResult objects.          |\n+-----------------------------------+-----------------------------------+\n| getClosestCollision()             | Returns the CollisionResult with  |\n|                                   | the lowest distance.              |\n+-----------------------------------+-----------------------------------+\n| getFarthestCollision()            | Returns the CollisionResult with  |\n|                                   | the farthest distance.            |\n+-----------------------------------+-----------------------------------+\n| getCollision(i)                   | Returns the CollisionResult at    |\n|                                   | index i.                          |\n+-----------------------------------+-----------------------------------+"),Object(i.b)("p",null,"A CollisionResult object contains information about the second party of\nthe collision event."),Object(i.b)("p",null,"+-----------------------------------+-----------------------------------+\n| CollisionResult Method            | Usage                             |\n+===================================+===================================+\n| getContactPoint()                 | Returns the contact point         |\n|                                   | coordinate on the second party,   |\n|                                   | as Vector3f.                      |\n+-----------------------------------+-----------------------------------+\n| getContactNormal()                | Returns the Normal vector at the  |\n|                                   | contact point, as Vector3f.       |\n+-----------------------------------+-----------------------------------+\n| getDistance()                     | Returns the distance between the  |\n|                                   | Collidable and the second party,  |\n|                                   | as float.                         |\n+-----------------------------------+-----------------------------------+\n| getGeometry()                     | Returns the Geometry of the       |\n|                                   | second party.                     |\n+-----------------------------------+-----------------------------------+\n| getTriangle(t)                    | Binds t to the triangle t on the  |\n|                                   | second party's mesh that was hit. |\n+-----------------------------------+-----------------------------------+\n| getTriangleIndex()                | Returns the index of the triangle |\n|                                   | on the second party's mesh that   |\n|                                   | was hit.                          |\n+-----------------------------------+-----------------------------------+"),Object(i.b)("h2",{id:"code-sample"},"Code Sample"),Object(i.b)("p",null,"Assume you have two collidables a and b and want to detect collisions\nbetween them. The collision parties can be Geometries, Nodes with\nGeometries attached (including the rootNode), Planes, Quads, Lines, or\nRays. An important restriction is that you can only collide geometry vs\nbounding volumes or rays. (This means for example that a must be of Type\nNode or Geometry and b respectively of Type BoundingBox, BoundingSphere\nor Ray.)"),Object(i.b)("p",null,"The following code snippet can be triggered by listeners (e.g. after an\ninput action such as a click), or timed in the update loop."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'  // Calculate detection results\n  CollisionResults results = new CollisionResults();\n  a.collideWith(b, results);\n  System.out.println("Number of Collisions between" +\n      a.getName()+ " and " + b.getName() + ": " + results.size());\n  // Use the results\n  if (results.size() > 0) {\n    // how to react when a collision was detected\n    CollisionResult closest  = results.getClosestCollision();\n    System.out.println("What was hit? " + closest.getGeometry().getName() );\n    System.out.println("Where was it hit? " + closest.getContactPoint() );\n    System.out.println("Distance? " + closest.getDistance() );\n  } else {\n    // how to react when no collision occured\n  }\n}\n')),Object(i.b)("p",null,"You can also loop over all results and trigger different reactions\ndepending on what was hit and where it was hit. In this example, we\nsimply print info about them."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'  // Calculate Results\n  CollisionResults results = new CollisionResults();\n  a.collideWith(b, results);\n  System.out.println("Number of Collisions between" + a.getName()+ " and "\n   + b.getName() " : " + results.size());\n  // Use the results\n  for (int i = 0; i < results.size(); i++) {\n    // For each hit, we know distance, impact point, name of geometry.\n    float     dist = results.getCollision(i).getDistance();\n    Vector3f    pt = results.getCollision(i).getContactPoint();\n    String   party = results.getCollision(i).getGeometry().getName();\n    int        tri = results.getCollision(i).getTriangleIndex();\n    Vector3f  norm = results.getCollision(i).getTriangle(new Triangle()).getNormal();\n    System.out.println("Details of Collision #" + i + ":");\n    System.out.println("  Party " + party + " was hit at " + pt + ", " + dist + " wu away.");\n    System.out.println("  The hit triangle #" + tri + " has a normal vector of " + norm);\n  }\n')),Object(i.b)("p",null,"Knowing the distance of the collisions is useful for example when you\nintersect Lines and Rays with other objects."),Object(i.b)("h1",{id:"bounding-volumes"},"Bounding Volumes"),Object(i.b)("p",null,"A ",Object(i.b)("inlineCode",{parentName:"p"},"com.jme3.bounding.BoundingVolume")," is an interface for dealing with\ncontainment of a collection of points. All BoundingVolumes are\n",Object(i.b)("inlineCode",{parentName:"p"},"Collidable")," and are used as optimization to calculate non-physical\ncollisions more quickly: It's always faster to calculate an intersection\nbetween simple shapes like spheres and boxes than between complex shapes\nlike models."),Object(i.b)("p",null,"jME3 computes bounding volumes for all objects. These bounding volumes\nare later used for frustum culling, which is making sure only objects\nvisible on-screen are actually sent for rendering."),Object(i.b)("p",null,"All fast-paced action and shooter games use BoundingVolumes as an\noptimization. Wrap all complex models into simpler shapes -- in the end,\nyou get equally useful collision detection results, but faster. ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"http://en.wikipedia.org/wiki/Bounding_volume"}),"More\nabout bounding\nvolumes...\u200b")),Object(i.b)("p",null,"Supported types:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Type.AABB = Axis-aligned bounding box, that means it doesn't rotate,\nwhich makes it less precise. A ",Object(i.b)("inlineCode",{parentName:"p"},"com.jme3.bounding.BoundingBox")," is an\naxis-aligned cuboid used as a container for a group of vertices of a\npiece of geometry. A BoundingBox has a center and extents from that\ncenter along the x, y and z axis. This is the default bounding\nvolume, since it is fairly fast to generate and gives better\naccuracy than the bounding sphere.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Type.Sphere: ",Object(i.b)("inlineCode",{parentName:"p"},"com.jme3.bounding.BoundingSphere")," is a sphere used as\na container for a group of vertices of a piece of geometry. A\nBoundingSphere has a center and a radius.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Type.OBB = Oriented bounding box. This bounding box is more precise\nbecause it can rotate with its content, but is computationally more\nexpensive. (Currently not supported.)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},'Type.Capsule = Cylinder with rounded ends, also called "swept\nsphere. Typically used for mobile characters. (Currently not\nsupported.)'))),Object(i.b)("p",null,"::: {.note}\nNote: If you are looking for bounding volumes for physical objects, use\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/advanced/physics"}),"CollisionShapes"),".\n:::"),Object(i.b)("h2",{id:"usage"},"Usage"),Object(i.b)("p",null,"For example you can use Bounding Volumes on custom meshes, or complex\nnon-physical shapes."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"mesh.setBound(new BoundingSphere());\nmesh.updateBound();\n")),Object(i.b)("h1",{id:"mesh-and-scene-graph-collision"},"Mesh and Scene Graph Collision"),Object(i.b)("p",null,"One of the supported ",Object(i.b)("inlineCode",{parentName:"p"},"Collidable"),"s are meshes and scene graph objects.\nTo execute a collision detection query against a scene graph, use\n",Object(i.b)("inlineCode",{parentName:"p"},"Spatial.collideWith()"),". This will traverse the scene graph and return\nany mesh collisions that were detected. Note that the first collision\nagainst a particular scene graph may take a long time, this is because a\nspecial data structure called ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"http://en.wikipedia.org/wiki/Bounding_interval_hierarchy"}),"Bounding Interval Hierarchy\n(BIH)")," needs\nto be generated for the meshes. At a later point, the mesh could change\nand the BIH tree would become out of date, in that case, call\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"%7Blink-javadoc%7D/com/jme3/scene/Mesh.html#createCollisionData--"}),"Mesh.createCollisionData()"),"\non the changed mesh to update the BIH tree."),Object(i.b)("h1",{id:"intersection"},"Intersection"),Object(i.b)("p",null,"A ",Object(i.b)("inlineCode",{parentName:"p"},"com.jme3.math.Ray")," is an infinite line with a beginning, a direction,\nand no end; whereas a ",Object(i.b)("inlineCode",{parentName:"p"},"com.jme3.math.Line")," is an infinite line with only\na direction (no beginning, no end)."),Object(i.b)("p",null,'Rays are used to perform line-of-sight calculations. This means you can\ndetect what users were "aiming at when they clicked or pressed a key.\nYou can also use this to detect whether game characters can see\nsomething (or someone) or not.'),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Click to select:")," You can determine what a user has clicked by\ncasting a ray from the camera forward in the direction of the\ncamera. Now identify the closest collision of the ray with the\nrootNode, and you have the clicked object.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Line of sight:")," Cast a ray from a player in the direction of\nanother player. Then you detect all collisions of this ray with\nother entities (walls versus foliage versus window panes) and use\nthis to calculate how likely it is that one can see the other."))),Object(i.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"These simple but powerful ray-surface intersection tests are called Ray\nCasting. As opposed to the more advanced Ray Tracing technique, Ray\nCasting does not follow the ray's reflection after the first hit -- the\nray just goes straight on."))),Object(i.b)("p",null,"Learn the details of how to implement ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/advanced/mouse_picking"}),"Mouse\nPicking")," here."),Object(i.b)("p",null,"TODO:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Bounding Interval Hierarchy (",Object(i.b)("inlineCode",{parentName:"p"},"com.jme3.collision.bih.BIHNode"),")")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"com.jme3.scene.CollisionData"))))}u.isMDXComponent=!0},441:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return d}));var a=n(0),o=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=o.a.createContext({}),u=function(e){var t=o.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l({},t,{},e)),n},p=function(e){var t=u(e.components);return o.a.createElement(c.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},h=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),p=u(n),h=a,d=p["".concat(s,".").concat(h)]||p[h]||b[h]||i;return n?o.a.createElement(d,l({ref:t},c,{components:n})):o.a.createElement(d,l({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=h;var l={};for(var r in t)hasOwnProperty.call(t,r)&&(l[r]=t[r]);l.originalType=e,l.mdxType="string"==typeof e?e:a,s[1]=l;for(var c=2;c<i;c++)s[c]=n[c];return o.a.createElement.apply(null,s)}return o.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);