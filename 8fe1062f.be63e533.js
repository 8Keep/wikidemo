(window.webpackJsonp=window.webpackJsonp||[]).push([[166],{305:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return p}));var a=n(1),o=n(9),i=(n(0),n(441)),r={},s={id:"jme3/advanced/jme3_ai",title:"jme3_ai",description:"Most games written need some type of [Artificial",source:"@site/docs/jme3/advanced/jme3_ai.md",permalink:"/wikidemo/docs/jme3/advanced/jme3_ai",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/advanced/jme3_ai.md"},l=[{value:"From the SDK",id:"from-the-sdk",children:[]},{value:"Procedural Method",id:"procedural-method",children:[]},{value:"Loading the NavMesh",id:"loading-the-navmesh",children:[]},{value:"Communicating with NavigationControl",id:"communicating-with-navigationcontrol",children:[]},{value:"NavigationControl",id:"navigationcontrol",children:[]},{value:"Pathfinding Thread",id:"pathfinding-thread",children:[]}],c={rightToc:l};function p(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Most games written need some type of ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Artificial_intelligence_(video_games)"}),"Artificial\nIntelligence"),"\nto deliver a feeling of realism, excitement or challenge to the player.\nAI can be as simple as having an NPC (Non Player Character) respond to\nsome action taken by a player or as complicated as smoothly navigating\nyour way through a scene full of obstacles without getting stuck. It's a\ntime-consuming and significant challenge to develop these systems so its\nmuch easier to use an existing library to do the heavy lifting for you."),Object(i.b)("p",null,"Unfortunately, the jMonkeyEngine comes with no official library for\ndealing with AI. There is, however, the jme3 Artificial Intelligence\nlibrary that is probably the closest there is to an official release.\nAlthough it never made it into any official releases, it was designed,\nin part, by core team members. It consists of two separate AI models, a\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Navigation_mesh"}),"Navigation Mesh")," library\nusing ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Pathfinding"}),"path-finding"),", and a\nsimple Steering Behaviours library that uses path-following."),Object(i.b)("p",null,"You can read about the introduction of the library in the forum thread:\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://hub.jmonkeyengine.org/t/ai-plugin-now-with-navmesh-pathfinding/24644"}),"AI plugin now with NavMesh\npath-finding"),"."),Object(i.b)("h1",{id:"requirements"},"Requirements"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/MeFisto94/jme3-artificial-intelligence/releases"}),"jme3 Artificial Intelligence\nLibrary")," -\nThe library and javaDocs for jme3AI. This is also where you can\nreport problems or help in maintaining the library.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/stevefsp/critterai/releases"}),"CritterAI")," -\nStephen Pratt's ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"http://www.critterai.org/projects/nmgen_study/"}),"NMGen\nStudy")," project files\nto generate the navmesh.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"To get the assets (3D models) used in this example, add the\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../../sdk/sample_code.xml#jme3testdata-assets#"}),"jME3-testdata.jar"),"\nto your classpath.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Java SDK 8+."))),Object(i.b)("p",null,"Stephen Pratt explains in detail the configuration parameters of\nCritterAI/Jme3AI in a easy to follow format and is suggested reading."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"http://www.critterai.org/projects/nmgen_study/config.html"}),"Configuration\nParameters"))),Object(i.b)("h1",{id:"use-example"},"Use Example"),Object(i.b)("p",null,"The jme3 Artificial Intelligence Library contains:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"NavMesh - A Navigation Mesh path-finding AI system using the\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/A*_search_algorithm"}),"A","*"),"\nalgorithm.",Object(i.b)("sup",Object(a.a)({parentName:"p"},{id:"fnref-1"}),Object(i.b)("a",Object(a.a)({parentName:"sup"},{href:"#fn-1",className:"footnote-ref"}),"1")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Steering - The foundations of an ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"http://natureofcode.com/book/chapter-6-autonomous-agents/"}),"Autonomous\nAgent"),"\nsystem that uses path-following and forces to move a character\nthrough its environment. Includes a test case as well.",Object(i.b)("sup",Object(a.a)({parentName:"p"},{id:"fnref-2"}),Object(i.b)("a",Object(a.a)({parentName:"sup"},{href:"#fn-2",className:"footnote-ref"}),"2")),"\xa0"))),Object(i.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"This scope of this tutorial is restricted to the NavMesh part of the\nlibrary and expands upon the lessons taught in the\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3.xml#tutorials-for-beginners"}),"tutorials"),". It demonstrates the\nuse of some classes and methods found in the Medium and Advanced topics\nof the wiki as well. You can find the source code for this tutorial in\nthe\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/doc-examples/tree/master/src/com/jme3/examples/jme3ai"}),"jMonkeyEngine/docs-examples"),"\nrepository."))),Object(i.b)("p",null,"Moving a character through your scene requires three things."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"A navigation mesh.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"A path-finding component that uses that navigation mesh to calculate\na path.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"A way to move the character."))),Object(i.b)("h1",{id:"navmesh-creation"},"NavMesh Creation"),Object(i.b)("p",null,"The first thing you need for path-finding is a navigation mesh. There\nare two ways to generate the NavMesh, procedural or the jMonkey\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/sdk/releases"}),"SDK"),"."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"The SDK has a built-in command, but comes with a trade-off that no\nparameter exceptions are thrown. This means you are flying blind\nwhen the NavMesh fails generation.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"If you choose procedural, you see any generation exceptions, but you\nwill have to do a little more work like saving, loading and/or\ndisplaying the NavMesh."))),Object(i.b)("p",null,"Both methods produce exactly the same NavMesh and both will be covered\nin this tutorial."),Object(i.b)("h2",{id:"from-the-sdk"},"From the SDK"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Open your scene in the Terrain Editor or Scene Explorer by RMB\nselecting the file in your assets folder and choosing ",Object(i.b)("inlineCode",{parentName:"p"},"Edit Terrain"),"\nor ",Object(i.b)("inlineCode",{parentName:"p"},"Edit in SceneComposer"),".")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Once open, RMB select the root node in the ",Object(i.b)("inlineCode",{parentName:"p"},"SceneExplorer")," and then\nselect ",Object(i.b)("inlineCode",{parentName:"p"},"Spatial NavMesh"),"."))),Object(i.b)("p",null,"This will open the ",Object(i.b)("inlineCode",{parentName:"p"},"Create NavMesh")," dialog with default settings. You\ncan read in depth about each parameter by following the\n",Object(i.b)("inlineCode",{parentName:"p"},"Configuration Parameters")," link under\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/advanced/jme3_ai.xml#requirements#"}),"Requirements"),"."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Parameter Insight.")),Object(i.b)("p",null,"The jme3AI system uses CritterAI, which is based off ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/recastnavigation/recastnavigation"}),"Recast and\nDetour"),"\nnavigation. The author of Recast lays out a few specific rules for\nNavMesh creation in this ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"http://digestingduck.blogspot.dk/2009/08/recast-settings-uncovered.html"}),"blog\npost"),",\nwhich logically apply to jme3AI. Below is a translation of this post as\nit pertains to jme3AI."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},'First you should decide the size of your character \\"capsule\\". For\nexample, if you are using meters as units in your game world, a good\nsize of human sized character might be (r)adius=0.4, (h)eight=2.0.')),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Next the voxelization cell size (cs) will be derived from that.\nUsually good value for cs is r/2 or r/3. In outdoor environments,\nr/2 might be enough, indoors you sometimes want the extra precision\nand you might choose to use r/3 or smaller.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"The voxelization cell height (ch) is defined separately in order to\nallow greater precision in height tests. Good starting point for ch\nis cs/2. If you get small holes where there are discontinuities in\nthe height (steps), you may want to decrease cell height.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Next up is the character definition values. First up is\n",Object(i.b)("inlineCode",{parentName:"p"},"minTraversableHeight"),", which defines the height of the agent.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"The ",Object(i.b)("inlineCode",{parentName:"p"},"maxTraversableStep")," defines how high steps the character can\nclimb.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"The parameter ",Object(i.b)("inlineCode",{parentName:"p"},"traversableAreaBorderSize")," defines the agent radius.\nIf this value is greater than zero, the navmesh will be shrunken by\nthe ",Object(i.b)("inlineCode",{parentName:"p"},"traversableAreaBorderSize"),". If you want to have tight fit\nnavmesh, use zero radius.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"The parameter ",Object(i.b)("inlineCode",{parentName:"p"},"maxTraversableSlope")," is used before voxelization to\ncheck if the slope of a triangle is too high and those polygons will\nbe given a non-walkable flag. The parameter is in radians.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"In certain cases really long outer edges may decrease the\ntriangulation results. Sometimes this can be remedied by just\ntessellating the long edges. The parameter ",Object(i.b)("inlineCode",{parentName:"p"},"maxEdgeLength")," defines\nthe max edge length. A good value for ",Object(i.b)("inlineCode",{parentName:"p"},"maxEdgeLength")," is something\nlike ",Object(i.b)("inlineCode",{parentName:"p"},"traversableAreaBorderSize*8"),". A good way to tweak this value\nis to first set it really high and see if your data creates long\nedges. If so, then try to find as big value as possible which happen\nto create those few extra vertices which makes the tessellation\nbetter.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"When the rasterized areas are converted back to vectorized\nrepresentation the ",Object(i.b)("inlineCode",{parentName:"p"},"edgeMaxDeviation")," describes how loosely the\nsimplification is done. Good values are between 1.1-1.5 (1.3 usually\nyield good results). If the value is less, some stair-casing starts\nto appear at the edges and if it is more than that, the\nsimplification starts to cut some corners."))),Object(i.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"A summary of the parameter effects is included in the comments of the\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/doc-examples/blob/master/src/com/jme3/examples/jme3ai/ai/NavMeshState.java"}),"NavMeshState.java"),"\nfile and discussed in the Procedural code examples that follow this\nsection."))),Object(i.b)("p",null,"If there are problems with your parameter settings, you will only know\nif the NavMesh doesn't appear under the Node you selected and there is\nno task running in the status area located at the bottom right of the\nSDK."),Object(i.b)("p",null,"If the NavMesh doesn't appear, then you will have to make adjustments to\nthe ",Object(i.b)("inlineCode",{parentName:"p"},"Configuration Parameters")," until it completes successfully. Minor\nadjustments to cell size will usually work."),Object(i.b)("p",null,"::: {.caution}\nCell size has the greatest impact on your NavMesh. The smaller the cell\nsize, the more accurate the NavMesh, the longer it takes to generate.\nGenerating a 1024x1024 NavMesh can take anywhere from 30 seconds to ten\nminutes to complete, depending on terrain complexity. Even larger\nNavMeshes can take many hours.\n:::"),Object(i.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"Selecting the NavMesh node in the SceneExplorer will show the NavMesh in\nthe Terrain Editor or SceneComposer view-port. If it doesn't show, with\nthe NavMesh node selected, change the ",Object(i.b)("inlineCode",{parentName:"p"},"Cull Hint")," to ",Object(i.b)("inlineCode",{parentName:"p"},"Never")," in the\n",Object(i.b)("inlineCode",{parentName:"p"},"NavMesh - Properties")," panel."))),Object(i.b)("h2",{id:"procedural-method"},"Procedural Method"),Object(i.b)("p",null,"There are many ways to create a NavMesh. If you look at the constructor\nfor the\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/doc-examples/blob/master/src/com/jme3/examples/jme3ai/Jme3AI.java"}),"Jme3AI.java"),"\nfile, you will see I use a\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/advanced/application_states.xml#baseappstate#"}),"BaseAppState"),"\nnamed\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/doc-examples/blob/master/src/com/jme3/examples/jme3ai/ai/NavMeshState.java"}),"NavMeshState.java"),"\nwhich creates a ",Object(i.b)("inlineCode",{parentName:"p"},"generator")," object and builds the ",Object(i.b)("inlineCode",{parentName:"p"},"NavMesh")," new every\ntime the program is ran."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Jme3AI constructor.")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"public Jme3AI() {\n    super(new StatsAppState(), new DebugKeysAppState(), new TerrainState(),\n            new NavMeshState(), new PCState(), new KeyboardRunState());\n}\n")),Object(i.b)("p",null,"It can take from seconds to hours to build a NavMesh, depending on how\ncomplicated it is. Therefore, you would normally build the NavMesh or\nmeshes, add them to your ",Object(i.b)("inlineCode",{parentName:"p"},"Assets")," folder and load them at startup. The\n",Object(i.b)("inlineCode",{parentName:"p"},"NavMeshState")," and ",Object(i.b)("inlineCode",{parentName:"p"},"NavMeshGenerator")," classes are both convenience\nclasses and are not required to create a NavMesh. If you wish to keep\nyour game minimalist, you can set the variables for the CritterAI\nNavmeshGenerator (note the lower case \\'m\\' in mesh) in the method call\ndirectly or by variable, and pass the IndexBuffer and VertexBuffer of\nyour mesh into the CritterAI NavmeshGenerator object."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"NavmeshGenerator nmgen = new NavmeshGenerator(cellSize, cellHeight, minTraversableHeight,\n                maxTraversableStep, maxTraversableSlope,\n                clipLedges, traversableAreaBorderSize,\n                smoothingThreshold, useConservativeExpansion,\n                minUnconnectedRegionSize, mergeRegionSize,\n                maxEdgeLength, edgeMaxDeviation, maxVertsPerPoly,\n                contourSampleDistance, contourMaxDeviation);\n...\nGet mesh buffers and set IntermediateData\n...\n\n//Pass buffers and IntermediateData to build process\nTriangleMesh triMesh = nmgen.build(positions, indices, intermediateData);\n\n...\nProcess trimesh\n...\n")),Object(i.b)("p",null,"Let's examine what it takes to create the ",Object(i.b)("inlineCode",{parentName:"p"},"NavMesh")," using the\n",Object(i.b)("inlineCode",{parentName:"p"},"NavMeshState")," and ",Object(i.b)("inlineCode",{parentName:"p"},"NavMeshGenerator")," helper classes."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"NavMeshState NavMesh generation method.")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'/**\n * creates the NavMesh\n */\nprivate void createNavMesh() {\n    generator = new NavMeshGenerator();\n    //The width and depth resolution used when sampling the source geometry.\n    //outdoors = agentRadius/2, indoors = agentRadius/3, cellSize =\n    //agentRadius for very small cells.\n    //Constraints > 0 , default=1\n    generator.setCellSize(.25f);\n    //The height resolution used when sampling the source geometry.\n    //minTraversableHeight, maxTraversableStep, and contourMaxDeviation\n    //will need to be greater than the value of cellHeight in order to\n    //function correctly. maxTraversableStep is especially susceptible to\n    //impact from the value of cellHeight.\n    //cellSize/2\n    //Constraints > 0, default=1.5\n    generator.setCellHeight(.125f);\n    //Represents the minimum floor to ceiling height that will still allow\n    //the floor area to be considered traversable.\n    //minTraversableHeight should be at least two times the value of\n    //cellHeight in order to get good results. Max spatial height.\n    //Constraints > 0, default=7.5\n    generator.setMinTraversableHeight(2f);\n    //Represents the maximum ledge height that is considered to still be\n    //traversable.\n    //maxTraversableStep should be greater than two times cellHeight.\n    //Constraints >= 0, default=1\n    generator.setMaxTraversableStep(0.3f);\n    //The maximum slope that is considered traversable. (In degrees.)\n    //Constraints >= 0, default=48\n    generator.setMaxTraversableSlope(50.0f);\n    //Indicates whether ledges should be considered un-walkable.\n    //Constraints None, default=false\n    generator.setClipLedges(false);\n    //Represents the closest any part of a mesh can get to an obstruction in\n    //the source geometry.\n    //traversableAreaBorderSize value must be greater than the cellSize to\n    //have an effect. Radius of the spatial.\n    //Constraints >= 0, default=1.2\n    generator.setTraversableAreaBorderSize(0.6f);\n    //The amount of smoothing to be performed when generating the distance\n    //field used for deriving regions.\n    //Constraints >= 0, default=2\n    generator.setSmoothingThreshold(0);\n    //Applies extra algorithms to help prevent malformed regions from\n    //forming.\n    //Constraints None, default=true\n    generator.setUseConservativeExpansion(true);\n    //The minimum region size for unconnected (island) regions.\n    //Constraints > 0, default=3\n    generator.setMinUnconnectedRegionSize(8);\n    //Any regions smaller than this size will, if possible, be merged with\n    //larger regions.\n    //Constraints >= 0, default=10\n    generator.setMergeRegionSize(20);\n    //The maximum length of polygon edges that represent the border of\n    //meshes.\n    //setTraversableAreaBorderSize * 8\n    //Constraints >= 0, default=0\n    generator.setMaxEdgeLength(4.0f);\n    //The maximum distance the edges of meshes may deviate from the source\n    //geometry.\n    //1.1 to 1.5 for best results.\n    //Constraints >= 0 , default=2.4\n    generator.setEdgeMaxDeviation(1.3f);\n    //The maximum number of vertices per polygon for polygons generated\n    //during the voxel to polygon conversion process.\n    //Constraints >= 3, default=6\n    generator.setMaxVertsPerPoly(6);\n    //Sets the sampling distance to use when matching the detail mesh to the\n    //surface of the original geometry.\n    //Constraints >= 0, default=25\n    generator.setContourSampleDistance(5.0f);\n    //The maximum distance the surface of the detail mesh may deviate from\n    //the surface of the original geometry.\n    //Constraints >= 0, default=25\n    generator.setContourMaxDeviation(5.0f);\n    //Time allowed before generation process times out in miliseconds.\n    //default=10000\n    generator.setTimeout(40000);\n\n    //the data object to use for storing data related to building the\n    //navigation mesh.\n    IntermediateData data = new IntermediateData();\n    generator.setIntermediateData(data);\n\n    Mesh mesh = new Mesh();\n    GeometryBatchFactory.mergeGeometries(findGeometries(app.getRootNode(),\n            new LinkedList<>(), generator), mesh);\n\n    //uncomment to show mesh\n//        Geometry meshGeom = new Geometry("MeshGeometry");\n//        meshGeom.setMesh(mesh);\n//        showGeometry(meshGeom, ColorRGBA.Yellow);\n//        saveNavMesh(meshGeom);\n\n    Mesh optiMesh = generator.optimize(mesh);\n    navMesh.loadFromMesh(optiMesh);\n\n    Geometry geom = new Geometry(DataKey.NAVMESH);\n    geom.setMesh(optiMesh);\n    //display the mesh\n    showGeometry(geom, ColorRGBA.Green);\n    //save the navmesh to Scenes/NavMesh for loading\n    exportNavMesh(geom, DataKey.NAVMESH);\n    //save geom to rootNode if you wish\n    saveNavMesh(geom);\n}\n')),Object(i.b)("p",null,"First, we create the\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/doc-examples/blob/master/src/com/jme3/examples/jme3ai/ai/NavMeshGenerator.java"}),"NavMeshGenerator"),"\nobject and then use it to set the parameters for the NavMesh."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"generator = new NavMeshGenerator();\n...\ngenerator.setCellSize(.25f);\n...\n")),Object(i.b)("p",null,"In our next step we create an IntermediateData object."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"//the data object to use for storing data related to building the\n//navigation mesh.\nIntermediateData data = new IntermediateData();\ngenerator.setIntermediateData(data);\n")),Object(i.b)("p",null,"The IntermediateData object can be used to get information about the\nbuild process of the NavMesh such as build times. You query this object\nafter building the NavMesh. If you don't wish to see the data, set it to\nnull."),Object(i.b)("p",null,"At this point, you now have a ",Object(i.b)("inlineCode",{parentName:"p"},"generator")," object that you use to create\nthe NavMesh with."),Object(i.b)("p",null,"Included in the\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/doc-examples/blob/master/src/com/jme3/examples/jme3ai/ai/NavMeshState.java"}),"NavMeshState.java"),"\nfile is the helper method ",Object(i.b)("inlineCode",{parentName:"p"},"findGeometries"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"//Gathers all geometries in supplied node into supplied List. Uses\n//NavMeshGenerator to merge found Terrain meshes into one geometry prior to\n//adding. Scales and sets translation of merged geometry.\nprivate List<Geometry> findGeometries(Node node, List<Geometry> geoms,\n          NavMeshGenerator generator)\n")),Object(i.b)("p",null,"It is used to collect all geometries, attached to a node, into a List.\nIf a child of the node is a Terrain instance (which can consist of many\nmeshes), it will use the ",Object(i.b)("inlineCode",{parentName:"p"},"generator")," object to merge them into one mesh,\nthen scale and set translation of the merged mesh prior to being added\nto the list. You then use GeometryBatchFactory to merge all the\ngeometries in the list into a single ",Object(i.b)("inlineCode",{parentName:"p"},"mesh")," object."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"Mesh mesh = new Mesh();\nGeometryBatchFactory.mergeGeometries(findGeometries(app.getRootNode(),\n        new LinkedList<>(), generator), mesh);\n")),Object(i.b)("p",null,"After these methods execute, you have a single ",Object(i.b)("inlineCode",{parentName:"p"},"mesh")," object that is now\nready to be optimized."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"Mesh optiMesh = generator.optimize(mesh);\n")),Object(i.b)("p",null,"This is where the parameters you set with the ",Object(i.b)("inlineCode",{parentName:"p"},"generator")," object are\napplied to the supplied ",Object(i.b)("inlineCode",{parentName:"p"},"mesh"),". The optimize method will return a new\nMesh object that reflects your generator settings. Now is when any\nproblems with your parameters will show themselves as either warnings or\nexceptions. You should keep changing the various parameters, one at a\ntime and in small increments/decrements, until your ",Object(i.b)("inlineCode",{parentName:"p"},"mesh")," generates\nwith no errors. See each parameter's notes for suggestions on how to do\nso."),Object(i.b)("p",null,"After the mesh generates, you need to link all of its cells together so\nit can be used as your ",Object(i.b)("inlineCode",{parentName:"p"},"NavMesh")," object. You do this by calling\n",Object(i.b)("inlineCode",{parentName:"p"},"loadFromMesh()")," or ",Object(i.b)("inlineCode",{parentName:"p"},"loadFromData()"),", depending on your implementation,\non your ",Object(i.b)("inlineCode",{parentName:"p"},"optiMesh")," object."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"navMesh.loadFromMesh(optiMesh);\n")),Object(i.b)("p",null,"If you look at the second contructor for the ",Object(i.b)("inlineCode",{parentName:"p"},"NavMesh")," class you will\nsee this is all it does. You would use this constructor if you were\nloading a ",Object(i.b)("inlineCode",{parentName:"p"},"Mesh")," from a geometry that had already been optimized and\nsaved into your ",Object(i.b)("inlineCode",{parentName:"p"},"Assets")," folder for example."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"public NavMesh(Mesh mesh) {\n  loadFromMesh(mesh);\n}\n")),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"NavMesh")," object is now ready for use in your game, but you still\nneed to create the geometry for it if you wish to save or view it. You\ndo this the same as you would for any newly created mesh."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"Geometry geom = new Geometry(DataKey.NAVMESH);\ngeom.setMesh(navMesh);\n")),Object(i.b)("p",null,"Now that you have your Mesh you should save it."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"//save the navmesh to Scenes/NavMesh for loading\nexportNavMesh(geom, DataKey.NAVMESH);\n//save geom to rootNode if you wish\nsaveNavMesh(geom);\n")),Object(i.b)("p",null,"In this instance, the object is exported to the projects ",Object(i.b)("inlineCode",{parentName:"p"},"Assets")," folder\nso it can be loaded rather than generated every time the game starts.\nThis is the preferred method. The ",Object(i.b)("inlineCode",{parentName:"p"},"saveNavMesh()")," method just attaches\nthe geometry to the ",Object(i.b)("inlineCode",{parentName:"p"},"rootNode"),". How and where you choose to save depends\non your implementation and personal preferences."),Object(i.b)("h1",{id:"pathfinding"},"Pathfinding"),Object(i.b)("p",null,"There are many ways to implement the ",Object(i.b)("inlineCode",{parentName:"p"},"NavMeshPathfinder")," class of the\njme3AI library. You can create a control, instantiate the\n",Object(i.b)("inlineCode",{parentName:"p"},"NavMeshPathFinder")," class, and query the newly created object in a\nthread. You could use a single AppState to calculate all your paths. You\ncould, as in this tutorial, extend the NavMeshPathFinder class in a\ncustom control."),Object(i.b)("p",null,"You also need a way to communicate ",Object(i.b)("inlineCode",{parentName:"p"},"Vector3f")," changes to the\n",Object(i.b)("inlineCode",{parentName:"p"},"NavMeshPathfinder"),". This tutorial uses an ActionListener and Interface.\nYou could just as easily create a public method in the control, and call\nit from the ActionListener, or store the ",Object(i.b)("inlineCode",{parentName:"p"},"Vector3f")," in ",Object(i.b)("inlineCode",{parentName:"p"},"UserData")," and\nlook for changes from the control itself."),Object(i.b)("p",null,"These are implementation decisions that are left up to you."),Object(i.b)("h2",{id:"loading-the-navmesh"},"Loading the NavMesh"),Object(i.b)("p",null,"In this tutorial example, the optimized mesh was exported as a geometry\nusing the jMonkey binary format ",Object(i.b)("inlineCode",{parentName:"p"},".j3o"),". Doing so means the loading of\nyour ",Object(i.b)("inlineCode",{parentName:"p"},"NavMeshes")," is done the same way you load any model, by using the\n",Object(i.b)("inlineCode",{parentName:"p"},"AssetManager"),". Once you load the ",Object(i.b)("inlineCode",{parentName:"p"},".j3o"),", you grab its ",Object(i.b)("inlineCode",{parentName:"p"},"Mesh")," and create\nthe ",Object(i.b)("inlineCode",{parentName:"p"},"NavMesh")," object to be passed to the\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/doc-examples/blob/master/src/com/jme3/examples/jme3ai/ai/NavigationControl.java"}),"NavigationControl"),"\nconstructor. This tutorial uses a\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/advanced/application_states.xml#baseappstate#"}),"BaseAppState"),"\nfor model loading so access to the ",Object(i.b)("inlineCode",{parentName:"p"},"Application")," class is built in."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'//load NavMesh geometry saved to assets folder\nGeometry navGeom = (Geometry) getApplication().getAssetManager().\n        loadModel("Scenes/NavMesh/NavMesh.j3o");\nNavigationControl navControl = new NavigationControl(new NavMesh(\n        navGeom.getMesh()), getApplication(), true)\ncharNode.addControl(navControl);\n//NavigationControl implements Pickable Interface\npicked = navControl;\n')),Object(i.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"This tutorial uses a custom control, ",Object(i.b)("inlineCode",{parentName:"p"},"NavigationControl"),", that extends\nthe ",Object(i.b)("inlineCode",{parentName:"p"},"NavMeshPathfinder")," class. As this is a tutorial, some extra\nvariables are used for dispalying the navigation path and are not\nneeded. The constructor for ",Object(i.b)("inlineCode",{parentName:"p"},"NavMeshPathfinder")," requires just the the\npassing of the ",Object(i.b)("inlineCode",{parentName:"p"},"NavMesh")," object, which makes for a cleaner control."),Object(i.b)("pre",{parentName:"div"},Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"public NavigationControl(NavMesh navMesh) {\n  ...\n}\n")))),Object(i.b)("h2",{id:"communicating-with-navigationcontrol"},"Communicating with NavigationControl"),Object(i.b)("p",null,"This tutorial makes use of the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/beginner/hello_picking"}),"Hello\nPicking")," and ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/advanced/mouse_picking.xml#pick-a-target-using-the-mouse-pointer#"}),"Mouse\nPicking"),"\ntutorials so you should already be familiar with this method for picking\nand how to add the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/beginner/hello_input_system"}),"input\nmappings")," to your game. How\nyou implement your ActionListener is up to you."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"PCState ActionListener.")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'    private class ClickedListener implements ActionListener {\n\n        @Override\n        public void onAction(String name, boolean isPressed, float tpf) {\n\n            if (name.equals(ListenerKey.PICK) && !isPressed) {\n                CollisionResults results = new CollisionResults();\n                Vector2f click2d = getInputManager().getCursorPosition().clone();\n                Vector3f click3d = app.getCamera().getWorldCoordinates(click2d,\n                        0f).clone();\n                Vector3f dir = app.getCamera().getWorldCoordinates(\n                        click2d, 1f).subtractLocal(click3d).normalizeLocal();\n                Ray ray = new Ray(click3d, dir);\n                app.getRootNode().collideWith(ray, results);\n\n                for (int i = 0; i < results.size(); i++) {\n                    // For each hit, we know distance, impact point, name of geometry.\n                    float dist = results.getCollision(i).getDistance();\n                    Vector3f pt = results.getCollision(i).getContactPoint();\n                    String hit = results.getCollision(i).getGeometry().getName();\n                    System.out.println("* Collision #" + i);\n                    System.out.println(\n                            "  You shot " + hit\n                            + " at " + pt\n                            + ", " + dist + " wu away.");\n                }\n\n                if (results.size() > 0) {\n                    // The closest collision point is what was truly hit:\n                    CollisionResult closest = results.getClosestCollision();\n                    // Let\'s interact - we mark the hit with a red dot.\n                    mark.setLocalTranslation(closest.getContactPoint());\n                    app.getRootNode().attachChild(mark);\n                    picked.setTarget(closest.getContactPoint());\n                    System.out.println("  Closest Contact " + closest.\n                            getContactPoint());\n                } else {\n                    // No hits? Then remove the red mark.\n                    app.getRootNode().detachChild(mark);\n                }\n            }\n        }\n    }\n')),Object(i.b)("p",null,"The main line of interest here is,"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"picked.setTarget(closest.getContactPoint());\n")),Object(i.b)("p",null,"where ",Object(i.b)("inlineCode",{parentName:"p"},"picked")," is the reference object used to communicate our\n",Object(i.b)("inlineCode",{parentName:"p"},"Vector3f")," changes to the ",Object(i.b)("inlineCode",{parentName:"p"},"NavigationControl"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"//NavigationControl implements Pickable Interface\npicked = navControl;\n")),Object(i.b)("p",null,"At this point you have loaded your ",Object(i.b)("inlineCode",{parentName:"p"},"NavMesh"),", added the\n",Object(i.b)("inlineCode",{parentName:"p"},"NavigationControl")," to your spatial, and instituted a method for\ncommunicating with the ",Object(i.b)("inlineCode",{parentName:"p"},"NavMeshPathFinder"),". Next we will delve into the\ndetails of the ",Object(i.b)("inlineCode",{parentName:"p"},"NavigationControl"),"."),Object(i.b)("h2",{id:"navigationcontrol"},"NavigationControl"),Object(i.b)("p",null,"The\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/doc-examples/blob/master/src/com/jme3/examples/jme3ai/ai/NavigationControl.java"}),"NavigationControl"),"\nis a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/advanced/custom_controls"}),"custom control")," that\nextends the\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/MeFisto94/jme3-artificial-intelligence/blob/master/AI/src/com/jme3/ai/navmesh/NavMeshPathfinder.java"}),"NavMeshPathFinder"),"\nclass of the Jme3AI library and implements the ",Object(i.b)("inlineCode",{parentName:"p"},"Pickable")," interface."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"public class NavigationControl extends NavMeshPathfinder implements Control,\n        JmeCloneable, Pickable {\n}\n")),Object(i.b)("p",null,"The\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/doc-examples/blob/master/src/com/jme3/examples/jme3ai/interfaces/Pickable.java"}),"Pickable"),"\ninterface is straightforward and its sole purpose in this implementation\nis to communicate changes made to the pick target."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Pickable Interface implementation.")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"/**\n * @param target the target to set\n */\n@Override\npublic void setTarget(Vector3f target) {\n    this.target = target;\n}\n")),Object(i.b)("p",null,"The heartbeat of the control lies in the pathfinding thread which makes\ncalls to the ",Object(i.b)("inlineCode",{parentName:"p"},"computePath()")," method. Potentially long running tasks like\nthis should always be ran from a thread. Below, is the constructor you\nwould normally use to instantiate your control."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"public NavigationControl(NavMesh navMesh) {\n    super(navMesh); //sets the NavMesh for this control\n    executor = Executors.newScheduledThreadPool(1);\n    startPathFinder();\n}\n")),Object(i.b)("p",null,"First, you call ",Object(i.b)("inlineCode",{parentName:"p"},"super(navMesh)")," to set the ",Object(i.b)("inlineCode",{parentName:"p"},"NavMesh")," for the control,\nthen setup your ",Object(i.b)("inlineCode",{parentName:"p"},"ExecutorService")," and start the pathfinding thread."),Object(i.b)("p",null,"This is a custom thread implementation so it's up to you to handle\nshutting it down. This is done in the controls ",Object(i.b)("inlineCode",{parentName:"p"},"setSpatial()")," method."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"if (spatial == null) {\n    shutdownAndAwaitTermination(executor);\n    ...\n} else {\n    ...\n}\n")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Executor shutdown process.")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'//standard shutdown process for executor\nprivate void shutdownAndAwaitTermination(ExecutorService pool) {\n    pool.shutdown(); // Disable new tasks from being submitted\n    try {\n        // Wait a while for existing tasks to terminate\n        if (!pool.awaitTermination(6, TimeUnit.SECONDS)) {\n            pool.shutdownNow(); // Cancel currently executing tasks\n            // Wait a while for tasks to respond to being cancelled\n            if (!pool.awaitTermination(6, TimeUnit.SECONDS)) {\n                LOG.log(Level.SEVERE, "Pool did not terminate {0}", pool);\n            }\n        }\n    } catch (InterruptedException ie) {\n        // (Re-)Cancel if current thread also interrupted\n        pool.shutdownNow();\n        // Preserve interrupt status\n        Thread.currentThread().interrupt();\n    }\n}\n')),Object(i.b)("p",null,"The easiest way to move a physics character is by using the\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/advanced/walking_character.xml#bettercharactercontrol#"}),"BetterCharacterControl"),"\nclass. In this implementation, this is done in the\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/doc-examples/blob/master/src/com/jme3/examples/jme3ai/controls/PCControl.java"}),"PCControl"),"\nclass by extending ",Object(i.b)("inlineCode",{parentName:"p"},"BetterCharacterControl"),". Since\n",Object(i.b)("inlineCode",{parentName:"p"},"BetterCharacterControl")," is required to be present on the spatial for\npathfinding, in the ",Object(i.b)("inlineCode",{parentName:"p"},"setSpatial()")," method, we throw an exception to let\nus know if it's missing."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'if (spatial == null) {\n    ...\n} else {\n    pcControl = spatial.getControl(PCControl.class);\n    if (pcControl == null) {\n        throw new IllegalStateException(\n                "Cannot add NavigationControl to spatial without PCControl!");\n    }\n}\n')),Object(i.b)("h2",{id:"pathfinding-thread"},"Pathfinding Thread"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"NavigationControl pathfinding thread.")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'//Computes a path using the A* algorithm. Every 1/2 second checks target\n//for processing. Path will remain untill a new path is generated.\nprivate void startPathFinder() {\n    executor.scheduleWithFixedDelay(() -> {\n        if (target != null) {\n            clearPath();\n            setWayPosition(null);\n            pathfinding = true;\n            //setPosition must be set before computePath is called.\n            setPosition(spatial.getWorldTranslation());\n            //warpInside(target) moves endpoint within the navMesh always.\n            warpInside(target);\n            System.out.println("Target " + target);\n            boolean success;\n            //comput the path\n            success = computePath(target);\n            System.out.println("SUCCESS = " + success);\n            if (success) {\n                //clear target if successful\n                target = null;\n                ...\n            }\n            pathfinding = false;\n        }\n    }, 0, 500, TimeUnit.MILLISECONDS);\n}\n')),Object(i.b)("p",null,"How you setup your pathfinding thread makes a significant difference."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"executor.scheduleWithFixedDelay(() -> {\n...\n}, 0, 500, TimeUnit.MILLISECONDS);\n")),Object(i.b)("p",null,"This ",Object(i.b)("inlineCode",{parentName:"p"},"ExecutorService")," is set to start immediately (0) with a fixed\ndelay of (500) milliseconds. This means the task has a fixed delay of\n1/2 second between the end of an execution and the start of the next\nexecution, i.e. it doesn't take into account the actual duration of the\ntask. If you were to use ",Object(i.b)("inlineCode",{parentName:"p"},"scheduleAtFixedRate()"),", you risk that the task\ndoesn't complete in the time allocated."),Object(i.b)("p",null,"When you use the ",Object(i.b)("inlineCode",{parentName:"p"},"BetterCharacterControl"),", all that's required to move\nthe spatial is that you ",Object(i.b)("inlineCode",{parentName:"p"},"setWalkDirection()")," and the spatial will\ncontinuously move in that direction. The following code breakdown\nexplains how the ",Object(i.b)("inlineCode",{parentName:"p"},"NavigationControl")," takes advantage of this."),Object(i.b)("p",null,"It starts by having the pathfinding thread check a ",Object(i.b)("inlineCode",{parentName:"p"},"target")," variable for\nchanges."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"if (target != null) {\n    ...\n}\n")),Object(i.b)("p",null,"If it finds a target, it will compute a new path to that ",Object(i.b)("inlineCode",{parentName:"p"},"target"),", and\nif successful, update the ",Object(i.b)("inlineCode",{parentName:"p"},"NavMeshPathfinder")," path variable. The\n",Object(i.b)("inlineCode",{parentName:"p"},"update()")," loop of the control continuously checks this path variable,\nand if its non-null, takes an appropriate action."),Object(i.b)("p",null,"Before you compute the path you first clear the existing path, and set\nwayPosition to null."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"if (target != null) {\n    clearPath();\n    setWayPosition(null);\n    pathfinding = true;\n    ...\n}\n")),Object(i.b)("p",null,"Doing this allows the player to select a new ",Object(i.b)("inlineCode",{parentName:"p"},"target")," at any time and\nimmediately start moving along the new path. Otherwise, the character\nmust finish the path they are on, then backtrack to the position the\ncharacter was at when the ",Object(i.b)("inlineCode",{parentName:"p"},"target")," change was made, before then\ncontinuing on the new path."),Object(i.b)("p",null,"Next, you must call ",Object(i.b)("inlineCode",{parentName:"p"},"setPosition()")," ",Object(i.b)("strong",{parentName:"p"},"before")," calling the\n",Object(i.b)("inlineCode",{parentName:"p"},"computePath()")," method."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"if (target != null) {\n  ...\n  setPosition(spatial.getWorldTranslation());\n  ...\n  //compute the path\n  success = computePath(target);\n  ...\n}\n")),Object(i.b)("p",null,"There are some things you need to know about how a path is computed."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"The first waypoint on any path is the one you set with\n",Object(i.b)("inlineCode",{parentName:"p"},"setPosition()"),".")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"The last waypoint on any path is always the ",Object(i.b)("inlineCode",{parentName:"p"},"target")," Vector3f.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"computePath() adds one waypoint to the cell ",Object(i.b)("strong",{parentName:"p"},"nearest")," to the\ntarget only if you are not in the goalCell (the cell target is in),\nand if there is a cell between first and last waypoint, and if there\nis no direct line of sight.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"If inside the goalCell when a new target is selected, computePath()\nwill do a direct line of sight placement of target. This means there\nwill only be two waypoints set, ",Object(i.b)("inlineCode",{parentName:"p"},"setPosition()")," and ",Object(i.b)("inlineCode",{parentName:"p"},"target"),".")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"If the ",Object(i.b)("inlineCode",{parentName:"p"},"target")," is outside the ",Object(i.b)("inlineCode",{parentName:"p"},"NavMesh"),", your endpoint will be as\nwell."))),Object(i.b)("p",null,"To guarantee that ",Object(i.b)("inlineCode",{parentName:"p"},"target")," is always inside the ",Object(i.b)("inlineCode",{parentName:"p"},"NavMesh"),", call"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"if (target != null) {\n    ...\n    //warpInside(target) moves endpoint within the navMesh always.\n    warpInside(target);\n    ...\n    //compute the path\n    success = computePath(target);\n    ...\n}\n")),Object(i.b)("p",null,"before calling ",Object(i.b)("inlineCode",{parentName:"p"},"computePath()")," and the endpoint of the path will be\nmoved to the closest cell to the ",Object(i.b)("inlineCode",{parentName:"p"},"target")," that's inside the ",Object(i.b)("inlineCode",{parentName:"p"},"NavMesh"),"."),Object(i.b)("h1",{id:"character-movement"},"Character Movement"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"NavigationControl update() loop.")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"@Override\npublic void update(float tpf) {\n    if (getWayPosition() != null) {\n        Vector3f spatialPosition = spatial.getWorldTranslation();\n        Vector2f aiPosition = new Vector2f(spatialPosition.x,\n                spatialPosition.z);\n        Vector2f waypoint2D = new Vector2f(getWayPosition().x,\n                getWayPosition().z);\n        float distance = aiPosition.distance(waypoint2D);\n        //move char between waypoints untill waypoint reached then set null\n        if (distance > .25f) {\n            Vector2f direction = waypoint2D.subtract(aiPosition);\n            direction.mult(tpf);\n            pcControl.setViewDirection(new Vector3f(direction.x, 0,\n                    direction.y).normalize());\n            pcControl.onAction(ListenerKey.MOVE_FORWARD, true, 1);\n        } else {\n            setWayPosition(null);\n        }\n    } else if (!isPathfinding() && getNextWaypoint() != null\n            && !isAtGoalWaypoint()) {\n        if (showPath) {\n            showPath();\n            showPath = false;\n        }\n        //advance to next waypoint\n        goToNextWaypoint();\n        setWayPosition(new Vector3f(getWaypointPosition()));\n\n        //set spatial physical position\n        if (getPositionType() == EnumPosition.POS_STANDING.position()) {\n            setPositionType(EnumPosition.POS_RUNNING.position());\n            stopFeetPlaying();\n            stopTorsoPlaying();\n        }\n    } else {\n        //waypoint null so stop moving and set spatials physical position\n        if (getPositionType() == EnumPosition.POS_RUNNING.position()) {\n            setPositionType(EnumPosition.POS_STANDING.position());\n            stopFeetPlaying();\n            stopTorsoPlaying();\n        }\n        pcControl.onAction(ListenerKey.MOVE_FORWARD, false, 1);\n    }\n}\n")),Object(i.b)("p",null,"If the ",Object(i.b)("inlineCode",{parentName:"p"},"computePath()")," successfully computes a new path, the path\nvariable of the ",Object(i.b)("inlineCode",{parentName:"p"},"NavMeshPathfinder")," will no longer be null. The update\nloop of the ",Object(i.b)("inlineCode",{parentName:"p"},"NavigationControl")," checks this path variable, every\niteration that wayPosition is null, by calling the ",Object(i.b)("inlineCode",{parentName:"p"},"getNextWaypoint()"),"\nmethod. If the path has another waypoint, it will advance to the next\nposition in the path and set the ",Object(i.b)("inlineCode",{parentName:"p"},"wayPosition")," variable of the\n",Object(i.b)("inlineCode",{parentName:"p"},"NavigationControl")," to that position."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"} else if (!isPathfinding() && getNextWaypoint() != null\n        && !isAtGoalWaypoint()) {\n    ...\n    //advance to next waypoint\n    goToNextWaypoint();\n    setWayPosition(new Vector3f(getWaypointPosition()));\n    ...\n}\n")),Object(i.b)("p",null,"::: {.important}\nRemember, the first waypoint in the path is always the spatials current\nposition. This is why you always advance the position first.\n:::"),Object(i.b)("p",null,"On the next iteration of the controls ",Object(i.b)("inlineCode",{parentName:"p"},"update()")," method, it sees that\n",Object(i.b)("inlineCode",{parentName:"p"},"wayPosition")," is no longer null and calculates the distance from the\nspatials current position to the ",Object(i.b)("inlineCode",{parentName:"p"},"wayPosition"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"if (getWayPosition() != null) {\n    Vector3f spatialPosition = spatial.getWorldTranslation();\n    Vector2f aiPosition = new Vector2f(spatialPosition.x,\n            spatialPosition.z);\n    Vector2f waypoint2D = new Vector2f(getWayPosition().x,\n            getWayPosition().z);\n    float distance = aiPosition.distance(waypoint2D);\n    ...\n}\n")),Object(i.b)("p",null,"If it's greater than the distance specified, it will\n",Object(i.b)("inlineCode",{parentName:"p"},"setViewDirection()")," of the ",Object(i.b)("inlineCode",{parentName:"p"},"PCControl")," (which extends\nBetterCharacterControl) and then notify the ",Object(i.b)("inlineCode",{parentName:"p"},"PCControl")," that the spatial\ncan move by calling the controls ",Object(i.b)("inlineCode",{parentName:"p"},"onAction()")," method directly."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"if (getWayPosition() != null) {\n    ...\n    //move char between waypoints untill waypoint reached then set null\n    if (distance > .25f) {\n        Vector2f direction = waypoint2D.subtract(aiPosition);\n        direction.mult(tpf);\n        pcControl.setViewDirection(new Vector3f(direction.x, 0,\n                direction.y).normalize());\n        pcControl.onAction(ListenerKey.MOVE_FORWARD, true, 1);\n    } else {\n        ...\n    }\n}\n")),Object(i.b)("p",null,"It's up to the ",Object(i.b)("inlineCode",{parentName:"p"},"NavigationControl")," to determine when the character\nshould stop moving. Each time the spatial reaches a point that is less\nthan the specified distance, it sets the wayPosition to null."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"if (distance > .25f) {\n    ...\n} else {\n    setWayPosition(null);\n}\n")),Object(i.b)("p",null,"If the path position has not yet reached the end, it will once again be\nadvance to the next waypoint in the path and update the wayPosition."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"} else if (!isPathfinding() && getNextWaypoint() != null\n        && !isAtGoalWaypoint()) {\n    ...\n    //advance to next waypoint\n    goToNextWaypoint();\n    setWayPosition(new Vector3f(getWaypointPosition()));\n    ...\n}\n")),Object(i.b)("p",null,"When the last waypoint is reached, the ",Object(i.b)("inlineCode",{parentName:"p"},"NavigationControl")," notifies the\n",Object(i.b)("inlineCode",{parentName:"p"},"PCControl")," that the spatial can no longer move."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"} else {\n    ...\n    pcControl.onAction(ListenerKey.MOVE_FORWARD, false, 1);\n}\n")),Object(i.b)("p",null,"The\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/doc-examples/blob/master/src/com/jme3/examples/jme3ai/controls/PCControl.java"}),"PCControl"),"\nclass handles the actual movement of the spatial in its ",Object(i.b)("inlineCode",{parentName:"p"},"update()")," loop.\nIt does this by checking the ",Object(i.b)("inlineCode",{parentName:"p"},"forward")," variable every iteration. This\nvariable is set when you call the ",Object(i.b)("inlineCode",{parentName:"p"},"onAction()")," method from the\n",Object(i.b)("inlineCode",{parentName:"p"},"NavigationControl")," update loop."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"PCControl ActionListener.")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"@Override\npublic void onAction(String name, boolean isPressed, float tpf) {\n    if (name.equals(ListenerKey.MOVE_FORWARD)) {\n        forward = isPressed;\n    }\n}\n")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"PCControl update() loop.")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"@Override\npublic void update(float tpf) {\n    super.update(tpf);\n    this.moveSpeed = 0;\n    walkDirection.set(0, 0, 0);\n    if (forward) {\n        Vector3f modelForwardDir = spatial.getWorldRotation().mult(Vector3f.UNIT_Z);\n        position = getPositionType();\n        for (EnumPosition pos : EnumPosition.values()) {\n            if (pos.position() == position) {\n                switch (pos) {\n                    case POS_RUNNING:\n                        moveSpeed = EnumPosition.POS_RUNNING.speed();\n                        break;\n                    default:\n                        moveSpeed = 0f;\n                        break;\n                }\n            }\n        }\n        walkDirection.addLocal(modelForwardDir.mult(moveSpeed));\n    }\n    setWalkDirection(walkDirection);\n}\n")),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"PCControl")," will then set the walk direction, based off spatials\nworld rotation, and set the speed."),Object(i.b)("h1",{id:"conclusion"},"Conclusion"),Object(i.b)("p",null,"The intent of this tutorial was to give you a general breakdown of how\nthe Jme3AI navigation system works as well as demonstrate how flexible\nits implementation is. All the code in this tutorial is free for your\nuse and can be found in the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/doc-examples"}),"jme3 documentation\nrepository"),". The\nimplementations design is such that you can easily change each of the\nparameters and then visually see how they affect the NavMesh. If you\nhave questions or suggestions on improving this tutorial you can do so\nin the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://hub.jmonkeyengine.org/"}),"jMonkeyEngine forum"),"."),Object(i.b)("h1",{id:"other-ai-options"},"Other AI Options"),Object(i.b)("p",null,"There are other jME3 specific options available you can read about in\nthe wiki under the topic ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://wiki.jmonkeyengine.org/jme3.html#artificial-intelligence-ai"}),"Artificial Intelligence\n(AI)"),"."),Object(i.b)("h1",{id:"further-reading"},"Further Reading"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"http://www.policyalmanac.org/games/aStarTutorial.htm"}),"A","*"," path-finding for\nBeginners")," by\nPatrick Lester")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"http://natureofcode.com/book/"}),"The Nature of Code")," by Daniel\nShiffman")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"http://www.red3d.com/cwr/steer/gdc99/"}),"Steering Behaviors For Autonomous\nCharacters")," by Craig W.\nReynolds")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"http://www.critterai.org/projects/nmgen_study/"}),"Study: Navigation Mesh Generation\nJava")," by Stephen\nPratt"))),Object(i.b)("div",{className:"footnotes"},Object(i.b)("hr",{parentName:"div"}),Object(i.b)("ol",{parentName:"div"},Object(i.b)("li",Object(a.a)({parentName:"ol"},{id:"fn-1"}),"Path-finding means computing the shortest route between two\npoints. Usually mazes.",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#fnref-1",className:"footnote-backref"}),"\u21a9")),Object(i.b)("li",Object(a.a)({parentName:"ol"},{id:"fn-2"}),"Path-following is taking a path that already exists and then\nfollowing that path.",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#fnref-2",className:"footnote-backref"}),"\u21a9")))))}p.isMDXComponent=!0},441:function(e,t,n){"use strict";n.d(t,"a",(function(){return h})),n.d(t,"b",(function(){return d}));var a=n(0),o=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=o.a.createContext({}),p=function(e){var t=o.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s({},t,{},e)),n},h=function(e){var t=p(e.components);return o.a.createElement(c.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},m=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,r=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=p(n),m=a,d=h["".concat(r,".").concat(m)]||h[m]||b[m]||i;return n?o.a.createElement(d,s({ref:t},c,{components:n})):o.a.createElement(d,s({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return o.a.createElement.apply(null,r)}return o.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);