(window.webpackJsonp=window.webpackJsonp||[]).push([[208],{347:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return o})),a.d(t,"metadata",(function(){return l})),a.d(t,"rightToc",(function(){return s})),a.d(t,"default",(function(){return p}));var n=a(1),r=a(9),i=(a(0),a(441)),o={},l={id:"jme3/terminology",title:"terminology",description:"Before you start, make certain you are familiar with the following",source:"@site/docs/jme3/terminology.md",permalink:"/wikidemo/docs/jme3/terminology",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/terminology.md",sidebar:"main",previous:{title:"hellovector",permalink:"/wikidemo/docs/jme3/beginner/hellovector"},next:{title:"how_to_use_materials",permalink:"/wikidemo/docs/jme3/intermediate/how_to_use_materials"}},s=[{value:"Polygon, Mesh, Vertex",id:"polygon-mesh-vertex",children:[]},{value:"Color",id:"color",children:[{value:"Ambient color",id:"ambient-color",children:[]},{value:"Diffuse color",id:"diffuse-color",children:[]}]},{value:"Light Sources",id:"light-sources",children:[{value:"Emissive color",id:"emissive-color",children:[]}]},{value:"Reflections",id:"reflections",children:[{value:"Shininess",id:"shininess",children:[]},{value:"Specular Color",id:"specular-color",children:[]}]},{value:"Texture Mapping",id:"texture-mapping",children:[]},{value:"Environment Mapping",id:"environment-mapping",children:[]},{value:"MIP Map Texture",id:"mip-map-texture",children:[]},{value:"Procedural Textures",id:"procedural-textures",children:[]},{value:"Physically Based Rendering Textures (PBR)",id:"physically-based-rendering-textures-pbr",children:[]},{value:"Rigging and Skinning",id:"rigging-and-skinning",children:[]},{value:"Kinematics",id:"kinematics",children:[]},{value:"Controller and Channel",id:"controller-and-channel",children:[]},{value:"Coordinates",id:"coordinates",children:[{value:"The Origin",id:"the-origin",children:[]}]},{value:"Vectors",id:"vectors",children:[{value:"Unit Vectors",id:"unit-vectors",children:[]},{value:"Normalized Vectors",id:"normalized-vectors",children:[]},{value:"Surface Normal Vectors",id:"surface-normal-vectors",children:[]},{value:"Cross Product",id:"cross-product",children:[]},{value:"Transformation",id:"transformation",children:[]},{value:"Slerp",id:"slerp",children:[]}]}],c={rightToc:s};function p(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(n.a)({},c,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Before you start, make certain you are familiar with the following\nconcepts and terminology."),Object(i.b)("h1",{id:"3d-graphics-and-audio"},"3D Graphics and Audio"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"OpenGL")," is the Open Graphics Library, a platform-independent\nspecification for rendering 2D/3D computer graphics. For Java, there are\ntwo implementations of OpenGL-based renderers:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"Lightweight Java Game Library (LWJGL).")),Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"Java OpenGL (JOGL)"))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"OpenAL")," is the Open Audio Library, a platform-independent 3D audio\nAPI."),Object(i.b)("h1",{id:"context-display-renderer"},"Context, Display, Renderer"),Object(i.b)("p",null,"The ",Object(i.b)("strong",{parentName:"p"},"jME Context")," makes settings, renderer, timer, input and event\nlisteners, display system, accessible to a JME game."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"The ",Object(i.b)("strong",{parentName:"p"},"jME Display System")," is what draws the custom JME window\n(instead of Java Swing).")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"The ",Object(i.b)("strong",{parentName:"p"},"Input System")," is the component that lets you respond to user\ninput: Mouse clicks and movements, keyboard presses, and joystick\nmotions.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"The ",Object(i.b)("strong",{parentName:"p"},"Renderer")," is what does all the work of calculating how to\ndraw the 3D scenegraph to the 2D screen."),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"The ",Object(i.b)("strong",{parentName:"li"},"Shader")," is a programmable part of the rendering pipeline.\nThe jME3 game engine uses it to offer advanced customizable\nmaterials.")))),Object(i.b)("h1",{id:"geometry"},"Geometry"),Object(i.b)("h2",{id:"polygon-mesh-vertex"},"Polygon, Mesh, Vertex"),Object(i.b)("p",null,Object(i.b)("img",Object(n.a)({parentName:"p"},{src:"../jme3/dolphin-mesh.png",alt:"Models (here a dolphin) are made up of polygon\nmeshes"}))),Object(i.b)("p",null,"Most visible objects in a 3D scene are made up of polygon meshes --\ncharacters, terrains, buildings, etc. A mesh is a grid-like structure\nthat represents a complex shape. The advantage of a mesh is that it is\nmathematically simple enough to render in real time, and detailed enough\nto be recognizable."),Object(i.b)("p",null,"Every shape is reduced to a number of connected polygons, usually\ntriangles; even round surfaces such as spheres are reduced to a grid of\ntriangles. The polygons\\' corner points are called vertices. Every\nvertex is positioned at a coordinate, all vertices together describe the\noutline of the shape."),Object(i.b)("p",null,"You create 3D meshes in tools called mesh editors, e.g in Blender. The\njMonkeyEngine can load finished meshes (=models) and arrange them to\nscenes, but it cannot edit the mesh itself."),Object(i.b)("h1",{id:"materials-color-lightingshading"},"Materials: Color, Lighting/Shading"),Object(i.b)("p",null,"What we call \"color\" is merely part of an object's light reflection. The\nonlooker's brain uses shading and reflecting properties to infer an\nobject's shape and material. Factors like these make all the difference\nbetween chalk vs milk, skin vs paper, water vs plastic, etc!"),Object(i.b)("h2",{id:"color"},"Color"),Object(i.b)("h3",{id:"ambient-color"},"Ambient color"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"The uniform base color of the mesh -- what it looks like when not\ninfluenced by any light source.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Usually similar to the Diffuse color.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"This is the minimum color you need for an object to be visible."))),Object(i.b)("h3",{id:"diffuse-color"},"Diffuse color"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"The base color of the mesh plus shattered light and shadows that are\ncaused by a light source.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Usually similar to the Ambient color."))),Object(i.b)("h2",{id:"light-sources"},"Light Sources"),Object(i.b)("h3",{id:"emissive-color"},"Emissive color"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"The color of light emitted by a light source or glowing material.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Only glowing materials such as lights have an emissive color, normal\nobjects don't have this property.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Often white (sun light)."))),Object(i.b)("h2",{id:"reflections"},"Reflections"),Object(i.b)("h3",{id:"shininess"},"Shininess"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Degree of shininess of a surface (1-128).")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Shiny objects have small, clearly outlined specular highlights.\n(E.g. glass, water, silver)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Normal objects have wide, blurry specular highlights. (E.g. metal,\nplastic, stone, polished materials)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Uneven objects are not shiny and have no specular highlights. (E.g.\ncloth, paper, wood, snow)\\\nSet the Specular color to ColorRGBA.Black to switch off shininess."))),Object(i.b)("h3",{id:"specular-color"},"Specular Color"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"If the material is shiny, then the Specular Color is the color of\nthe reflected highlights.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Usually the same as the emissive color of the light source (e.g.\nwhite).")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"You can use colors to achieve special specular effects, such as\nmetallic or iridescent reflections.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Non-shiny objects have a black specular color."))),Object(i.b)("p",null,Object(i.b)("img",Object(n.a)({parentName:"p"},{src:"../jme3/tanlglow2.png",alt:"tanlglow2.png"}))),Object(i.b)("h1",{id:"materials-textures"},"Materials: Textures"),Object(i.b)("p",null,"Textures are part of Materials. In the simplest case, an object could\nhave just one texture, the Color Map, loaded from one image file. When\nyou think back of old computer games you'll remember this looks quite\nplain."),Object(i.b)("p",null,'The more information you (the game designer) provide additionally to the\nColor Map, the higher the degree of detail and realism. Whether you want\nphoto-realistic rendering or "toon" rendering (Cel Shading), everything\ndepends on the quality of your materials and textures. Modern 3D\ngraphics use several layers of information to describe one material,\neach mapped layer is a texture.'),Object(i.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"Got no textures? ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"http://opengameart.org"}),"Download free textures from\nopengameart.org"),". Remember to keep the copyright\nnotice together with the textures!"))),Object(i.b)("h2",{id:"texture-mapping"},"Texture Mapping"),Object(i.b)("p",null,Object(i.b)("img",Object(n.a)({parentName:"p"},{src:"https://raw.githubusercontent.com/jMonkeyEngine/jmonkeyengine/master/jme3-testdata/src/main/resources/Models/HoverTank/tank_diffuse.jpg",alt:"tank_diffuse.jpg"}))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Color Map / Diffuse Map")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"A plain image file or a procedural texture that describes an\nobject's visible surface.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"The image can have alpha channels for transparency.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"A Color Map is the minimum texture.")," You can map more\ntextures as optional improvements.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Color Maps are unshaded. The same is called Diffuse Map in a\nPhong-illuminated material, because this texture defines the\nbasic colors of light that are ",Object(i.b)("em",{parentName:"p"},"diffused")," by this object.")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Bump Map")),Object(i.b)("p",{parentName:"li"},"Bump maps are used to describe detailed shapes that would be too\nhard or simply too inefficient to sculpt in a mesh editor."),Object(i.b)("p",{parentName:"li"},"There are two types:"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"You use Normal Maps to model tiny details such as cracks in\nwalls, rust, skin texture, or a canvas weave ( (",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"http://en.wikipedia.org/wiki/Bump_mapping"}),"More on\nBumpMaps"),").")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"You use Height Maps to model large terrains with valleys and\nmountains."))),Object(i.b)("p",{parentName:"li"},Object(i.b)("img",Object(n.a)({parentName:"p"},{src:"../jme3/beginner/mountains512.png",alt:"mountains512.png"})))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Height Map")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"A height map is a grayscale image looking similar to a terrain\nmap used in topography. Brighter grays represent higher areas\nand darker grays lower areas.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"A heightmap can represent 256 height levels and is mostly used\nto roughly outline terrains.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"You can draw a heightmap by hand in any image editor."))))),Object(i.b)("p",null,Object(i.b)("img",Object(n.a)({parentName:"p"},{src:"https://raw.githubusercontent.com/jMonkeyEngine/jmonkeyengine/master/jme3-testdata/src/main/resources/Models/HoverTank/tank_normals.png",alt:"tank_normals.png"}))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Normal Map")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"A well-done Normal Map makes a shape more detailed -- without\nthe need to add costly polygons to the mesh. It contains shading\ninformation that makes the object appear smoother and more\nfine-grained.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"When you open a Normal Map in an image editor, it looks like a\nfalse-color version of the Color Map. Normal maps however are\nnever used for coloring, instead, each the color values encode\ndisplacement data of bumps and cracks on the surface.\nDisplacement data is represented by the Surface Normals of the\nslopes, hence the name.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"You cannot draw or edit normal maps by hand, professional\ndesigners use software to calculate them off high-quality 3D\nmodels. You can either buy a professional texture set, or find\nfree collections that include Normal Maps."))))),Object(i.b)("p",null,Object(i.b)("img",Object(n.a)({parentName:"p"},{src:"https://raw.githubusercontent.com/jMonkeyEngine/jmonkeyengine/master/jme3-testdata/src/main/resources/Models/HoverTank/tank_specular.jpg",alt:"tank_specular.jpg"}))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Specular Map")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"A Specular Map further improves the realism of an object's\nsurface: It contains extra information about shininess and makes\nthe shape appear more realistically illumated.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Start out with a copy of the Diffuse Map in a medium gray that\ncorresponds to the average shininess/dullness of this material.\nThen add ligher grays for smoother, shinier, more reflective\nareas; and darker grays for duller, rougher, worn-out areas. The\nresulting image file looks similar to a grayscale version of the\nDiffuse Map.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"You can use colors in a Specular map to create certain\nreflective effects (fake iridiscence, metallic effect)."))))),Object(i.b)("p",null,Object(i.b)("img",Object(n.a)({parentName:"p"},{src:"https://raw.githubusercontent.com/jMonkeyEngine/jmonkeyengine/master/jme3-testdata/src/main/resources/Textures/Terrain/BrickWall/BrickWall.jpg",alt:"BrickWall.jpg"}))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Seamless Tiled Textures")),Object(i.b)("p",{parentName:"li"},"Tiles are a very simple, commonly used type of texture. When\ntexturing a wide area (e.g. walls, floors), you don't create one\nhuge texture -- instead you tile a small texture repeatedly to fill\nthe area."),Object(i.b)("p",{parentName:"li"},"A seamless texture is an image file that has been designed or\nmodified so that it can be used as tiles: The right edge matches the\nleft edge, and the top edge matches the bottom edge. The onlooker\ncannot easily tell where one starts and the next one ends, thus\ncreating an illusion of a huge texture. The downside is that the\ntiling becomes painfully obvious when the area is viewed from a\ndistance. Also you cannot use it on more complex models such as\ncharacters."),Object(i.b)("p",{parentName:"li"},"See also this tutorial on ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"http://www.photoshoptextures.com/texture-tutorials/seamless-textures.htm"}),"How to make seamless textures in\nPhotoshop"),"."))),Object(i.b)("p",null,Object(i.b)("img",Object(n.a)({parentName:"p"},{src:"https://raw.githubusercontent.com/jMonkeyEngine/jmonkeyengine/master/jme3-testdata/src/main/resources/Models/Ferrari/Car.jpg",alt:"Car.jpg"}))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"UV Maps / Texture Atlas")),Object(i.b)("p",{parentName:"li"},"Creating a texture for a cube is easy -- but what about a character\nwith a face and extremities? For more complex objects, you design\nthe texture in the same ways as a flat sewing pattern: One image\nfile contains the outline of the front, back, and side of the\nobject, next to one another. Specific areas of the flat texture (UV\ncoordinates) map onto certain areas of your 3D model (XYZ\ncoordinates), hence the name UV map. Using UV Maps (also known as\nTexture Atlas), one model can have different textures on each side.\nYou create one corresponding UV map for each texture."),Object(i.b)("p",{parentName:"li"},"Getting the seams and mappings right is crucial: You must use a\ngraphic tool like Blender to create UV Maps (Texture Atlas) and\nstore the coordinates correctly. It's worth the while to learn this,\nUV mapped models look a lot more professional.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Albedo Maps")),Object(i.b)("p",{parentName:"li"},"Albedo maps are similar to Diffuse maps with the exceptions that\nthey don't have shadows or highlights. They are used as the base\ncolor of a PBR material."))),Object(i.b)("h2",{id:"environment-mapping"},"Environment Mapping"),Object(i.b)("p",null,Object(i.b)("img",Object(n.a)({parentName:"p"},{src:"../wp-uploads/glass-teapot1.png",alt:"glass-teapot1.png"}))),Object(i.b)("p",null,"Environment Mapping or Reflection Mapping is used to create the\nimpression of reflections and refractions in real time. It's faster (but\nless accurate) than the raytracing methods used in offline rendering\napplications."),Object(i.b)("p",null,'You create a Cube Map to represent your environment; Sphere Maps are\nalso possible, but often look distorted. Basically you give the\nenvironment map a set of images showing a "360\xb0" view of the background\nscene -- very similar to a skybox. The renderer maps the environment on\nthe texture of the reflective surface, which results in an acceptable\n"glass/mirror/water" effect. Just like a skybox, the reflection map is\nstatic, so dynamic things (such as the player walking) are not part of\nthe reflection. (!)'),Object(i.b)("p",null,"See also: ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"../jme3/advanced/water"}),"Water"),"."),Object(i.b)("h2",{id:"mip-map-texture"},"MIP Map Texture"),Object(i.b)("p",null,'MIP Map means that you provide one texture in two or three resolutions\nin one file (MIP = "multum" in parvo = "many" in one). Depending on how\nclose (or far) the camera is, the engine automatically renders a more\n(or less) detailed texture for the object. Thus objects look detailed at\nclose up, but also look good when viewed from far away. Good for\neverything, but requires more time to create and more space to store\ntextures. If you don\'t provide custom ones, the jMonkeyEngine creates\nbasic MIP maps automatically as an optimization.'),Object(i.b)("h2",{id:"procedural-textures"},"Procedural Textures"),Object(i.b)("p",null,"A procedural texture is generated from repeating one small image, plus\nsome pseudo-random, gradient variations (called Perlin noise).\nProcedural textures look more natural than static rectangular textures,\nand they look less distorted on spheres. On big meshes, their\nrepetitiveness is much less noticable than with tiled seamless textures.\nProcedural textures are ideal for irregular large-area textures like\ngrass, soil, rock, rust, and walls. Use the ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"../sdk/neotexture"}),"jMonkeyEngine SDK\nNeoTexture plugin")," to create them."),Object(i.b)("p",null,Object(i.b)("img",Object(n.a)({parentName:"p"},{src:"../wp-uploads/neotexture-2.jpg",alt:"neotexture-2.jpg"}))),Object(i.b)("p",null,"See also: ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"http://en.wikibooks.org/wiki/Blender_3D:_Noob_to_Pro/Every_Material_Known_to_Man"}),"Blender: Every Material Known to\nMan")),Object(i.b)("h2",{id:"physically-based-rendering-textures-pbr"},"Physically Based Rendering Textures (PBR)"),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"Physically based rendering is an approach in computer graphics that\nseeks to render graphics in a way that more accurately models the flow\nof light in the real world."),Object(i.b)("p",{parentName:"blockquote"},"---  Wikipedia")),Object(i.b)("p",null,"To simplify, PBR attempts to deliver photo realistic images based off\nthe texture of a material and how light becomes more reflective the more\nyou view it at an angle. In other words, it's based on real physics.\nEverything has a reflection but accurately representing that reflection\nin video graphics has been mostly done with tricks prior to the\nintroduction of PBR. Tricks as in using different lighting images\n(specular maps) overlaying color images (diffuse maps) to simulate\nshininess."),Object(i.b)("p",null,'With PBR, a materials "Metalness" (conductive) or \\"Dielectric\\"\n(insulator) and \\"Roughness\\" or lack thereof will determine how light\ngets reflected. For example, metal (Metalness) is smoother than dirt\n(dielectric) so has a higher reflection whereas the dirt would tend to\nabsorb the light, just as in real world conditions.'),Object(i.b)("p",null,'The technique described above is known as the "Metalness Workflow".\nWhere you are deciding whether the texture is metallic or dielectric and\ndefining the amount of roughness for the texture.'),Object(i.b)("p",null,'There is another workflow known as the "Specular Workflow". In the\nmetalness workflow the albedo map is used for both diffuse color and\nspecular color. "Specular Workflow" uses a specular color map instead.\nIn this workflow, the albedo map is the diffuse color, the specular map\nis the specular color, and you have a gray scale gloss map that is the\nsame as the roughness map. The workflow is very similar to the old\ntechniques used for making materials.'),Object(i.b)("p",null,"This has been a brief introduction to PBR. In reality, it requires a\nsignificant amount of learning to implement correctly. Read the three\npart series of articles called, Physically Based Rendering, that can be\nfound under the ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"../jme3.xml#materials-light-shadow"}),"Materials, light,\nShadow")," topic for a more in depth\nexplanation of PBR textures. This is a must read for any serious jME\ndeveloper."),Object(i.b)("p",null,"See also: ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://www.chaosgroup.com/blog/understanding-metalness"}),"Understanding\nMetalness"),"."),Object(i.b)("p",null,"You should also conduct many searches on the subject, especially ones\nrelated to your modeling tool of choice."),Object(i.b)("h1",{id:"animation"},"Animation"),Object(i.b)("p",null,"In 3D games, Skeletal Animation is used for animated characters, but in\nprinciple the skeleton approach can be extended to any 3D mesh (for\nexample, an opening crate's hinge can be considered a primitive joint)."),Object(i.b)("p",null,"Unless you animate a 3D cartoon, realism of animated characters is\ngenerally a problem: Movement can look alien-like mechanical or broken,\nthe character appears hollow, or as if floating. Professional game\ndesigners invest a lot of effort to make characters animate in a natural\nway, including ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"http://en.wikipedia.org/wiki/Motion_capture"}),"motion\ncapture"),"."),Object(i.b)("h2",{id:"rigging-and-skinning"},"Rigging and Skinning"),Object(i.b)("p",null,Object(i.b)("img",Object(n.a)({parentName:"p"},{src:"../wp-uploads/blenderswordsman.png",alt:"blenderswordsman.png"}))),Object(i.b)("p",null,"An animated character has an armature: An internal skeleton (Bones) and\nan external surface (Skin). The Skin is the visible outside of the\ncharacter and it includes clothing. The Bones are not visible and are\nused to interpolate (calculate) the morphing steps of the skin."),Object(i.b)("p",null,"JME3, the game engine, only loads and plays your recorded animations.\nYou must use a tool (such as Blender) to set up (rig, skin, and animate)\na character."),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Rigging:")," The Construction of a character's skeleton."),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Create as few Bones as possible to decrease complexity.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Bones are connected in a parent-child hierarchy: Moving one bone\ncan pull another bone with it (e.g. arm pulls hand).")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Bones follow a certain naming scheme so the 3D engines know\nwhat's what.")))),Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Skinning:")," The association of individual bones with the\ncorresponding skin sections."),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Each Bone is connected to a part of the Skin. Animating the\n(invisible) Bone pulls the (visible) Skin with it.\\\nE.g. the thigh Bone is connected to the upper leg Skin.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"One part of the Skin can be affected by more than one bone (e.g.\nknee, elbow).")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"The connection between bones and skin sections is gradual: You\nassign weights how much each skin polygon is affected by any\nbone's motion.\\\nE.g. when the thigh bone moves, the leg is fully affected, the\nhips joints less so, and the head not at all.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"jMonkeyEngine supports hardware skinning (on the GPU, not on the\nCPU).")))),Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Keyframe Animation:")," A keyframe is one recorded snapshot of a\nmotion sequence."),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"A series of keyframes makes up one animation.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},'Each model can have several animations. Each animation has a\nname to identify it (e.g. "walk", "attack", "jump").')),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"You specify in your game code which keyframe animation to load,\nand when to play it."))))),Object(i.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},'What is the difference between animation (rigging, skinning, keyframes)\nand transformation (rotation, scaling, moving, "slerp")?'),Object(i.b)("ul",{parentName:"div"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Transformation is simpler than animation. Sometimes, transforming a\ngeometry already makes it look like it is animated: For example, a\nspinning windmill, a pulsating alien ball of energy, moving rods of\na machine. Transformations can be easily done with JME3 methods.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},'Animations however are more complex and are encoded in a special\nformat (keyframes). They distort the skin of the mesh, and complex\nseries of motions be "recorded" (in external tools) and played (in\nJME3).'))))),Object(i.b)("h2",{id:"kinematics"},"Kinematics"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Forward kinematics: \"Given\" the angles of all the character's\njoints, what is the position of the character's hand?")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Inverse kinematics: \"Given\" the position of the character's hand,\nwhat are the angles of all the character's joints?"))),Object(i.b)("h2",{id:"controller-and-channel"},"Controller and Channel"),Object(i.b)("p",null,"In the JME3 application, you register animated models to the Animation\nController. The controller object gives you access to the available\nanimation sequences. The controller has several channels, each channel\ncan run one animation sequence at a time. To run several sequences, you\ncreate several channels, and run them in parallel."),Object(i.b)("h1",{id:"artificial-intelligence-ai"},"Artificial Intelligence (AI)"),Object(i.b)("p",null,'Non-player (computer-controlled) characters (NPCs) are only fun in a\ngame if they do not stupidly bump into walls, or blindly run into the\nline of fire. You want to make NPCs "aware" of their surroundings and\nlet them make decisions based on the game state -- otherwise the player\ncan just ignore them. The most common use case is that you want to make\nenemies interact in a way so they offer a more interesting challenge for\nthe player.'),Object(i.b)("p",null,'"Smart" game elements are called artificially intelligent agents (AI\nagents). An AI agent can be used to implement enemy NPCs as well as\ntrained pets; you also use them to create automatic alarm systems that\nlock doors and "call" the guards after the player triggers an intruder\nalert.'),Object(i.b)("p",null,"The domain of artificial intelligence deals, among other things, with:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Knowledge")," -- Knowledge is ",Object(i.b)("em",{parentName:"p"},"the data"),' to which the AI agent has\naccess, and on which the AI bases its decisions. Realistic agents\nonly "know" what they "see and hear". This implies that information\ncan be hidden from the AI to keep the game fair. You can have an\nall-knowing AI, or you can let only some AI agents share\ninformation, or you let only AI agents who are close know the\ncurrent state.\\\nExample: After the player trips the wire, only a few AI guards with\ntwo-way radios start moving towards the player\'s position, while\nmany other guards don\'t suspect anything yet.')),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Goal Planning")," -- Planning is about how an AI agent ",Object(i.b)("em",{parentName:"p"},"takes\naction"),". Each agent has the priority to achieve a specific goal, to\nreach a future state. When programming, you split the agent's goal\ninto several subgoals. The agent consults its knowledge about the\ncurrent state, chooses from available tactics and strategies, and\nprioritizes them. The agent repeatedly tests whether the current\nstate is closer to its goal. If unsuccessful, the agent must discard\nthe current tactics/strategy and try another one.\\\nExample: An agent searches the best path to reach the player base in\na changing environment, avoiding traps. An agent chases the player\nwith the goal of eliminating him. An agent hides from the player\nwith the goal of murdering a VIP.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Problem Solving")," -- Problem solving is about how the agent\n",Object(i.b)("em",{parentName:"p"},"reacts to interruptions"),", obstacles that stand between it and its\ngoal. The agent uses a given set of facts and rules to deduct what\nstate it is in -- triggered by perceptions similar to pain, agony,\nboredom, or being trapped. In each state, only a specific subset of\nreactions makes sense. The actual reaction also depends on the\nagent's, goal since the agent's reaction must not block its own\ngoal!\\\nExamples: If player approaches, does the agent attack or conceal\nhimself or raise alarm? While agent is idle, does he lay traps or\nheal self or recharge magic runes? If danger to own life, does the\nagent try to escape or kamikaze?"))),Object(i.b)("p",null,"More advanced AIs can also learn, for example using neural networks."),Object(i.b)("p",null,"There are lots of resources explaining interesting AI algorithms:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"http://www.policyalmanac.org/games/aStarTutorial.htm"}),"A","*"," (A-Star) pathfinding for\nbeginners"))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"http://theory.stanford.edu/~amitp/GameProgramming/"}),"A","*"," (A-star) pathfinding\ntheory"))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"http://hem.fyristorg.com/dawnbringer/z-path.html"}),'\\"Z-Path\\"\nalgorithm'),"\n(backwards pathfinding)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"http://web.media.mit.edu/~jorkin/goap.html"}),"GOAP\u2009---\u2009Goal-Oriented Action\nPlanning"))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"http://neuroph.sourceforge.net/"}),"Neuroph\u2009---\u2009Java Neural Networks")))),Object(i.b)("h1",{id:"math"},"Math"),Object(i.b)("p",null,Object(i.b)("img",Object(n.a)({parentName:"p"},{src:"../jme3/intermediate/coordinate-system.png",alt:"coordinate-system.png"}))),Object(i.b)("h2",{id:"coordinates"},"Coordinates"),Object(i.b)("p",null,"Coordinates represent a location in a coordinate system. Coordinates are\nrelative to the origin at (0,0,0). In 3D space, you need to specify\nthree coordinate values to locate a point: X (right), Y (up), Z (towards\nyou). Similarly, -X (left), -Y (down), -Z (away from you). In contrast\nto a vector (which looks similar), a coordinate is a location, not a\ndirection."),Object(i.b)("h3",{id:"the-origin"},"The Origin"),Object(i.b)("p",null,"The origin is the central point in the 3D world, where the three axes\nmeet. It's always at the coordinates (0,0,0)."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")," ",Object(i.b)("inlineCode",{parentName:"p"},"Vector3f origin = new Vector3f( Vector3f.ZERO );")),Object(i.b)("h2",{id:"vectors"},"Vectors"),Object(i.b)("p",null,"A vector has a length and a direction, like an arrow in 3D space. A\nvector starts at a coordinate (x1,y1,z1) or at the origin, and ends at\nthe target coordinate (x2,y2,z2). Backwards directions are expressed\nwith negative values."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"Vector3f v = new Vector3f( 17f , -4f , 0f ); // starts at (0/0/0)\nVector3f v = new Vector3f( 8f , 0f , 33f ).add(new Vector3f( 0f , -2f , -2f )); // starts at (8,-2,31)\n")),Object(i.b)("h3",{id:"unit-vectors"},"Unit Vectors"),Object(i.b)("p",null,"A ",Object(i.b)("em",{parentName:"p"},"unit vector")," is a basic vector with a length of 1 world unit. Since\nits length is fixed (and it thus can only point at one location anyway),\nthe only interesting thing about this vector is its direction."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"p"},"Vector3f.UNIT_X")," = ( 1, 0, 0) = right")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"p"},"Vector3f.UNIT_Y")," = ( 0, 1, 0) = up")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"p"},"Vector3f.UNIT_Z")," = ( 0, 0, 1) = forwards")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"p"},"Vector3f.UNIT_XYZ")," = 1 wu diagonal right-up-forewards"))),Object(i.b)("p",null,"Negate the components of the vector to turn its direction, e.g. negating\nright (1,0,0) results in left (-1,0,0)."),Object(i.b)("h3",{id:"normalized-vectors"},"Normalized Vectors"),Object(i.b)("p",null,"A ",Object(i.b)("em",{parentName:"p"},"normalized vector")," is a custom ",Object(i.b)("em",{parentName:"p"},"unit vector"),". A normalized vector is\nnot the same as a ",Object(i.b)("em",{parentName:"p"},"(surface) normal vector"),". When you normalize a\nvector, it still has the same direction, but you lose the information\nwhere the vector originally pointed."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")," You normalize vectors before calculating angles."),Object(i.b)("h3",{id:"surface-normal-vectors"},"Surface Normal Vectors"),Object(i.b)("p",null,Object(i.b)("img",Object(n.a)({parentName:"p"},{src:"../jme3/300px-surface_normal.png",alt:"300px-surface_normal.png"}))),Object(i.b)("p",null,"A surface normal is a vector that is perpendicular (orthogonal) to a\nplane. You calculate the Surface Normal by calculating the cross\nproduct."),Object(i.b)("h3",{id:"cross-product"},"Cross Product"),Object(i.b)("p",null,'The cross product is a calculation that you use to find a perpendicular\nvector (an orthogonal, a "right" angle at 90\xb0). In 3D space, speaking of\nan orthogonal only makes sense with respect to a plane. You need two\nvectors to uniquely define a plane. The cross product of the two\nvectors, ',Object(i.b)("inlineCode",{parentName:"p"},"v1 \xd7 v2"),", is a new vector that is perpendicular to this plane.\nA vector perpendicular to a plane is a called ",Object(i.b)("em",{parentName:"p"},"Surface Normal"),"."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")," The x unit vector and the y unit vector together define the\nx/y plane. The vector perpendicular to them is the z axis. JME can\ncalculate that this equation is true:\\\n",Object(i.b)("inlineCode",{parentName:"p"},"( Vector3f.UNIT_X.cross( Vector3f.UNIT_Y ) ).equals( Vector3f.UNIT_Z )"),"\n== true"),Object(i.b)("h3",{id:"transformation"},"Transformation"),Object(i.b)("p",null,"Transformation means rotating (turning), scaling (resizing), or\ntranslating (moving) objects in 3D scenes. 3D engines offer simple\nmethods so you can write code that transforms nodes."),Object(i.b)("p",null,"Examples: Falling and rotating bricks in 3D Tetris."),Object(i.b)("h3",{id:"slerp"},"Slerp"),Object(i.b)("p",null,'Slerp is how we pronounce spherical linear interpolation when we are in\na hurry. A slerp is an interpolated transformation that is used as a\nsimple "animation" in 3D engines. You define a start and end state, and\nthe slerp interpolates a constant-speed transition from one state to the\nother. You can play the motion, pause it at various percentages (values\nbetween 0.0 and 1.0), and play it backwards and forwards. ',Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"%7Blink-javadoc%7D/com/jme3/math/Quaternion.html#slerp-com.jme3.math.Quaternion-com.jme3.math.Quaternion-float-"}),"JavaDoc:\nslerp()")),Object(i.b)("p",null,'Example: A burning meteorite Geometry slerps from "position p1, rotation\nr1, scale s1" in the sky down to "p2, r2, s2" into a crater.'),Object(i.b)("p",null,Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"../jme3/math"}),"Learn more about 3D maths here.")),Object(i.b)("h1",{id:"game-developer-jargon"},"Game Developer Jargon"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"http://www.gamasutra.com/view/feature/6504/a_game_studio_culture_dictionary.php?print=1"}),"A Game Studio Culture\nDictionary"))),Object(i.b)("h1",{id:"3d-graphics-terminology-wiki-book"},"3D graphics Terminology Wiki book"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"http://en.wikipedia.org/wiki/User:Jreynaga/Books/3D_Graphics_Terms"}),"http://en.wikipedia.org/wiki/User:Jreynaga/Books/3D_Graphics_Terms"))))}p.isMDXComponent=!0},441:function(e,t,a){"use strict";a.d(t,"a",(function(){return b})),a.d(t,"b",(function(){return u}));var n=a(0),r=a.n(n);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=r.a.createContext({}),p=function(e){var t=r.a.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):l({},t,{},e)),a},b=function(e){var t=p(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},h=Object(n.forwardRef)((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),b=p(a),h=n,u=b["".concat(o,".").concat(h)]||b[h]||m[h]||i;return a?r.a.createElement(u,l({ref:t},c,{components:a})):r.a.createElement(u,l({ref:t},c))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,o=new Array(i);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:n,o[1]=l;for(var c=2;c<i;c++)o[c]=a[c];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,a)}h.displayName="MDXCreateElement"}}]);