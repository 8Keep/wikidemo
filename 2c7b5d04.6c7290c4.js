(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{202:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return b}));var a=n(1),o=n(9),i=(n(0),n(441)),r={},l={id:"jme3/advanced/monkey_zone",title:"monkey_zone",description:"MonkeyZone is an multi-player demo game provided by the jME core",source:"@site/docs/jme3/advanced/monkey_zone.md",permalink:"/wikidemo/docs/jme3/advanced/monkey_zone",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/advanced/monkey_zone.md"},s=[{value:"Terminology",id:"terminology",children:[]},{value:"Manager Classes",id:"manager-classes",children:[]},{value:"Use of Controls",id:"use-of-controls",children:[{value:"...\u200bAs entity capabilities",id:"as-entity-capabilities",children:[]},{value:"...\u200b to abstract",id:"-to-abstract",children:[]},{value:"...\u200b for AI functions",id:"-for-ai-functions",children:[]}]},{value:"Artificial Intelligence",id:"artificial-intelligence",children:[{value:"Commands",id:"commands",children:[]},{value:"Triggers",id:"triggers",children:[]},{value:"NavMesh",id:"navmesh",children:[]}]},{value:"Networking",id:"networking",children:[]},{value:"UserData",id:"userdata",children:[]},{value:"Physics",id:"physics",children:[]},{value:"Designer Infos",id:"designer-infos",children:[{value:"Developer Infos",id:"developer-infos",children:[]}]}],c={rightToc:s};function b(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"MonkeyZone is an multi-player demo game provided by the jME core\ndeveloper team."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine/monkeyzone"}),"Download source code"),"\n(Github Repository)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"http://www.youtube.com/watch?v=98yITEoJvqE"}),"Watch pre-alpha video\nfootage")," (YouTube Video)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"http://web.archive.org/web/20121021075434/http://jmonkeyengine.org/2011/02/13/monkeyzone-a-jme3-game-from-the-core/"}),'Read \\"MonkeyZone -- a jME3 game from the\ncore\\"'),"\n(news article)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://hub.jmonkeyengine.org/t/open-game-finder/13399/11"}),"Related forum thread: Open Game\nFinder")))),Object(i.b)("p",null,"This open-source demo:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"showcases one possible way to implement a game with jME3, and")),Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"helps the jME team verify the jME3 API in terms of usability."))),Object(i.b)("p",null,'The game idea is based on "BattleZone" arcade game from the 1980s, a\nfirst-person shooter the with real-time strategy elements. The game was\nwritten using the jMonkeyEngine SDK, and it\'s based off the BasicGame\nproject template. It took us one week to create a playable pre-alpha,\nincluding networking. The project design follows best practices that\nmake it possible to edit maps, vehicles, etc, in jMonkeyEngine SDK\nwithout having to change the code -- This allows 3D graphic designers to\ncontribute models more easily. (If you feel like contributing assets or\nworking on parts of the game code, drop us a note!)'),Object(i.b)("h1",{id:"implementation"},"Implementation"),Object(i.b)("p",null,"MonkeyZone is a multi-player game with a physics simulation. Both,\nclients and server, run the physics simulation. The clients send input\ndata from the player group to the server, where they control the\nentities, and also broadcast to the clients. Additionally, the server\nsends regular syncronization data for all objects in the game to prevent\ndrifting. When a human user or an AI performs an action (presses a\nbutton), the actual logic is done on the server. The results are\nbroadcast as data messages to the entities. When the entity is\ncontrolled by an AI, the actual AI code (that determines where the\nentity should move, and when it should perform an action) is executed on\nthe client. ","_",'The way MonkeyZone is implemented is just one of the many\npossible ways to do a game like this in jME. Some things might be done\nmore efficiently, some might be done in another way completely.\nMonkeyZone tries to do things the way that are most appropriate to\nimplement the game at hand and it shows nicely how jME3 and the standard\nJava \\<abbr title=\\"Application Programming Interface\\"',">","API\\</abbr",">","++\ncan make game development easier and faster. Also note that the way\nMonkeyZone is designed is not scalable to a MMO style game, it will only\nwork in a FPS style environment where the whole game world can be loaded\nat once.","_"),Object(i.b)("h2",{id:"terminology"},"Terminology"),Object(i.b)("p",null,"The game uses certain terms that might be familiar to you but maybe used\nin another way, so heres a quick rundown on the terms being used."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},'Player -- Logical human or AI player that can enter entities and\ngenerally act, only exists as PlayerData "database" with an id.')),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Entity -- Spatial with UserData, a world object like character,\nvehicle, box or factory. The base form is defined only by a String\npointing to the j3o which already has all userdata like hitpoints,\nspeed etc.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"User -- Human player using a client")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Player Group -- Group of players that play together (e.g. one human\nplayer and one AI companion per client). For now that's the same as\nclient","_","id of human player for all AIControl'ed players originating\nfrom that client.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Client -- Computer connected to server"))),Object(i.b)("h2",{id:"manager-classes"},"Manager Classes"),Object(i.b)("p",null,"The WorldManager does the main work of organizing players, entities and\nthe world and synchronizing them between the server and client. Both\nclient and server use this class. Some other managers like\nClientEffectsManager only exist on the client or server and manage e.g.\neffects display. The gameplay is largely controlled by the\nServerGameManager which does gameplay logic on the server, combined with\nthe actions issued by the AI and user on the client (see below) it\nimplements the gameplay. It extensively uses the functions exposed by\nthe WorldManager to perform actions and gather data. This is also the\nclass where the actions of the players are actually executed on the\nserver to determine the outcome (ray testing for shooting etc.)."),Object(i.b)("h2",{id:"use-of-controls"},"Use of Controls"),Object(i.b)("p",null,Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/advanced/custom_controls"}),"Controls")," are used extensively\nin MonkeyZone for many aspects of the game. When a player enters an\nentity, the Spatials Controls are configured based on the player that\nenters. For example when the human user enters an entity, Controls that\nupdate the user interface (DefaultHUDControl) or user input\n(UserInputControl) are added to the current entity Spatial."),Object(i.b)("h3",{id:"as-entity-capabilities"},"...\u200bAs entity capabilities"),Object(i.b)("p",null,'Controls attached to Spatials are generally used like an "array of\ncapabilities" that the entity posesses. So when an entity has a\nVehicleControl its expected to be a vehicle, when its got a\nCharacterControl its expected to be a character. Other Controls work\ncompletely on their own, like CharacterAnimControl which just uses the\nCharacterControl of the entity to check if the character is running,\njumping etc. and then animates the entity if it has an AnimControl.'),Object(i.b)("h3",{id:"-to-abstract"},"...\u200b to abstract"),Object(i.b)("p",null,"Furthermore theres special interfaces for Controls that allow\nabstraction of different Controls into one base interface. For example\nManualControl and AutonomousControl are interfaces for controls that\nmanage the movement of a spatial in a generalized way. This way AI code\nand e.g. the UserInputControl only have to check for a valid\nAutonomousControl or ManualControl on the spatial to control and move\nit. The details of the movement are handled by classes like\nManualVehicleControl and AutonomousCharacterControl."),Object(i.b)("h3",{id:"-for-ai-functions"},"...\u200b for AI functions"),Object(i.b)("p",null,"A special Control called CommandControl handles the Commands that can be\nexecuted by user controlled players, see below."),Object(i.b)("h2",{id:"artificial-intelligence"},"Artificial Intelligence"),Object(i.b)("p",null,"MonkeyZone includes simple AI functions based on a command queue."),Object(i.b)("h3",{id:"commands"},"Commands"),Object(i.b)("p",null,"To implement autonomous AI players MonkeyZone uses a system of Commands\nthat are managed by a CommandControl that is attached to each AI player\nentity controlled by the user. This CommandControl manages a list of\nCommands that are executed based on priority. For example theres a\nMoveCommand, a FollowCommand and an AttackCommand, Commands can however\nimplement more complete behavior than that, e.g. the complete logic for\na scavenging entity."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Press the WASD keys and use the mouse to move")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"press space to jump")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Aim and click to shoot")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Type 1 to select the first Ogre"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Aim at the floor and press F1 to tell it where to go.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Aim at a target and press F2 to tell it who to follow.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Aim at the car and press F3 to make it drive the car.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Aim at a target and press F4 to tell it who to attack.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Walk close to the car and press enter to drive the car."))))),Object(i.b)("h3",{id:"triggers"},"Triggers"),Object(i.b)("p",null,'The SphereTrigger is a TriggerControl that is also attached to each AI\nplayers current entity. It consists of a GhostControl that checks the\noverlapping entities around the entity its attached to. It can be\nassigned a command that is checked with every entity entering the\nSphereTrigger and executed if applicable (e.g. normal "attack enemy"\nmode).'),Object(i.b)("h3",{id:"navmesh"},"NavMesh"),Object(i.b)("p",null,"For each map a navigation mesh is generated that allows the entities to\nnavigate the terrain. Autonomous entities automatically get a\nNavigationControl based on the current map. The AutonomousControl\nimplementations automatically recognize the NavigationControl attached\nto the Spatial and use it for navigation. The NavMeshNavigationControl\nimplementation contains a reference to the levels NavMesh and implements\na navigation algorithm similar to the A","*"," algorithm."),Object(i.b)("h2",{id:"networking"},"Networking"),Object(i.b)("p",null,'Networking is realized in the PhysicsSyncManager which we hope to extend\nto a state where it can serve as a general sync system for physics based\nnetwork games. The sync manager basically puts a timestamp on every\nmessage sent from the server and then buffers all arriving messages on\nthe client within a certain time window. This allows to compensate for\nmessages arriving too soon or too late within the constraints of the\nbuffer, a future version might step the clients physics space different\nto compensate for network delays without "snapping".'),Object(i.b)("h1",{id:"use-of-jmonkeyengine-sdk-tools"},"Use of jMonkeyEngine SDK tools"),Object(i.b)("p",null,"All assets used in the game, like entity models and loaded maps can be\npreconfigured and edited using the jMonkeyEngine SDK. For example, to\nadd a new vehicle type, a vehicle is created in the jMonkeyEngine SDK\nvehicle editor and UserData like Speed, HitPoints etc. is applied\ndirectly in the editor. When the model is loaded in the game it is\nautomatically configured based on these settings, the same accounts for\nmaps that are loaded, special Nodes that mark e.g. player start\nlocations are recognized automatically etc."),Object(i.b)("h2",{id:"userdata"},"UserData"),Object(i.b)("p",null,"Entities (Nodes and Geometries) that are loaded from disk have certain\nUserData like HitPoints, Speed etc. that is used to configure the entity\nat runtime. The jMonkeyEngine SDK allows adding and editing this\nUserData, so entity properties are editable visually."),Object(i.b)("h2",{id:"physics"},"Physics"),Object(i.b)("p",null,"VehicleControls, CharacterControls and RigidBodyControls with mesh\ncollision shape for terrain and objects are generated in the\njMonkeyEngine SDK and saved in the entity j3o file. When an entity is\nloaded, the type of entity is identified based on the available controls\nand UserData and it is configured accordingly."),Object(i.b)("h1",{id:"api-info"},"API Info"),Object(i.b)("h2",{id:"designer-infos"},"Designer Infos"),Object(i.b)("p",null,"Editable UserData of entity Spatials:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"(float) HitPoints")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"(float) MaxHitPoints")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"(float) Speed"))),Object(i.b)("p",null,"Entity Spatial marking Node names:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"AimNode")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"CameraAttachment")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"ShootAttachment"))),Object(i.b)("p",null,"Level Spatial marking Node names:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"StartPoint")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"PowerSource")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"MetalField"))),Object(i.b)("h3",{id:"developer-infos"},"Developer Infos"),Object(i.b)("p",null,"Programmatic UserData of entities:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"(long) entity","_","id")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"(int) group","_","id")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"(long) player","_","id"))),Object(i.b)("p",null,"Programmatic PlayerData:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"(long) id")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"(int) group","_","id")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"(long) entity","_","id")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"(long) character","_","entity","_","id"))),Object(i.b)("h1",{id:"the-future"},"The Future"),Object(i.b)("p",null,"Have a look at the code and feel free to ask about it, if you want any\nnew features, you are free to implement them. ;) MonkeyZone is hosted at\nGoogleCode, where you can check out the jMonkeyEngine SDK-ready project\nvia svn:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"jMonkeyEngine SDK\u2192Team\u2192Subversion\u2192Checkout,")),Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"Enter the SVN URL ",Object(i.b)("inlineCode",{parentName:"p"},"http://monkeyzone.googlecode.com/svn/trunk/"))),Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"Download, open, and build the project")),Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"Run the server first (com.jme3.monkeyzone.ServerMain), and then a\nclient (com.jme3.monkeyzone.ClientMain)."))),Object(i.b)("h1",{id:"troubleshooting"},"Troubleshooting"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"After download, errors could appear because\njme3tools.navmesh.util","\\","NavMeshGenerator.java import\ncom.jme3.terrain.Terrain is not known, you should correct this by\nsetting Project Properties ",">"," Libraries ",">"," Add Library ",">","\njme3-libraries-terrain")))}b.isMDXComponent=!0},441:function(e,t,n){"use strict";n.d(t,"a",(function(){return m})),n.d(t,"b",(function(){return d}));var a=n(0),o=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=o.a.createContext({}),b=function(e){var t=o.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l({},t,{},e)),n},m=function(e){var t=b(e.components);return o.a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},h=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,r=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=b(n),h=a,d=m["".concat(r,".").concat(h)]||m[h]||p[h]||i;return n?o.a.createElement(d,l({ref:t},c,{components:n})):o.a.createElement(d,l({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var c=2;c<i;c++)r[c]=n[c];return o.a.createElement.apply(null,r)}return o.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);