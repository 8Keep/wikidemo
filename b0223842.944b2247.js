(window.webpackJsonp=window.webpackJsonp||[]).push([[207],{346:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return s})),t.d(n,"rightToc",(function(){return l})),t.d(n,"default",(function(){return p}));var a=t(1),r=t(9),i=(t(0),t(441)),o={},s={id:"jme3/advanced/mesh",title:"mesh",description:"![dolphin-mesh.png](/images/jme3/dolphin-mesh.png)",source:"@site/docs/jme3/advanced/mesh.md",permalink:"/wikidemo/docs/jme3/advanced/mesh",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/advanced/mesh.md"},l=[{value:"Mesh Vertex Buffers",id:"mesh-vertex-buffers",children:[]},{value:"Mesh Properties",id:"mesh-properties",children:[]},{value:"Mesh Rendering Modes",id:"mesh-rendering-modes",children:[]},{value:"Level of Detail",id:"level-of-detail",children:[]}],c={rightToc:l};function p(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("p",null,Object(i.b)("img",Object(a.a)({parentName:"p"},{src:"/images/jme3/dolphin-mesh.png",alt:"dolphin-mesh.png"}))),Object(i.b)("p",null,"All visible game elements in a scene, whether it is a Model or a Shape,\nare made up of polygon meshes. JME3 has a\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"%7Blink-javadoc%7D/com/jme3/scene/Mesh.html"}),"com.jme3.scene.Mesh")," class\nthat represents all meshes."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Meshes are made up of triangles: ",Object(i.b)("inlineCode",{parentName:"p"},"getTriangleCount(\u2026)")," and\n",Object(i.b)("inlineCode",{parentName:"p"},"getTriangle(\u2026)"))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Each mesh has a unique ID: ",Object(i.b)("inlineCode",{parentName:"p"},"getId()"))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Meshes have transformations: Location (local translation), rotation,\nscale.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Meshes have a bounding volume. jME3 can detect intersections (that\nis, non-physical collisions) between meshes, or between meshes and\n2D elements such as rays: ",Object(i.b)("inlineCode",{parentName:"p"},"collideWith()"),".")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Meshes are locked with ",Object(i.b)("inlineCode",{parentName:"p"},"setStatic()")," and unlocked with\n",Object(i.b)("inlineCode",{parentName:"p"},"setDynamic()"),"."),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Static Meshes cannot be modified, but are more optimized and\nfaster (they can be precalculated).")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Dynamic Meshes can be modified live, but are not optimized and\nslower."))))),Object(i.b)("p",null,"You have several options when ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/advanced/spatial"}),"creating Geometries from\nmeshes"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use built-in ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/advanced/shape"}),"Shape"),"s as meshes;")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Load ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/advanced/3d_models"}),"3D models")," (that is, meshes\ncreated in external applications); or")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Create free-form ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/advanced/custom_meshes"}),"custom\nmeshes")," programmatically."))),Object(i.b)("h1",{id:"vertex-buffer"},"Vertex Buffer"),Object(i.b)("p",null,"The VertexBuffer contains a particular type of geometry data used by\nMeshes. Every VertexBuffer set on a Mesh is sent as an attribute to the\nvertex shader to be processed."),Object(i.b)("h2",{id:"mesh-vertex-buffers"},"Mesh Vertex Buffers"),Object(i.b)("p",null,"Here is the list of\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"%7Blink-javadoc%7D/com/jme3/scene/VertexBuffer.Type.html"}),"VertexBuffer"),"\ntypes."),Object(i.b)("p",null,"+-----------------------------------+-----------------------------------+\n| Vertex Buffer Type                | Description                       |\n+===================================+===================================+\n| Type.Position                     | Position of the vertex (3 floats) |\n+-----------------------------------+-----------------------------------+\n| Type.Index                        | Specifies the index buffer, must  |\n|                                   | contain integer data.             |\n+-----------------------------------+-----------------------------------+\n| Type.TexCoord                     | Texture coordinate                |\n+-----------------------------------+-----------------------------------+\n| Type.TexCoord2                    | Texture coordinate ","#","2            |\n+-----------------------------------+-----------------------------------+\n| Type.Normal                       | Normal vector, normalized.        |\n+-----------------------------------+-----------------------------------+\n| Type.Tangent                      | Tangent vector, normalized.       |\n+-----------------------------------+-----------------------------------+\n| Type.Binormal                     | Binormal vector, normalized.      |\n+-----------------------------------+-----------------------------------+\n| Type.Color                        | Color and Alpha (4 floats)        |\n+-----------------------------------+-----------------------------------+\n| Type.Size                         | The size of the point when using  |\n|                                   | point buffers.                    |\n+-----------------------------------+-----------------------------------+\n| Type.InterleavedData              | Specifies the source data for     |\n|                                   | various vertex buffers when       |\n|                                   | interleaving is used.             |\n+-----------------------------------+-----------------------------------+\n| Type.BindPosePosition             | Inital vertex position, used with |\n|                                   | animation.                        |\n+-----------------------------------+-----------------------------------+\n| Type.BindPoseNormal               | Inital vertex normals, used with  |\n|                                   | animation                         |\n+-----------------------------------+-----------------------------------+\n| Type.BoneWeight                   | Bone weights, used with animation |\n+-----------------------------------+-----------------------------------+\n| Type.BoneIndex                    | Bone indices, used with animation |\n+-----------------------------------+-----------------------------------+"),Object(i.b)("h2",{id:"mesh-properties"},"Mesh Properties"),Object(i.b)("p",null,"Some Mesh properties from the\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"%7Blink-javadoc%7D/com/jme3/scene/Mesh.html"}),"Mesh")," class."),Object(i.b)("p",null,"+-----------------------------------+-----------------------------------+\n| Mesh method                       | Description                       |\n+===================================+===================================+\n| setBound(boundingVolume)          | if you need to specifiy a custom  |\n|                                   | optimized bounding volume         |\n+-----------------------------------+-----------------------------------+\n| setStatic()                       | Locks the mesh so you cannot      |\n|                                   | modify it anymore, thus           |\n|                                   | optimizing its data (faster).     |\n+-----------------------------------+-----------------------------------+\n| setDynamic()                      | Unlocks the mesh so you can       |\n|                                   | modified it, but this will        |\n|                                   | un-optimize the data (slower).    |\n+-----------------------------------+-----------------------------------+\n| setMode(Mesh.Mode.Points)         | Used to set mesh rendering modes, |\n|                                   | see below.                        |\n+-----------------------------------+-----------------------------------+\n| getId()                           | returns the Mesh ID, default      |\n|                                   | value is -1                       |\n+-----------------------------------+-----------------------------------+\n| getTriangle(int,tri)              | returns data of triangle number   |\n|                                   | ",Object(i.b)("inlineCode",{parentName:"p"},"int")," into variable ",Object(i.b)("inlineCode",{parentName:"p"},"tri"),"         |\n+-----------------------------------+-----------------------------------+\n| scaleTextureCoordinates(Vector2f) | How the texture will be stretched |\n|                                   | over the whole mesh.              |\n+-----------------------------------+-----------------------------------+"),Object(i.b)("h2",{id:"mesh-rendering-modes"},"Mesh Rendering Modes"),Object(i.b)("p",null,"Here is the list of ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"%7Blink-javadoc%7D/com/jme3/scene/Mesh.Mode.html"}),"Mesh rendering\nmodes"),"."),Object(i.b)("p",null,"+-----------------------------------+-----------------------------------+\n| Mesh Mode                         | Description                       |\n+===================================+===================================+\n| Mesh.Mode.Points                  | Show only corner points           |\n|                                   | (vertices) of mesh                |\n+-----------------------------------+-----------------------------------+\n| Mesh.Mode.Lines                   | Show lines (edges) of mesh        |\n+-----------------------------------+-----------------------------------+\n| Mesh.Mode.LineLoop                | ?                                 |\n+-----------------------------------+-----------------------------------+\n| Mesh.Mode.LineStrip               | ?                                 |\n+-----------------------------------+-----------------------------------+\n| Mesh.Mode.Triangles               | ?                                 |\n+-----------------------------------+-----------------------------------+\n| Mesh.Mode.TriangleStrip           | ?                                 |\n+-----------------------------------+-----------------------------------+\n| Mesh.Mode.TriangleFan             | ?                                 |\n+-----------------------------------+-----------------------------------+\n| Mesh.Mode.Hybrid                  | ?                                 |\n+-----------------------------------+-----------------------------------+"),Object(i.b)("h2",{id:"level-of-detail"},"Level of Detail"),Object(i.b)("p",null,"Optionally, custom meshes can have a LOD (level of detail optimization)\nthat renders more or less detail, depending on the distance of the mesh\nfrom the camera. You have to specify several vertex buffers, one for\neach level of detail you want (very far away with few details, close up\nwith all details, and something in the middle). Use\n",Object(i.b)("inlineCode",{parentName:"p"},"setLodLevels(VertexBuffer[] lodLevels)"),"."))}p.isMDXComponent=!0},441:function(e,n,t){"use strict";t.d(n,"a",(function(){return m})),t.d(n,"b",(function(){return h}));var a=t(0),r=t.n(a);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=r.a.createContext({}),p=function(e){var n=r.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s({},n,{},e)),t},m=function(e){var n=p(e.components);return r.a.createElement(c.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},b=Object(a.forwardRef)((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(t),b=a,h=m["".concat(o,".").concat(b)]||m[b]||d[b]||i;return t?r.a.createElement(h,s({ref:n},c,{components:t})):r.a.createElement(h,s({ref:n},c))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=b;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=t[c];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,t)}b.displayName="MDXCreateElement"}}]);