(window.webpackJsonp=window.webpackJsonp||[]).push([[183],{322:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return u}));var a=n(1),i=n(9),o=(n(0),n(441)),r={},l={id:"jme3/advanced/recast",title:"recast",description:"What is Recast Navigation",source:"@site/docs/jme3/advanced/recast.md",permalink:"/wikidemo/docs/jme3/advanced/recast",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/advanced/recast.md"},s=[{value:"Recast",id:"recast",children:[]},{value:"Detour",id:"detour",children:[]},{value:"Plugin",id:"plugin",children:[]},{value:"Developmental project",id:"developmental-project",children:[]},{value:"Questions &amp; Suggestions",id:"questions--suggestions",children:[]},{value:"Source",id:"source",children:[{value:"Useful links",id:"useful-links",children:[]}]}],c={rightToc:s};function u(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h1",{id:"what-is-recast-navigation"},"What is Recast Navigation"),Object(o.b)("p",null,"Recast Navigation is C++ library for path-finding in 3D, continuous\nspace. Recast has two big modules:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Recast")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Detour"))),Object(o.b)("h2",{id:"recast"},"Recast"),Object(o.b)("p",null,"Recast is state of the art navigation mesh construction tool set for\ngames."),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"It is automatic, which means that you can throw any level geometry\nat it and you will get robust mesh out")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"It is fast which means swift turnaround times for level designers")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"It is open source so it comes with full source and you can customize\nit to your heart's content."))),Object(o.b)("h2",{id:"detour"},"Detour"),Object(o.b)("p",null,"Recast is accompanied with Detour, path-finding and spatial reasoning\ntoolkit. You can use any navigation mesh with Detour, but of course the\ndata generated with Recast fits perfectly."),Object(o.b)("p",null,"Detour offers simple static navigation mesh which is suitable for many\nsimple cases, as well as tiled navigation mesh which allows you to plug\nin and out pieces of the mesh. The tiled mesh allows you to create\nsystems where you stream new navigation data in and out as the player\nprogresses the level, or you may regenerate tiles as the world changes."),Object(o.b)("h1",{id:"jnavigation"},"jNavigation"),Object(o.b)("p",null,"jNavigation is port Java library for ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/memononen/recastnavigation"}),"Recast\nnavigation"),". jNavigation\nis the project in progress, and currently it enables building\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://en.wikipedia.org/wiki/Navigation_mesh"}),"Navigation meshes")," and\npath-finding for one agent (bot)."),Object(o.b)("h1",{id:"example"},"Example"),Object(o.b)("p",null,"In next code is described how the user should build navigation mesh, and\nquery for it."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'// Step 1. Initialize build config.\nConfig config = new Config();\n\nMesh mesh = ((Geometry) scene.getChild("terrain")).getMesh();\n\nVector3f minBounds = RecastBuilder.calculateMinBounds(mesh);\nVector3f maxBounds = RecastBuilder.calculateMaxBounds(mesh);\n\nconfig.setMaxBounds(maxBounds);\nconfig.setMinBounds(minBounds);\nconfig.setCellSize(0.3f);\nconfig.setCellHeight(0.2f);\nconfig.setWalkableSlopeAngle(45);\nconfig.setWalkableClimb(1);\nconfig.setWalkableHeight(2);\nconfig.setWalkableRadius(2);\nconfig.setMinRegionArea(8);\nconfig.setMergeRegionArea(20);\nconfig.setBorderSize(20);\nconfig.setMaxEdgeLength(12);\nconfig.setMaxVerticesPerPoly(6);\nconfig.setDetailSampleMaxError(1f);\nconfig.setDetailSampleDistance(6);\n\nRecastBuilder.calculateGridWidth(config);\nRecastBuilder.calculatesGridHeight(config);\n\n// Step 2. Rasterize input polygon soup.\n\n//context is needed for logging that is not yet fully supported in native library.\n//It must NOT be null.\nContext context = new Context();\n\n// Allocate voxel heightfield where we rasterize our input data to.\nHeightfield heightfield = new Heightfield();\nif (!RecastBuilder.createHeightfield(context, heightfield, config)) {\n    System.out.println("Could not create solid heightfield");\n    return;\n}\n\n// Allocate array that can hold triangle area types.\n\n// In Recast terminology, triangles are what indices in jME is. I left this,\n\n// Find triangles which are walkable based on their slope and rasterize them.\nchar[] areas = RecastBuilder.markWalkableTriangles(context, config.getWalkableSlopeAngle(), mesh);\nRecastBuilder.rasterizeTriangles(context, mesh, areas, heightfield, 20);\n\n\n// Step 3. Filter walkables surfaces.\n// Once all geometry is rasterized, we do initial pass of filtering to\n// remove unwanted overhangs caused by the conservative rasterization\n// as well as filter spans where the character cannot possibly stand.\nRecastBuilder.filterLowHangingWalkableObstacles(context, config.getWalkableClimb(), heightfield);\nRecastBuilder.filterLedgeSpans(context, config, heightfield);\nRecastBuilder.filterWalkableLowHeightSpans(context, config.getWalkableHeight(), heightfield);\n\n\n// Step 4. Partition walkable surface to simple regions.\n// Compact the heightfield so that it is faster to handle from now on.\n// This will result more cache coherent data as well as the neighbours\n// between walkable cells will be calculated.\nCompactHeightfield compactHeightfield = new CompactHeightfield();\n\nif (!RecastBuilder.buildCompactHeightfield(context, config, heightfield, compactHeightfield)) {\n    System.out.println("Could not build compact data");\n    return;\n}\n\nif (!RecastBuilder.erodeWalkableArea(context, config.getWalkableRadius(), compactHeightfield)) {\n    System.out.println("Could not erode");\n    return;\n}\n\n// Partition the heightfield so that we can use simple algorithm later to triangulate the walkable areas.\n// There are 3 martitioning methods, each with some pros and cons:\n// 1) Watershed partitioning\n//   - the classic Recast partitioning\n//   - creates the nicest tessellation\n//   - usually slowest\n//   - partitions the heightfield into nice regions without holes or overlaps\n//   - the are some corner cases where this method creates produces holes and overlaps\n//      - holes may appear when a small obstacles is close to large open area (triangulation can handle this)\n//      - overlaps may occur if you have narrow spiral corridors (i.e stairs), this make triangulation to fail\n//   * generally the best choice if you precompute the nacmesh, use this if you have large open areas\n// 2) Monotone partioning\n//   - fastest\n//   - partitions the heightfield into regions without holes and overlaps (guaranteed)\n//   - creates long thin polygons, which sometimes causes paths with detours\n//   * use this if you want fast navmesh generation\nString partitionType = "Sample partition watershed";\n\nif (partitionType.equals("Sample partition watershed")) {\n    if (!RecastBuilder.buildDistanceField(context, compactHeightfield)) {\n        System.out.println("Could not build distance field");\n        return;\n    }\n    if (!RecastBuilder.buildRegions(context, compactHeightfield, config)) {\n        System.out.println("Could not build watershed regions");\n        return;\n    }\n}\n\nif (partitionType.equals("Sample partition monotone")) {\n    if (!RecastBuilder.buildRegionsMonotone(context, compactHeightfield, config)) {\n        System.out.println("Could not build monotone regions");\n        return;\n    }\n}\n\n// Step 5. Trace and simplify region contours.\n// Create contours.\nContourSet contourSet = new ContourSet();\n\nif (!RecastBuilder.buildContours(context, compactHeightfield, 2f, config.getMaxEdgeLength(), contourSet)) {\n    System.out.println("Could not create contours");\n    return;\n}\n\n// Step 6. Build polygons mesh from contours.\n// Build polygon navmesh from the contours.\nPolyMesh polyMesh = new PolyMesh();\n\nif (!RecastBuilder.buildPolyMesh(context, contourSet, config.getMaxVertsPerPoly(), polyMesh)) {\n    System.out.println("Could not triangulate contours");\n    return;\n}\n\n// Step 7. Create detail mesh which allows to access approximate height on each polygon.\nPolyMeshDetail polyMeshDetail = new PolyMeshDetail();\n\nif (!RecastBuilder.buildPolyMeshDetail(context, polyMesh, compactHeightfield, config, polyMeshDetail)) {\n    System.out.println("Could not build detail mesh.");\n    return;\n}\n\n// (Optional) Step 8. Create Detour data from Recast poly mesh.\n// The GUI may allow more max points per polygon than Detour can handle.\n// Only build the detour navmesh if we do not exceed the limit.\nif (config.getMaxVertsPerPoly() > DetourBuilder.VERTS_PER_POLYGON()) {\n    return;\n}\nNavMeshCreateParams createParams = new NavMeshCreateParams();\ncreateParams.getData(polyMesh);\ncreateParams.getData(polyMeshDetail);\n//setting optional off-mesh connections (in my example there are none)\ncreateParams.getData(config);\ncreateParams.setBuildBvTree(true);\n\nchar[] navData = DetourBuilder.createNavMeshData(createParams);\n\nif (navData == null) {\n    System.out.println("Could not build Detour navmesh.");\n    return;\n}\n\nNavMesh navMesh = new NavMesh();\n\nif (!navMesh.isAllocationSuccessful()) {\n    System.out.println("Could not create Detour navmesh");\n    return;\n}\n\nStatus status;\nstatus = navMesh.init(navData, TileFlags.DT_TILE_FREE_DATA.value());\nif (status.isFailed()) {\n    System.out.println("Could not init Detour navmesh");\n    return;\n}\n\nNavMeshQuery query = new NavMeshQuery();\nstatus = query.init(navMesh, 2048);\nif (status.isFailed()) {\n    System.out.println("Could not init Detour navmesh query");\n    return;\n}\n')),Object(o.b)("p",null,"After this (if everything is successful) you can use methods in ",Object(o.b)("inlineCode",{parentName:"p"},"query"),"\nthat was created for path-finding purposes."),Object(o.b)("h1",{id:"how-to-get-jnavigation"},"How to get jNavigation"),Object(o.b)("p",null,"There is 2 ways to get jNavigation:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"as plugin form")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"as developmental project"))),Object(o.b)("h2",{id:"plugin"},"Plugin"),Object(o.b)("p",null,'You can download "stable version from\n',Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/QuietOne/jNavigationPlugin/tree/master"}),"repository")),Object(o.b)("h2",{id:"developmental-project"},"Developmental project"),Object(o.b)("p",null,"Instructions for downloading and setting it up:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Download C++ wrapper from ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/QuietOne/jNavigation-native"}),"jNavigationNative\nrepository"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Build downloaded project with C++ compiler")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Download java library from ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/QuietOne/jNavigation"}),"jNavigation\nrepository"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"In Java project in class\n",Object(o.b)("inlineCode",{parentName:"p"},"com.jme3.ai.navigation.utils.RecastJNI.java")," change URL to where\nyour build of C++ project is."))),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'static {\n    // the URL that needs to be changed\n    System.load(".../jNavigationNative.dll");\n}\n')),Object(o.b)("p",null,"If there is problem with building C++ project see\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/advanced/building_recast"}),"link"),"."),Object(o.b)("h2",{id:"questions--suggestions"},"Questions & Suggestions"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"For suggestion and/or question on jNavigation post on\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://hub.jmonkeyengine.org/forum/board/development/summer-of-code/"}),"forum"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"For question on Recast (C++ library) ask on ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://groups.google.com/forum/#!forum/recastnavigation"}),"Google\ngroups")))),Object(o.b)("h2",{id:"source"},"Source"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/QuietOne/jNavigationPlugin/tree/master"}),"jNavigation plugin\nrepository"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/QuietOne/jNavigation"}),"Developmental jNavigation\nrepository"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/QuietOne/jNavigation-native"}),"Developmental jNavigationNative\nrepository")))),Object(o.b)("h3",{id:"useful-links"},"Useful links"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/advanced/building_recast"}),"How to build the native recast\nbindings"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://www.critterai.org/projects/nmgen_study/"}),"Study: Navigation Mesh\nGeneration"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://www.stevefsp.org/projects/rcndoc/prod/index.html"}),"Documentation of C++ Recast\nlibrary")," It\ncan be useful for tracing bugs."))))}u.isMDXComponent=!0},441:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return d}));var a=n(0),i=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),u=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l({},t,{},e)),n},p=function(e){var t=u(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},h=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(n),h=a,d=p["".concat(r,".").concat(h)]||p[h]||b[h]||o;return n?i.a.createElement(d,l({ref:t},c,{components:n})):i.a.createElement(d,l({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var c=2;c<o;c++)r[c]=n[c];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);