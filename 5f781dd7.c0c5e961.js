(window.webpackJsonp=window.webpackJsonp||[]).push([[116],{255:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return r})),t.d(n,"metadata",(function(){return a})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return d}));var o=t(1),i=t(9),s=(t(0),t(441)),r={},a={id:"spidermonkey/migration",title:"migration",description:"::: {.warning}",source:"@site/docs/spidermonkey/migration.md",permalink:"/wikidemo/docs/spidermonkey/migration",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/spidermonkey/migration.md"},c=[{value:"Package/Class Imports",id:"packageclass-imports",children:[]},{value:"Client and MessageListener",id:"client-and-messagelistener",children:[{value:"MessageListener",id:"messagelistener",children:[]},{value:"Client method changes",id:"client-method-changes",children:[]},{value:"No IOExceptions",id:"no-ioexceptions",children:[]}]},{value:"Message.getClient() and Message.getConnection()",id:"messagegetclient-and-messagegetconnection",children:[]},{value:"Client ID and Player ID",id:"client-id-and-player-id",children:[]},{value:"com.jme3.network.event.ConnectionListener",id:"comjme3networkeventconnectionlistener",children:[]}],l={rightToc:c};function d(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(s.b)("wrapper",Object(o.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(s.b)("p",null,"::: {.warning}\nThis article covers how to move away from an older, deprecated API! If\nyou just start with JME3 networking, see\n",Object(s.b)("a",Object(o.a)({parentName:"p"},{href:"../jme3/advanced/networking"}),"networking")," for current documentation.\n:::"),Object(s.b)("p",null,"This document provides an overview of the new versus the old\nSpiderMonkey API, and a path for migrating from the old, now deprecated,\nAPI to the newer version. Much has changed. The ",Object(s.b)("a",Object(o.a)({parentName:"p"},{href:"../spidermonkey"}),"original\nSpiderMonkey")," implementation was a good concept and\na clever implementation but suffered under the weight of rapid patches\nand some creeping design deficit. In the end, there were enough small\nproblems, long-term maintenance issues, and limitations that a newer\ndesign was warranted. Some things will be very similar but others have\nchanged very much. Hopefully for the better."),Object(s.b)("h1",{id:"overview"},"Overview"),Object(s.b)("p",null,"Most of the new SpiderMonkey API now exists as a set of interfaces and\nhelper classes in the \\'com.jme3.network\\' package. For most users, this\npackage and the \\'message\\' package will be all they need to worry\nabout. The \\'base\\' and \\'kernel\\' packages only come into play when\nimplementing custom network transports or alternate client/server\nprotocols (",Object(s.b)("em",{parentName:"p"},"which are now possible"),"). Clients and Servers can be created\nfrom the factory methods on the Network helper class. Once a Server\ninstance is created and started, it can accept remote connections from\nClients. The Client objects represent the client-side of a client\u2192server\nconnection. Within the Server, these are HostedConnections. This is a\ndistinct change from the old API."),Object(s.b)("p",null,"+----------------------+----------------------+-----------------------+\n| Client               |                      | Server                |\n+======================+======================+=======================+\n| com                  | \u2190\u2192                   | com.jme3.net          |\n| .jme3.network.Client |                      | work.HostedConnection |\n+----------------------+----------------------+-----------------------+"),Object(s.b)("p",null,"HostedConnections can hold application defined client-specific session\nattributes that the server-side listeners and services can use to track\nplayer information, etc.. MessageListeners can be registered with either\nthe Client or the Server to be notified when new messages arrive. As\nbefore, these listeners can be registered to be notified about only\nspecific types of messages. ClientStateListeners can be registered with\na Client to detect changes in connection state. ConnectionListeners can\nbe registered with a Server to be notified about HostedConnection\narrivals and removals."),Object(s.b)("h1",{id:"whats-gone"},"What's Gone?"),Object(s.b)("p",null,"All of \\'connection\\', \\'events\\', \\'queue\\', \\'service\\',\n\\'streaming\\', and \\'sync\\' are now deprecated. The \\'service\\',\n\\'streaming\\', and \\'sync\\' packages were too difficult to easily port\nto the new API and would have required additional code review for\nthread-related issues. Since the service manager model has ",Object(s.b)("em",{parentName:"p"},"not")," been\nported and will likely live on in a different way, it was better to let\nthese go until better solutions evolve. For example, streaming is\nprobably better done more tightly integrated with the core API and as\nactual java.io streams."),Object(s.b)("h1",{id:"migration"},"Migration"),Object(s.b)("h2",{id:"packageclass-imports"},"Package/Class Imports"),Object(s.b)("p",null,"As a first pass, use the following table for conversion and then see\nspecific class notes."),Object(s.b)("p",null,"+-----------------------------------+-----------------------------------+\n| Old Class                         | New Class                         |\n+===================================+===================================+\n| c                                 | com.jme3.network.Client or        |\n| om.jme3.network.connection.Client | com.jme3.network.HostedConnection |\n+-----------------------------------+-----------------------------------+\n| c                                 | com.jme3.network.Server           |\n| om.jme3.network.connection.Server |                                   |\n+-----------------------------------+-----------------------------------+\n| com.j                             | com.jme3.network.MessageListener  |\n| me3.network.event.MessageListener |                                   |\n+-----------------------------------+-----------------------------------+\n| com.jme3                          | com                               |\n| .network.event.ConnectionListener | .jme3.network.ClientStateListener |\n|                                   | or                                |\n|                                   | co                                |\n|                                   | m.jme3.network.ConnectionListener |\n+-----------------------------------+-----------------------------------+\n| com.                              | no equivalent class, implement    |\n| jme3.network.event.MessageAdapter | MessageListener directly          |\n+-----------------------------------+-----------------------------------+\n| com.jme                           | no equivalent class, implement    |\n| 3.network.event.ConnectionAdapter | ClientStateListener or            |\n|                                   | ConnectionListener directly       |\n+-----------------------------------+-----------------------------------+\n| com.jme3.network.message.Message  | if used as a reference and not a  |\n|                                   | superclass,                       |\n|                                   | com.jme3.network.Message. The     |\n|                                   | base class stays the same for     |\n|                                   | message subclasses.               |\n+-----------------------------------+-----------------------------------+"),Object(s.b)("p",null,"Doing all of those changes will certainly break your build... so now\nlet's fix it."),Object(s.b)("h2",{id:"client-and-messagelistener"},"Client and MessageListener"),Object(s.b)("p",null,"This class is the hardest migration to perform. Do not get discouraged.\nThe old version used com.jme3.network.connection.Client for both client\nside and server side. So, depending on context, these references will\neither change to com.jme3.network.Client or\ncom.jme3.network.HostedConnection. In the case where calling code is not\nclient or server specific, then there is also the common\ncom.jme3.network.MessageConnection interface. In general, the actual\nclient changes are of one of the following to types:"),Object(s.b)("pre",null,Object(s.b)("code",Object(o.a)({parentName:"pre"},{className:"language-java"}),"  Client client = new Client( host, port );\n  ...becomes...\n  Client client = Network.connectToServer( host, port );\n")),Object(s.b)("p",null,"In the delayed connection case:"),Object(s.b)("pre",null,Object(s.b)("code",Object(o.a)({parentName:"pre"},{className:"language-java"}),"  Client client = new Client();\n  ...\n  client.connect( host, port );\n  ...becomes...\n  NetworkClient client = Network.createClient();\n  ...\n  client.connectToServer( host, port );\n")),Object(s.b)("p",null,"NetworkClient is a Client. The rest of your code can just refer to\nClient. Those are the easy changes. The trickier ones are related to the\nMessageListeners."),Object(s.b)("h3",{id:"messagelistener"},"MessageListener"),Object(s.b)("p",null,"By now you've figured out that all of your MessageListeners are broken\nbecause the new method signature is different. The source of a message\nis no longer stored with the message and is instead provided to the\nMessageListener. Depending on whether your MessageListener is being\nadded to the Client or the Server, it will need to refer to either\ncom.jme3.network.Client or com.jme3.network.HostedConnection in its\nmessageReceived(), respectively. The MessageListener interface is\ngenerically typed to help make sure the right listener goes where it's\nsupposed to and so the listener implementations don't have to cast all\nthe time."),Object(s.b)("pre",null,Object(s.b)("code",Object(o.a)({parentName:"pre"},{className:"language-java"}),"// An example client-specific listener\npublic class MyClientListener implements MessageListener<Client> {\n    public void messageReceived( Client source, Message m ) {\n       ...do stuff...\n    }\n}\n// And example server-specific listener\npublic class MyServerListener implements MessageListener<HostedConnection> {\n    public void messageReceived( HostedConnection source, Message m ) {\n        ...do stuff...\n    }\n}\n// A client or server listener\npublic class MyGenericListener implements MessageListener<MessageConnection> {\n    public void messageReceived( MessageConnection source, Message m ) {\n        ... do limited stuff....\n    }\n}\n")),Object(s.b)("p",null,"Your listeners will fall into one of those three categories."),Object(s.b)("p",null,"::: {.note}\nSeveral of the old MessageListener's methods have gone away. The\nobject-based methods didn't fit with the new API and messageSent()\nseemed of little utility. It could be resurrected if there is demand.\n:::"),Object(s.b)("h3",{id:"client-method-changes"},"Client method changes"),Object(s.b)("p",null,"Some of the methods on the old Client class have changed or been\nremoved. Here is a basic summary:"),Object(s.b)("p",null,"+-----------------------------------+-----------------------------------+\n| Old Method                        | New Method                        |\n+===================================+===================================+\n| Client.disconnect()               | Client.close() or                 |\n|                                   | HostedConnection.close(reason)    |\n+-----------------------------------+-----------------------------------+\n| Client.kick(reason)               | HostedConnection.close(reason)    |\n+-----------------------------------+-----------------------------------+\n| Client.getClientID()              | Client.getId() or                 |\n|                                   | HostedConnection.getId()          |\n+-----------------------------------+-----------------------------------+\n| Client.get/setPlayerID()          | no equivalent                     |\n+-----------------------------------+-----------------------------------+\n| Client.get/setLabel()             | no equivalent                     |\n+-----------------------------------+-----------------------------------+"),Object(s.b)("h3",{id:"no-ioexceptions"},"No IOExceptions"),Object(s.b)("p",null,"After you've done all of that, the compiler will be complaining about\nthe fact that send(), broadcast(), etc. no longer throw IOException. So\nremove all of those try/catch blocks."),Object(s.b)("p",null,"::: {.note}\nThe truth is that even in the old API, expecting a real IOException from\nthese methods was unreasonable because often times the message was\nqueued and actually sent later by a separate thread. The new API assumes\nthat all underlying transports will operate this way and so forgoes the\nartificial annoyance or sense of security provided by these \\'throws\\'\nclauses. It also simplifies the calling code a great deal.\n:::"),Object(s.b)("p",null,"Only API methods that actually perform direct IO (such as the\nNetwork.connectToServer() and NetworkClient.connectToServer() methods)\nwill ever be declared to throw IOException."),Object(s.b)("h2",{id:"messagegetclient-and-messagegetconnection"},"Message.getClient() and Message.getConnection()"),Object(s.b)("p",null,"This is important enough to deserve its own sub-heading because your\ncode ",Object(s.b)("strong",{parentName:"p"},"will")," break if you use these as they now return null. Any reason\nfor calling them is now provided directly to the MessageListener in the\nform of the source Client or source HostedConnection."),Object(s.b)("h2",{id:"client-id-and-player-id"},"Client ID and Player ID"),Object(s.b)("p",null,"The ID of the Client and HostedConnection are now the same at both ends\nof a connection and the ID is given out authoritatively by the hosting\nServer. This removes some of the inconsistency on when to use the old\nplayer ID and when to use the old client ID as the new client ID serves\nboth purposes. This leaves the game to be able to define its own player\nID based on whatever user criteria it wants."),Object(s.b)("p",null,"::: {.note}\nMany of the reasons for accessing the client ID on the server can now be\ntaken care of using the session attributes on HostedConnection. It seems\nlike a common use-case for these IDs was to look-up\nplayer/client-specific information in a java.util.Map. This information\ncan now be set directly on the HostedConnection.\n:::"),Object(s.b)("h2",{id:"comjme3networkeventconnectionlistener"},"com.jme3.network.event.ConnectionListener"),Object(s.b)("p",null,"Along with the shift from not using the same object at both ends of the\nclient connection was a shift in the interfaces that are notified about\nthose ends. On the client, there is now\ncom.jme3.network.ClientStateListener which is notified when the client\nfully connects to the server (including any internal handshaking) and\nwhen the client is disconnected. On the server,\ncom.jme3.network.ConnectionListener will be notified whenever new\nHostedConnections are added or removed. This listener isn't notified\nuntil the connection is fully setup (including any internal\nhandshaking)."),Object(s.b)("p",null,"+-----------------------------------+-----------------------------------+\n| Old Method                        | New Method                        |\n+===================================+===================================+\n| clientConnected(Client)           | connect                           |\n|                                   | ionAdded(Server,HostedConnection) |\n+-----------------------------------+-----------------------------------+\n| clientDisconnected(Client)        | connectio                         |\n|                                   | nRemoved(Server,HostedConnection) |\n+-----------------------------------+-----------------------------------+"),Object(s.b)("h1",{id:"why-am-i-doing-this-again"},"Why am I doing this again?"),Object(s.b)("p",null,"As you've seen above, there are quite a few changes necessary to migrate\nto the new API. You might be asking yourself if it's worth the trouble.\nThe bottom line is that the old architecture had threading and stability\nissues that just couldn't be fixed in any reasonable way. Some were\nminor, others kind of severe... and they combined to make trouble. If\nyou've ever wondered why sometimes your clients connect and then the\nnetwork connection hangs or stops sending data. Or if you've ever\nwondered why UDP/unreliable messages get corrupted or somehow won't\ndeserialize properly then you've run into some of these issues.\nMoreover, the lack of thread safety meant that user code sometimes had\nto do some strange and/or complicated work-arounds. The goal should be\nthat the API should just work like it looks like it will with a minimum\nof hassle. The new architecture is built from the ground up for\nthreading stability and for a clean separation between the public API,\nthe message passing layer, and the underlying network transport\nimplementations. You should be able to throw all kinds of stuff at it\nthat would make the old system fall over and it should just hum along.\nThere will certainly be some growing pains as we work the kinks out of\nthe new system but it is already much more stable in even the most basic\nof stress tests."))}d.isMDXComponent=!0},441:function(e,n,t){"use strict";t.d(n,"a",(function(){return h})),t.d(n,"b",(function(){return p}));var o=t(0),i=t.n(o);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,o,i=function(e,n){if(null==e)return{};var t,o,i={},s=Object.keys(e);for(o=0;o<s.length;o++)t=s[o],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)t=s[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=i.a.createContext({}),d=function(e){var n=i.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):a({},n,{},e)),t},h=function(e){var n=d(e.components);return i.a.createElement(l.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return i.a.createElement(i.a.Fragment,{},n)}},u=Object(o.forwardRef)((function(e,n){var t=e.components,o=e.mdxType,s=e.originalType,r=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),h=d(t),u=o,p=h["".concat(r,".").concat(u)]||h[u]||m[u]||s;return t?i.a.createElement(p,a({ref:n},l,{components:t})):i.a.createElement(p,a({ref:n},l))}));function p(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var s=t.length,r=new Array(s);r[0]=u;var a={};for(var c in n)hasOwnProperty.call(n,c)&&(a[c]=n[c]);a.originalType=e,a.mdxType="string"==typeof e?e:o,r[1]=a;for(var l=2;l<s;l++)r[l]=t[l];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"}}]);