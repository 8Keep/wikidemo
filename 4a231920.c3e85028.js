(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{231:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return p}));var a=n(1),i=n(9),o=(n(0),n(441)),r={},l={id:"jme3/math",title:"math",description:"It's a fact of life, math is hard. Unfortunately, 3D graphics require a",source:"@site/docs/jme3/math.md",permalink:"/wikidemo/docs/jme3/math",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/math.md",sidebar:"main",previous:{title:"math",permalink:"/wikidemo/docs/jme3/intermediate/math"},next:{title:"rotate",permalink:"/wikidemo/docs/jme3/rotate"}},s=[{value:"Definition",id:"definition",children:[]},{value:"Homogenous coordinates",id:"homogenous-coordinates",children:[]},{value:"Fundamental Types",id:"fundamental-types",children:[]},{value:"Definition",id:"definition-1",children:[]},{value:"jME Class",id:"jme-class",children:[]},{value:"Definition",id:"definition-2",children:[]},{value:"Transformations",id:"transformations-1",children:[{value:"Scaling",id:"scaling",children:[]},{value:"Rotation",id:"rotation",children:[]},{value:"Translation",id:"translation",children:[]}]},{value:"jME Class",id:"jme-class-1",children:[]},{value:"Definition",id:"definition-3",children:[]},{value:"Operations",id:"operations",children:[{value:"Multiplication by Scalar",id:"multiplication-by-scalar",children:[]},{value:"Addition and Subtraction",id:"addition-and-subtraction",children:[]},{value:"Magnitude",id:"magnitude",children:[]},{value:"Dot Products",id:"dot-products",children:[]},{value:"Cross Product",id:"cross-product",children:[]},{value:"jME Class",id:"jme-class-2",children:[]}]},{value:"Definition",id:"definition-4",children:[]},{value:"Angle Axis",id:"angle-axis",children:[{value:"Example - Rotate a Spatial Using fromAngleAxis",id:"example---rotate-a-spatial-using-fromangleaxis",children:[]}]},{value:"Three Angles",id:"three-angles",children:[{value:"Example - Rotate a Spatial Using fromAngles",id:"example---rotate-a-spatial-using-fromangles",children:[]}]},{value:"Three Axes",id:"three-axes",children:[{value:"Example - Rotate a Spatial Using fromAxes",id:"example---rotate-a-spatial-using-fromaxes",children:[]}]},{value:"Rotation Matrix",id:"rotation-matrix",children:[{value:"Example - Rotate a Spatial Using a Rotation Matrix",id:"example---rotate-a-spatial-using-a-rotation-matrix",children:[]}]},{value:"Slerp",id:"slerp",children:[{value:"Example - Use Slerp to Rotate Between two Quaternions",id:"example---use-slerp-to-rotate-between-two-quaternions",children:[]}]},{value:"Multiplication",id:"multiplication",children:[{value:"Utility Classes",id:"utility-classes",children:[]}]},{value:"Definition",id:"definition-5",children:[]},{value:"Usage",id:"usage",children:[{value:"Trig Functions",id:"trig-functions",children:[]},{value:"Numerical Methods",id:"numerical-methods",children:[]},{value:"Linear Algebra",id:"linear-algebra",children:[]},{value:"Geometric Functions",id:"geometric-functions",children:[]},{value:"Misc.",id:"misc",children:[]}]},{value:"Definition",id:"definition-6",children:[]},{value:"Usage",id:"usage-1",children:[]},{value:"Example 1 - Find a Random Point on a Line",id:"example-1---find-a-random-point-on-a-line",children:[]},{value:"Definition",id:"definition-7",children:[]},{value:"Usage in jME",id:"usage-in-jme",children:[]},{value:"Example 1 - Determining if a Point is On the Positive Side of a Plane",id:"example-1---determining-if-a-point-is-on-the-positive-side-of-a-plane",children:[]},{value:"Example 2 - For the Layperson",id:"example-2---for-the-layperson",children:[]},{value:"Definition",id:"definition-8",children:[]},{value:"Example 1 - Create a Ray That Represents Where the Camera is Looking",id:"example-1---create-a-ray-that-represents-where-the-camera-is-looking",children:[]},{value:"Definition",id:"definition-9",children:[]},{value:"jME Usage",id:"jme-usage",children:[]},{value:"Example 1 : Define a Rectangle and Get a Point From It",id:"example-1--define-a-rectangle-and-get-a-point-from-it",children:[]},{value:"Definition",id:"definition-10",children:[]},{value:"Usage",id:"usage-2",children:[]},{value:"Example 1 - Creating a Triangle",id:"example-1---creating-a-triangle",children:[{value:"Tips and Tricks",id:"tips-and-tricks",children:[]}]},{value:"See Also",id:"see-also",children:[]}],c={rightToc:s};function p(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"It's a fact of life, math is hard. Unfortunately, 3D graphics require a\nfair bit of knowledge about the subject. Fortunately, jME is able to\nhide the majority of the details away from the user. Vectors are the\nfundamental type in the 3D environment, and it is used extensively.\nMatrices are also a basic necessity of 3D for representing linear\nsystems. ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../jme3/quaternion"}),"Quaternions")," are perhaps the most\npowerful and complicated of the basic types and are used for rotation in\njME."),Object(o.b)("p",null,"I'll discuss how these are used in the system for the core\nfunctionality. Including Transforming, Visibility Determination,\nCollision Detection, and the Coordinate System. Note, that these are low\nlevel details. Further chapters will discuss how to use these various\nsystems from a high level perspective."),Object(o.b)("p",null,"To get a visual introduction to math in jME3 for the absolute beginner,\ncheck out our ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../jme3/math_for_dummies"}),"Math for Dummies"),"\nintroduction class."),Object(o.b)("h1",{id:"coordinate-system"},"Coordinate System"),Object(o.b)("h2",{id:"definition"},"Definition"),Object(o.b)("p",null,"A ",Object(o.b)("em",{parentName:"p"},"coordinate system")," consists of an origin (single point in space) and\nthree coordinate axes that are each unit length and mutually\nperpendicular. The axes can be written as the column of a Matrix, R =\n","[","U1","|","U2","|","U3","]",". In fact, this is exactly how CameraNode works. The\ncoordinate system defined by Camera is stored in a Matrix."),Object(o.b)("p",null,"jME uses a Right-Handed coordinate system (as OpenGL does)."),Object(o.b)("p",null,"The definition of a coordinate system is defined in jME by the\nproperties sent to Camera. There are no error checks to insure that: 1)\nthe coordinate system is right-handed and 2) The axes are mutually\nperpendicular. Therefore, if the user sets the axes incorrectly, they\nare going to experience very odd rendering artifacts (random culling,\netc)."),Object(o.b)("p",null,Object(o.b)("img",Object(a.a)({parentName:"p"},{src:"../jme3/intermediate/coordinate-system.png",alt:"coordinate-system.png"}))),Object(o.b)("h2",{id:"homogenous-coordinates"},"Homogenous coordinates"),Object(o.b)("p",null,"Homogenous coordinates have an additional ",Object(o.b)("em",{parentName:"p"},"W")," value tacked on to the\nend. The XYZ values are to be divided by W to give the true coordinates."),Object(o.b)("p",null,"This has several advantages, one technical, some relevant to application\nprogrammers:"),Object(o.b)("p",null,"Technically, it simplifies some formulae used inside the vector math.\nFor example, some operations need to apply the same factor to the XYZ\ncoordinates. Chain multiple operations of that kind (and vector math\ntends to do that), and you can save a lot of multiplications by simply\nkeeping the scaling factor around and doing the multiplication to XYZ at\nthe end of the pipeline, in the 3D card (which does accept homogenous\ncoordinates). It also simplifies some formulae, in particular anything\nthat is related to rotations."),Object(o.b)("p",null,"For application programmers, this means you can express infinitely long\nvectors that still have a direction - these tend to be used in lighting.\nJust use a W value of 0.0."),Object(o.b)("h1",{id:"transformations"},"Transformations"),Object(o.b)("p",null,"Transformations define an operation that converts points from one\ncoordinate system to another. This includes translation, rotation and\nscaling. In jME, local transforms are used to represent the positioning\nof objects relative to a parent coordinate system. While, world\ntransforms are used to represent the positioning of objects in a global\ncoordinate system."),Object(o.b)("h1",{id:"visibility-determination"},"Visibility Determination"),Object(o.b)("p",null,"Visibility Determination concerns itself with minimizing the amount of\ndata that is sent to the graphics card for rendering. Specifically, we\ndo not want to send data that will not be seen. Data not sent to the\ngraphics card is said to be culled. The primary focus of this section is\nFrustum Culling based on the Camera's view frustum. In essence, this\nfrustum creates six standard view planes. The BoundingVolume of an\nobject is tested against the frustum planes to determine if it is\ncontained in the frustum. If at any point the object's bounding is\noutside of the plane, it is tossed out and no longer processed for\nrendering. This also includes any children that it managed, allowing\nfast culling of large sections of the scene."),Object(o.b)("h2",{id:"fundamental-types"},"Fundamental Types"),Object(o.b)("h1",{id:"colorrgba"},"ColorRGBA"),Object(o.b)("h2",{id:"definition-1"},"Definition"),Object(o.b)("p",null,"ColorRGBA defines a color value in the jME library. The color value is\nmade of three components, red, green and blue. A fourth component\ndefines the alpha value (transparent) of the color. Every value is set\nbetween ","[","0, 1","]",". Anything less than 0 will be clamped to 0 and anything\ngreater than 1 will be clamped to 1."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note:"),' If you would like to "convert" an ordinary RGB value (0-255)\nto the format used here (0-1), simply multiply it with: 1/255.'),Object(o.b)("h2",{id:"jme-class"},"jME Class"),Object(o.b)("p",null,"ColorRGBA defines a few static color values for ease of use. That is,\nrather than:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"ColorRGBA red = new ColorRGBA(1,0,0,1);\nobject.setSomeColor(red);\n")),Object(o.b)("p",null,"you can simply say:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"object.setSomeColor(ColorRGBA.red)\n")),Object(o.b)("p",null,"ColorRGBA will also handle interpolation between two colors. Given a\nsecond color and a value between 0 and 1, a the owning ColorRGBA object\nwill have its color values altered to this new interpolated color."),Object(o.b)("h1",{id:"matrix"},"Matrix"),Object(o.b)("p",null,"See ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"%7Blink-javadoc%7D/com/jme3/math/Matrix3f.html"}),"Matrix3f Javadoc")," and\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"%7Blink-javadoc%7D/com/jme3/math/Matrix4f.html"}),"Matrix4f Javadoc")),Object(o.b)("h2",{id:"definition-2"},"Definition"),Object(o.b)("p",null,"A Matrix is typically used as a ",Object(o.b)("em",{parentName:"p"},"linear transformation")," to map vectors\nto vectors. That is: Y = MX where X is a Vector and M is a Matrix\napplying any or all transformations (scale,\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../jme3/rotate"}),"rotate"),", translate)."),Object(o.b)("p",null,"There are a few special matrices:"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"zero matrix")," is the Matrix with all zero entries."),Object(o.b)("p",null,"+----------------------+----------------------+-----------------------+\n| 0                    | 0                    | 0                     |\n+======================+======================+=======================+\n| 0                    | 0                    | 0                     |\n+----------------------+----------------------+-----------------------+\n| 0                    | 0                    | 0                     |\n+----------------------+----------------------+-----------------------+"),Object(o.b)("p",null,"The ",Object(o.b)("em",{parentName:"p"},"Identity Matrix")," is the matrix with 1 on the diagonal entries and 0\nfor all other entries."),Object(o.b)("p",null,"+----------------------+----------------------+-----------------------+\n| 1                    | 0                    | 0                     |\n+======================+======================+=======================+\n| 0                    | 1                    | 0                     |\n+----------------------+----------------------+-----------------------+\n| 0                    | 0                    | 1                     |\n+----------------------+----------------------+-----------------------+"),Object(o.b)("p",null,"A Matrix is ",Object(o.b)("em",{parentName:"p"},"invertible")," if there is a matrix ",Object(o.b)("em",{parentName:"p"},"M^-1^")," where ",Object(o.b)("em",{parentName:"p"},"MM^-1^ =\nM^-1^M = I"),"."),Object(o.b)("p",null,"The ",Object(o.b)("em",{parentName:"p"},"transpose")," of a matrix ",Object(o.b)("em",{parentName:"p"},"M = ","[","m~ij~","]")," is ",Object(o.b)("em",{parentName:"p"},"M^T^ = ","[","m~ji~","]"),". This\ncauses the rows of ",Object(o.b)("em",{parentName:"p"},"M")," to become the columns of ",Object(o.b)("em",{parentName:"p"},"M^T^"),"."),Object(o.b)("p",null,"+---------+---------+---------+---------+---------+---------+---------+\n| 1       | 1       | 1       |         | 1       | 2       | 3       |\n+=========+=========+=========+=========+=========+=========+=========+\n| 2       | 2       | 2       | \u21d2       | 1       | 2       | 3       |\n+---------+---------+---------+---------+---------+---------+---------+\n| 3       | 3       | 3       |         | 1       | 2       | 3       |\n+---------+---------+---------+---------+---------+---------+---------+"),Object(o.b)("p",null,"A Matrix is symmetric if ",Object(o.b)("em",{parentName:"p"},"M")," = ",Object(o.b)("em",{parentName:"p"},"M^T^"),"."),Object(o.b)("p",null,"+----------------------+----------------------+-----------------------+\n| X                    | A                    | B                     |\n+======================+======================+=======================+\n| A                    | X                    | C                     |\n+----------------------+----------------------+-----------------------+\n| B                    | C                    | X                     |\n+----------------------+----------------------+-----------------------+"),Object(o.b)("p",null,"Where X, A, B, and C equal numbers"),Object(o.b)("p",null,"jME includes two types of Matrix classes: Matrix3f and Matrix4f.\nMatrix3f is a 3x3 matrix and is the most commonly used (able to handle\nscaling and rotating), while Matrix4f is a 4x4 matrix that can also\nhandle translation."),Object(o.b)("h2",{id:"transformations-1"},"Transformations"),Object(o.b)("p",null,"Multiplying a vector with a Matrix allows the vector to be transformed.\nEither rotating, scaling or translating that vector."),Object(o.b)("h3",{id:"scaling"},"Scaling"),Object(o.b)("p",null,"If a ",Object(o.b)("em",{parentName:"p"},"diagonal Matrix"),", defined by D = ","[","d~ij~","]"," and d~ij~ = 0 for i !=\nj, has all positive entries it is a ",Object(o.b)("em",{parentName:"p"},"scaling matrix"),". If d~i~ is greater\nthan 1 then the resulting vector will grow, while if d~i~ is less than 1\nit will shrink."),Object(o.b)("h3",{id:"rotation"},"Rotation"),Object(o.b)("p",null,"A ",Object(o.b)("em",{parentName:"p"},"rotation matrix")," requires that the transpose and inverse are the same\nmatrix (R^-1^ = R^T^). The ",Object(o.b)("em",{parentName:"p"},"rotation matrix")," R can then be calculated\nas: R = I + (sin(angle)) S + (1 - cos(angle)S^2^ where S is:"),Object(o.b)("p",null,"+----------------------+----------------------+-----------------------+\n| 0                    | u~2~                 | -u~1~                 |\n+======================+======================+=======================+\n| -u~2~                | 0                    | u~0~                  |\n+----------------------+----------------------+-----------------------+\n| u~1~                 | -u~0~                | 0                     |\n+----------------------+----------------------+-----------------------+"),Object(o.b)("h3",{id:"translation"},"Translation"),Object(o.b)("p",null,"Translation requires a 4x4 matrix, where the vector (x,y,z) is mapped to\n(x,y,z,1) for multiplication. The ",Object(o.b)("em",{parentName:"p"},"Translation Matrix")," is then defined\nas:"),Object(o.b)("p",null,"+-----------------------------------+-----------------------------------+\n| M                                 | T                                 |\n+===================================+===================================+\n| S^T^                              | 1                                 |\n+-----------------------------------+-----------------------------------+"),Object(o.b)("p",null,"where M is the 3x3 matrix (containing any rotation/scale information), T\nis the translation vector and S^T^ is the transpose Vector of T. 1 is\njust a constant."),Object(o.b)("h2",{id:"jme-class-1"},"jME Class"),Object(o.b)("p",null,"Both Matrix3f and Matrix4f store their values as floats and are publicly\navailable as (m00, m01, m02, ..., mNN) where N is either 2 or 3."),Object(o.b)("p",null,"Most methods are straight forward, and I will leave documentation to the\nJavadoc."),Object(o.b)("h1",{id:"vector"},"Vector"),Object(o.b)("p",null,"See ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"%7Blink-javadoc%7D/com/jme3/math/Vector3f.html"}),"Vector3f Javadoc")," and\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"%7Blink-javadoc%7D/com/jme3/math/Vector2f.html"}),"Vector2f Javadoc")),Object(o.b)("h2",{id:"definition-3"},"Definition"),Object(o.b)("p",null,"Vectors are used to represent a multitude of things in jME, points in\nspace, vertices in a triangle mesh, normals, etc. These classes\n(Vector3f in particular) are probably the most used class in jME."),Object(o.b)("p",null,"A Vector is defined by an n-tuple of real numbers. ",Object(o.b)("strong",{parentName:"p"},"V")," = \\<V~1~,\nV~2~,..., V~n~",">","."),Object(o.b)("p",null,"We have two Vectors (2f and 3f) meaning we have tuples of 2 float values\nor 3 float values."),Object(o.b)("h2",{id:"operations"},"Operations"),Object(o.b)("h3",{id:"multiplication-by-scalar"},"Multiplication by Scalar"),Object(o.b)("p",null,"A Vector can be multiplied by a scalar value to produce a second Vector\nwith the same proportions as the first. a",Object(o.b)("strong",{parentName:"p"},"V")," = ",Object(o.b)("strong",{parentName:"p"},"V"),"a = \\<aV~1~,\naV~2~,...,aV~n~",">"),Object(o.b)("h3",{id:"addition-and-subtraction"},"Addition and Subtraction"),Object(o.b)("p",null,"Adding or subtracting two Vectors occurs component-wise. That is the\nfirst component is added (subtracted) with the first component of the\nsecond Vector and so on."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"P")," + ",Object(o.b)("strong",{parentName:"p"},"Q")," = \\<P~1~+Q~1~, P~2~+Q~2~, ..., P~n~+Q~n~",">"),Object(o.b)("h3",{id:"magnitude"},"Magnitude"),Object(o.b)("p",null,"The ",Object(o.b)("em",{parentName:"p"},"magnitude")," defines the length of a Vector. A Vector of magnitude 1\nis ",Object(o.b)("em",{parentName:"p"},"unit length"),"."),Object(o.b)("p",null,"For example, if ",Object(o.b)("strong",{parentName:"p"},"V")," = (x, y, z), the magnitude is the square root of\n(x^2^ + y^2^ + z^2^)."),Object(o.b)("p",null,"A Vector can be ",Object(o.b)("em",{parentName:"p"},"normalized")," or made ",Object(o.b)("em",{parentName:"p"},"unit length")," by multiplying the\nVector by (1/magnitude)."),Object(o.b)("h3",{id:"dot-products"},"Dot Products"),Object(o.b)("p",null,"The dot product of two vectors is defined as: ",Object(o.b)("strong",{parentName:"p"},"P")," dot ",Object(o.b)("strong",{parentName:"p"},"Q")," = P~x~Q~x~"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"P~y~Q~y~ + P~z~Q~z~")),Object(o.b)("p",null,"Using the dot product allows us to determine how closely two Vectors are\npointing to the same point. If the dot product is negative they are\nfacing in relatively opposite directions, while postive tells us they\nare pointing in the relative same direction."),Object(o.b)("p",null,"If the dot product is 0 then the two Vectors are ",Object(o.b)("em",{parentName:"p"},"orthogonal")," or 90\ndegrees off."),Object(o.b)("h3",{id:"cross-product"},"Cross Product"),Object(o.b)("p",null,"The Cross Product of two Vectors returns a third Vector that is\nprependicular to the two Vectors. This is very useful for calculating\nsurface normals."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"P")," X ",Object(o.b)("strong",{parentName:"p"},"Q")," = \\<P~y~Q~z~ - P~z~Q~y~, P~z~Q~x~ - P~x~Q~z~, P~x~Q~y~ -\nP~y~Q~x~",">"),Object(o.b)("h3",{id:"jme-class-2"},"jME Class"),Object(o.b)("p",null,"Vector3f and Vector2f store their values (x, y, z) and (x, y)\nrespectively as floats. Most methods are straight forward, and I will\nleave documentation to the Javadoc."),Object(o.b)("h1",{id:"quaternion"},"Quaternion"),Object(o.b)("p",null,"See ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"%7Blink-javadoc%7D/com/jme3/math/Quaternion.html"}),"Quaternion Javadoc")),Object(o.b)("h2",{id:"definition-4"},"Definition"),Object(o.b)("p",null,"Quaternions define a subset of a hypercomplex number system. Quaternions\nare defined by (i^2^ = j^2^ = k^2^ = ijk = -1). jME makes use of\nQuaternions because they allow for compact representations of rotations,\nor correspondingly, orientations, in 3D space. With only four float\nvalues, we can represent an object's orientation, where a rotation\nmatrix would require nine. They also require fewer arithmetic operations\nfor concatenation."),Object(o.b)("p",null,"Additional benefits of the Quaternion is reducing the chance of ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://en.wikipedia.org/wiki/Gimbal_lock"}),"Gimbal\nLock")," and allowing for easily\ninterpolation between two rotations (spherical linear interpolation or\nslerp)."),Object(o.b)("p",null,"While Quaternions are quite difficult to fully understand, there are an\nexceeding number of convenience methods to allow you to use them without\nhaving to understand the math behind it. Basically, these methods\ninvolve nothing more than setting the Quaternion's x,y,z,w values using\nother means of representing rotations. The Quaternion is then contained\nin the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../jme3/advanced/spatial"}),"Spatial")," as its local rotation\ncomponent."),Object(o.b)("p",null,"Quaternion ",Object(o.b)("strong",{parentName:"p"},"q")," has the form"),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"q")," = \\<","_","w,x,y,z","_",">"," = ",Object(o.b)("em",{parentName:"p"},"w + xi + yj + zk")),Object(o.b)("p",null,"or alternatively, it can be written as:"),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"q")," = ",Object(o.b)("strong",{parentName:"p"},"s")," + ",Object(o.b)("strong",{parentName:"p"},"v"),", where ",Object(o.b)("strong",{parentName:"p"},"s")," represents the scalar part\ncorresponding to the w-component of ",Object(o.b)("strong",{parentName:"p"},"q"),", and ",Object(o.b)("strong",{parentName:"p"},"v")," represents the\nvector part of the (x, y, z) components of ",Object(o.b)("strong",{parentName:"p"},"q"),"."),Object(o.b)("p",null,"Multiplication of Quaternions uses the distributive law and adheres to\nthe following rules with multiplying the imaginary components (i, j, k):"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"i2 = j2 = k2 = -1"),"+ ",Object(o.b)("inlineCode",{parentName:"p"},"ij = -ji = k"),"+ ",Object(o.b)("inlineCode",{parentName:"p"},"jk = -kj = i"),"+ ",Object(o.b)("inlineCode",{parentName:"p"},"ki = -ik = j")),Object(o.b)("p",null,"However, Quaternion multiplication is ",Object(o.b)("em",{parentName:"p"},"not")," commutative, so we have to\npay attention to order."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"q~1~q~2~")," = s~1~s~2~ - ",Object(o.b)("strong",{parentName:"p"},"v~1~")," dot ",Object(o.b)("strong",{parentName:"p"},"v~2~")," + s~1~",Object(o.b)("strong",{parentName:"p"},"v~2~")," +\ns~2~",Object(o.b)("strong",{parentName:"p"},"v~1~")," + ",Object(o.b)("strong",{parentName:"p"},"v~1~")," X ",Object(o.b)("strong",{parentName:"p"},"v~2~")),Object(o.b)("p",null,"Quaternions also have conjugates where the conjugate of ",Object(o.b)("strong",{parentName:"p"},"q")," is (s -\n",Object(o.b)("strong",{parentName:"p"},"v"),")"),Object(o.b)("p",null,"These basic operations allow us to convert various rotation\nrepresentations to Quaternions."),Object(o.b)("h2",{id:"angle-axis"},"Angle Axis"),Object(o.b)("p",null,"You might wish to represent your rotations as Angle Axis pairs. That is,\nyou define a axis of rotation and the angle with which to\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../jme3/rotate"}),"rotate")," about this axis.\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../jme3/quaternion"}),"Quaternion")," defines a method ",Object(o.b)("inlineCode",{parentName:"p"},"fromAngleAxis"),"\n(and ",Object(o.b)("inlineCode",{parentName:"p"},"fromAngleNormalAxis"),") to create a Quaternion from this pair. This\nis acutally used quite a bit in jME demos to continually rotate objects.\nYou can also obtain a Angle Axis rotation from an existing Quaternion\nusing ",Object(o.b)("inlineCode",{parentName:"p"},"toAngleAxis"),"."),Object(o.b)("h3",{id:"example---rotate-a-spatial-using-fromangleaxis"},"Example - Rotate a Spatial Using fromAngleAxis"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"//rotate about the Y-Axis by approximately 1 pi\nVector3f axis = Vector3f.UNIT_Y;\n// UNIT_Y equals (0,1,0) and does not require to create a new object\nfloat angle = 3.14f;\ns.getLocalRotation().fromAngleAxis(angle, axis);\n")),Object(o.b)("h2",{id:"three-angles"},"Three Angles"),Object(o.b)("p",null,"You can also represent a rotation by defining three angles. The angles\nrepresent the rotation about the individual axes. Passing in a\nthree-element array of floats defines the angles where the first element\nis X, second Y and third is Z. The method provided by Quaternion is\n",Object(o.b)("inlineCode",{parentName:"p"},"fromAngles")," and can also fill an array using ",Object(o.b)("inlineCode",{parentName:"p"},"toAngles")),Object(o.b)("h3",{id:"example---rotate-a-spatial-using-fromangles"},"Example - Rotate a Spatial Using fromAngles"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"//rotate 1 radian on the x, 3 on the y and 0 on z\nfloat[] angles = {1, 3, 0};\ns.getLocalRotation().fromAngles(angles);\n")),Object(o.b)("h2",{id:"three-axes"},"Three Axes"),Object(o.b)("p",null,"If you have three axes that define your rotation, where the axes define\nthe left axis, up axis and directional axis respectively) you can make\nuse of ",Object(o.b)("inlineCode",{parentName:"p"},"fromAxes")," to generate the Quaternion. It should be noted that\nthis will generate a new ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../jme3/matrix"}),"Matrix")," object that is\nthen garbage collected, thus, this method should not be used if it will\nbe called many times. Again, ",Object(o.b)("inlineCode",{parentName:"p"},"toAxes")," will populate a Vector3f array."),Object(o.b)("h3",{id:"example---rotate-a-spatial-using-fromaxes"},"Example - Rotate a Spatial Using fromAxes"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"//rotate a spatial to face up ~45 degrees\nVector3f[] axes = new Vector3f[3];\naxes[0] = new Vector3f(-1, 0, 0); //left\naxes[1] = new Vector3f(0, 0.5f, 0.5f); //up\naxes[2] = new Vector3f(0, 0.5f, 0.5f); //dir\n\ns.getLocalRotation().fromAxes(axes);\n")),Object(o.b)("h2",{id:"rotation-matrix"},"Rotation Matrix"),Object(o.b)("p",null,"Commonly you might find yourself with a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../jme3/matrix"}),"Matrix"),"\ndefining a rotation. In fact, it's very common to contain a rotation in\na Matrix create a Quaternion, rotate the Quaternion, and then get the\nMatrix back. Quaternion contains a ",Object(o.b)("inlineCode",{parentName:"p"},"fromRotationMatrix")," method that will\ncreate the appropriate Quaternion based on the give Matrix. The\n",Object(o.b)("inlineCode",{parentName:"p"},"toRotationMatrix")," will populate a given Matrix."),Object(o.b)("h3",{id:"example---rotate-a-spatial-using-a-rotation-matrix"},"Example - Rotate a Spatial Using a Rotation Matrix"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"Matrix3f mat = new Matrix3f();\nmat.setColumn(0, new Vector3f(1,0,0));\nmat.setColumn(1, new Vector3f(0,-1,0));\nmat.setColumn(2, new Vector3f(0,0,1));\n\ns.getLocalRotation().fromRotationMatrix(mat);\n")),Object(o.b)("p",null,"As you can see there are many ways to build a Quaternion. This allows\nyou to work with rotations in a way that is conceptually easier to\npicture, but still build Quaternions for internal representation."),Object(o.b)("h2",{id:"slerp"},"Slerp"),Object(o.b)("p",null,"One of the biggest advantages to using Quaternions is allowing\ninterpolation between two rotations. That is, if you have an initial\nQuaternion representing the original orientation of an object, and you\nhave a final Quaternion representing the orientation you want the object\nto face, you can do this very smoothly with slerp. Simply supply the\ntime, where time is ","[","0, 1","]"," and 0 is the initial rotation and 1 is the\nfinal rotation."),Object(o.b)("h3",{id:"example---use-slerp-to-rotate-between-two-quaternions"},"Example - Use Slerp to Rotate Between two Quaternions"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"/*\nYou can interpolate rotations between two quaternions using spherical linear\ninterpolation (slerp).\n*/\nQuaternion Xroll45 = new Quaternion();\nXroll45.fromAngleAxis(45 * FastMath.DEG_TO_RAD, Vector3f.UNIT_X);\n//\nQuaternion Yroll45 = new Quaternion();\nYroll45.fromAngleAxis(45 * FastMath.DEG_TO_RAD, Vector3f.UNIT_Y);\n\n//the rotation half - way between these two\n\nQuaternion halfBetweenXroll45Yroll45 = new Quaternion();\nhalfBetweenXroll45Yroll45.slerp(Xroll45, Yroll45, 0.5f);\ngeom2.setLocalRotation(halfBetweenXroll45Yroll45);\n")),Object(o.b)("h2",{id:"multiplication"},"Multiplication"),Object(o.b)("p",null,"You can concatenate (add) rotations: This means you turn the object\nfirst around one axis, then around the other, in one step."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"Quaternion myRotation = pitch90.mult(roll45); /* pitch and roll */\n")),Object(o.b)("p",null,"To rotate a Vector3f around its origin by the Quaternion amount, use the\nmultLocal method of the Quaternion:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"Quaternion myRotation = pitch90;\nVector3f myVector = new Vector3f(0,0,-1);\nmyRotation.multLocal(myVector);\n")),Object(o.b)("h3",{id:"utility-classes"},"Utility Classes"),Object(o.b)("p",null,"Along with the base Math classes, jME provides a number of Math classes\nto make development easier (and, hopefully, faster). Most of these\nclasses find uses throughout the jME system internally. They can also\nprove beneficial to users as well."),Object(o.b)("h1",{id:"fast-math"},"Fast Math"),Object(o.b)("p",null,"See ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"%7Blink-javadoc%7D/com/jme3/math/FastMath.html"}),"FastMath Javadoc")),Object(o.b)("h2",{id:"definition-5"},"Definition"),Object(o.b)("p",null,"FastMath provides a number of convience methods, and where possible\nfaster versions (although this can be at the sake of accuracy)."),Object(o.b)("h2",{id:"usage"},"Usage"),Object(o.b)("p",null,"FastMath provides a number of constants that can help with general math\nequations. One important attribute is ",Object(o.b)("inlineCode",{parentName:"p"},"USE_FAST_TRIG")," if you set this to\ntrue, a look-up table will be used for trig functions rather than Java's\nstandard Math library. This provides significant speed increases, but\nmight suffer from accuracy so care should be taken."),Object(o.b)("p",null,"There are five major categories of functions that FastMath provides."),Object(o.b)("h3",{id:"trig-functions"},"Trig Functions"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"cos and acos - provide ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://en.wikipedia.org/wiki/cosine"}),"cosine"),"\nand ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Inverse_trigonometric_functions"}),"arc\ncosine"),"\nvalues (make use of the look-up table if ",Object(o.b)("inlineCode",{parentName:"p"},"USE_FAST_TRIG")," is true)")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"sin and asin - provide ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://en.wikipedia.org/wiki/sine"}),"sine")," and\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Inverse_trigonometric_functions"}),"arc\nsine"),"\nvalues (make use of the look-up table if ",Object(o.b)("inlineCode",{parentName:"p"},"USE_FAST_TRIG")," is true)")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"tan and atan - provide\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://en.wikipedia.org/wiki/tangent"}),"tangent")," and ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Inverse_trigonometric_functions"}),"arc\ntangent"),"\nvalues"))),Object(o.b)("h3",{id:"numerical-methods"},"Numerical Methods"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"ceil - provides the ceiling (smallest value that is greater than or\nequal to a given value and an integer)of a value.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"floor - provides the floor (largest value that is less than or equal\nto a given value and an integer) of a value.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"exp - provides the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://en.wikipedia.org/wiki/Euler_number"}),"euler\nnumber")," (e) raised to the\nprovided value.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"sqr - provides the square of a value (i.e. value ","*"," value).")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"pow - provides the first given number raised to the second.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"isPowerOfTwo - provides a boolean if a value is a power of two or\nnot (e.g. 32, 64, 4).")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"abs - provides the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://en.wikipedia.org/wiki/Absolute_value"}),"absolute\nvalue")," of a given\nnumber.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"sign - provides the sign of a value (1 if positive, -1 if negative,\n0 if 0).")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"log - provides the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://en.wikipedia.org/wiki/Natural_logarithm"}),"natural\nlogarithm")," of a\nvalue.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"sqrt - provides the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://en.wikipedia.org/wiki/Square_root"}),"square\nroot")," of a value.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"invSqrt - provides the inverse square root of a value (1 /\nsqrt(value)."))),Object(o.b)("h3",{id:"linear-algebra"},"Linear Algebra"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"LERP - calculate the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://en.wikipedia.org/wiki/Linear_interpolation"}),"linear\ninterpolation")," of\ntwo points given a time between 0 and 1.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"determinant - calculates the\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://en.wikipedia.org/wiki/determinant"}),"determinant")," of a 4x4\nmatrix."))),Object(o.b)("h3",{id:"geometric-functions"},"Geometric Functions"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"counterClockwise - given three points (defining a triangle), the\nwinding is determined. 1 if counter-clockwise, -1 if clockwise and 0\nif the points define a line.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"pointInsideTriangle - calculates if a point is inside a triangle.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"sphericalToCartesian - converts a point from ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Spherical_coordinate_system"}),"spherical\ncoordinates"),"\nto ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Cartesian"}),"cartesian coordinates"),".")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"cartesianToSpherical - converts a point from cartesian coordinates\nto ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Spherical_coordinate_system"}),"spherical\ncoordinates"),"."))),Object(o.b)("h3",{id:"misc"},"Misc."),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"newRandomFloat - obtains a random float.")),Object(o.b)("h1",{id:"line"},"Line"),Object(o.b)("p",null,"See ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"%7Blink-javadoc%7D/com/jme3/math/Line.html"}),"Line Javadoc")),Object(o.b)("h2",{id:"definition-6"},"Definition"),Object(o.b)("p",null,"A line is a straight one-dimensional figure having no thickness and\nextending infinitely in both directions. A line is defined by two points\n",Object(o.b)("strong",{parentName:"p"},"A")," and ",Object(o.b)("strong",{parentName:"p"},"B")," with the line passing through both."),Object(o.b)("h2",{id:"usage-1"},"Usage"),Object(o.b)("p",null,"jME defines a Line class that is defined by an origin and direction. In\nreality, this Line class is typically used as a ",Object(o.b)("em",{parentName:"p"},"line segment"),". Where\nthe line is finite and contained between these two points."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"random")," provides a means of generate a random point that falls on the\nline between the origin and direction points."),Object(o.b)("h2",{id:"example-1---find-a-random-point-on-a-line"},"Example 1 - Find a Random Point on a Line"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"Line l = new Line(new Vector3f(0,1,0), new Vector3f(3,2,1));\nVector3f randomPoint = l.random();\n")),Object(o.b)("h1",{id:"plane"},"Plane"),Object(o.b)("p",null,"See ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"%7Blink-javadoc%7D/com/jme3/math/Plane.html"}),"Plane Javadoc")),Object(o.b)("h2",{id:"definition-7"},"Definition"),Object(o.b)("p",null,"A plane is defined by the equation ",Object(o.b)("strong",{parentName:"p"},"N")," . (",Object(o.b)("strong",{parentName:"p"},"X")," - ",Object(o.b)("strong",{parentName:"p"},"X~0~"),") = 0 where\n",Object(o.b)("strong",{parentName:"p"},"N")," = (a, b, c) and passes through the point ",Object(o.b)("strong",{parentName:"p"},"X~0~")," = (x~0~, y~0~,\nz~0~). ",Object(o.b)("strong",{parentName:"p"},"X")," defines another point on this plane (x, y, z)."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"N")," . (",Object(o.b)("strong",{parentName:"p"},"X")," - ",Object(o.b)("strong",{parentName:"p"},"X~0~"),") = 0 can be described as (",Object(o.b)("strong",{parentName:"p"},"N")," . ",Object(o.b)("strong",{parentName:"p"},"X"),") +\n(",Object(o.b)("strong",{parentName:"p"},"N")," . -",Object(o.b)("strong",{parentName:"p"},"X~0~"),") = 0"),Object(o.b)("p",null,"or"),Object(o.b)("p",null,"(ax + by + cz) + (-ax~0~-by~0~-cz~0~) = 0"),Object(o.b)("p",null,"where (-ax~0~-by~0~-cz~0~) = d"),Object(o.b)("p",null,"Where d is the negative value of a point in the plane times the unit\nvector describing the orientation of the plane."),Object(o.b)("p",null,"This gives us the general equation: (ax + by + cz + d = 0)"),Object(o.b)("h2",{id:"usage-in-jme"},"Usage in jME"),Object(o.b)("p",null,"jME defines the Plane as ax + by + cz = -d. Therefore, during creation\nof the plane, the normal of the plane (a,b,c) and the constant d is\nsupplied."),Object(o.b)("p",null,"The most common usage of Plane is ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../jme3/advanced/camera"}),"Camera"),"\nfrustum planes. Therefore, the primary purpose of Plane is to determine\nif a point is on the positive side, negative side, or intersecting a\nplane."),Object(o.b)("p",null,"Plane defines the constants:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"NEGATIVE_SIDE")," - represents a point on the opposite side to which\nthe normal points.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"NO_SIDE")," - represents a point that lays on the plane itself.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"POSITIVE_SIDE")," - represents a point on the side to which the normal\npoints."))),Object(o.b)("p",null,"These values are returned on a call to ",Object(o.b)("inlineCode",{parentName:"p"},"whichSide"),"."),Object(o.b)("h2",{id:"example-1---determining-if-a-point-is-on-the-positive-side-of-a-plane"},"Example 1 - Determining if a Point is On the Positive Side of a Plane"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'Vector3f normal = new Vector3f(0,1,0);\nfloat constant = new Vector3f(1,1,1).dot(normal);\nPlane testPlane = new Plane(normal, constant);\n\nint side = testPlane.whichSide(new Vector3f(2,1,0));\n\nif(side == Plane.NO_SIDE) {\n   System.out.println("This point lies on the plane");\n}\n')),Object(o.b)("h2",{id:"example-2---for-the-layperson"},"Example 2 - For the Layperson"),Object(o.b)("p",null,"Using the standard constructor Plane(Vector3f normal, float constant),\nhere is what you need to do to create a plane, and then use it to check\nwhich side of the plane a point is on."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'package test;\n\nimport java.util.logging.Logger;\n\nimport com.jme.math.*;\n\n/**\n *@author Nick Wiggill\n */\n\npublic class TestPlanes\n{\n  public static final Logger logger = Logger.getLogger(LevelGraphBuilder.class.getName());\n\n  public static void main(String[] args) throws Exception\n  {\n    //***Outline.\n    //This example shows how to construct a plane representation using\n    //com.jme.math.Plane.\n    //We will create a very simple, easily-imagined 3D plane. It will\n    //be perpendicular to the x axis (it\'s facing). It\'s "centre" (if\n    //such a thing exists in an infinite plane) will be positioned 1\n    //unit along the positive x axis.\n\n    //***Step 1.\n    //The vector that represents the normal to the plane, in 3D space.\n    //Imagine a vector coming out of the origin in this direction.\n    //There is no displacement yet (see Step 2, below).\n    Vector3f normal = new Vector3f(5f,0,0);\n\n    //***Step 2.\n    //This is our displacement vector. The plane remains facing in the\n    //direction we\'ve specified using the normal above, but now we are\n    //are actually giving it a position other than the origin.\n    //We will use this displacement to define the variable "constant"\n    //needed to construct the plane. (see step 3)\n    Vector3f displacement = Vector3f.UNIT_X;\n    //or\n    //Vector3f displacement = new Vector3f(1f, 0, 0);\n\n    //***Step 3.\n    //Here we generate the constant needed to define any plane. This\n    //is semi-arcane, don\'t let it worry you. All you need to\n    //do is use this same formula every time.\n    float constant = displacement.dot(normal);\n\n    //***Step 4.\n    //Finally, construct the plane using the data you have assembled.\n    Plane plane = new Plane(normal, constant);\n\n    //***Some tests.\n    logger.info("Plane info: "+plane.toString()); //trace our plane\'s information\n\n    Vector3f p1  = new Vector3f(1.1f,0,0); //beyond the plane (further from origin than plane)\n    Vector3f p2  = new Vector3f(0.9f,0,0); //before the plane (closer to origin than plane)\n    Vector3f p3  = new Vector3f(1f,0,0); //on the plane\n\n    logger.info("p1 position relative to plane is "+plane.whichSide(p1)); //outputs NEGATIVE\n    logger.info("p2 position relative to plane is "+plane.whichSide(p2)); //outputs POSITIVE\n    logger.info("p3 position relative to plane is "+plane.whichSide(p3)); //outputs NONE\n  }\n}\n')),Object(o.b)("h1",{id:"ray"},"Ray"),Object(o.b)("p",null,"See ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"%7Blink-javadoc%7D/com/jme3/math/Ray.html"}),"Ray Javadoc")),Object(o.b)("h2",{id:"definition-8"},"Definition"),Object(o.b)("p",null,"Ray defines a line that starts at a point ",Object(o.b)("strong",{parentName:"p"},"A")," and continues in a\ndirection through ",Object(o.b)("strong",{parentName:"p"},"B")," into infinity."),Object(o.b)("p",null,"This Ray is used extensively in jME for\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../jme3/beginner/hello_picking"}),"Picking"),". A Ray is cast from a\npoint in screen space into the scene. Intersections are found and\nreturned. To create a ray supply the object with two points, where the\nfirst point is the origin."),Object(o.b)("h2",{id:"example-1---create-a-ray-that-represents-where-the-camera-is-looking"},"Example 1 - Create a Ray That Represents Where the Camera is Looking"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"Ray ray = new Ray(cam.getLocation(), cam.getDirection());\n")),Object(o.b)("h1",{id:"rectangle"},"Rectangle"),Object(o.b)("p",null,"See ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"%7Blink-javadoc%7D/com/jme3/math/Rectangle.html"}),"Rectangle Javadoc")),Object(o.b)("h2",{id:"definition-9"},"Definition"),Object(o.b)("p",null,"Rectangle defines a finite plane within three dimensional space that is\nspecified via three points (A, B, C). These three points define a\ntriangle with the forth point defining the rectangle ( (B + C) - A )."),Object(o.b)("h2",{id:"jme-usage"},"jME Usage"),Object(o.b)("p",null,"Rectangle is a straight forward data class that simply maintains values\nthat defines a Rectangle in 3D space. One interesting use is the\n",Object(o.b)("inlineCode",{parentName:"p"},"random")," method that will create a random point on the Rectangle. The\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../jme3/advanced/effects_overview"}),"Particle System")," makes use of\nthis to define an area that generates\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../jme3/advanced/particle_emitters"}),"Particles"),"."),Object(o.b)("h2",{id:"example-1--define-a-rectangle-and-get-a-point-from-it"},"Example 1 : Define a Rectangle and Get a Point From It"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"Vector3f v1 = new Vector3f(1,0,0);\nVector3f v2 = new Vector3f(1,1,0);\nVector3f v3 = new Vector3f(0,1,0);\nRectangle r = new Rectangle(v1, v2, v3);\nVector3f point = r.random();\n")),Object(o.b)("h1",{id:"triangle"},"Triangle"),Object(o.b)("p",null,"See ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"%7Blink-javadoc%7D/com/jme3/math/Triangle.html"}),"Triangle Javadoc")),Object(o.b)("h2",{id:"definition-10"},"Definition"),Object(o.b)("p",null,"A triangle is a 3-sided polygon. Every triangle has three sides and\nthree angles, some of which may be the same. If the triangle is a right\ntriangle (one angle being 90 degrees), the side opposite the 90 degree\nangle is the hypotenuse, while the other two sides are the legs. All\ntriangles are ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://en.wikipedia.org/wiki/Convex_polygon"}),"convex")," and\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://mathworld.wolfram.com/BicentricPolygon.html"}),"bicentric"),"."),Object(o.b)("h2",{id:"usage-2"},"Usage"),Object(o.b)("p",null,"jME's Triangle class is a simple data class. It contains three\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../jme3/terminology.html.xml#vectors#"}),"Vector3f")," objects that represent\nthe three points of the triangle. These can be retrieved via the ",Object(o.b)("inlineCode",{parentName:"p"},"get"),"\nmethod. The ",Object(o.b)("inlineCode",{parentName:"p"},"get")," method, obtains the point based on the index provided.\nSimilarly, the values can be set via the ",Object(o.b)("inlineCode",{parentName:"p"},"set")," method."),Object(o.b)("h2",{id:"example-1---creating-a-triangle"},"Example 1 - Creating a Triangle"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"//the three points that make up the triangle\nVector3f p1 = new Vector3f(0,1,0);\nVector3f p2 = new Vector3f(1,1,0);\nVector3f p3 = new Vector3f(0,1,1);\nTriangle t = new Triangle(p1, p2, p3);\n")),Object(o.b)("h3",{id:"tips-and-tricks"},"Tips and Tricks"),Object(o.b)("h1",{id:"how-do-i-get-heightwidth-of-a-spatial"},"How do I get height/width of a spatial?"),Object(o.b)("p",null,"Cast the spatial to com.jme3.bounding.BoundingBox to be able to use\ngetExtent()."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"Vector3f extent = ((BoundingBox) spatial.getWorldBound()).getExtent(new Vector3f());\nfloat x = ( (BoundingBox)spatial.getWorldBound()).getXExtent();\nfloat y = ( (BoundingBox)spatial.getWorldBound()).getYExtent();\nfloat z = ( (BoundingBox)spatial.getWorldBound()).getZExtent();\n")),Object(o.b)("h1",{id:"how-do-i-position-the-center-of-a-geomtry"},"How do I position the center of a Geomtry?"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"geo.center().move(pos);\n")),Object(o.b)("h2",{id:"see-also"},"See Also"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../jme3/rotate"}),"Rotate"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../jme3/quaternion"}),"Quaternion")))))}p.isMDXComponent=!0},441:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return m}));var a=n(0),i=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),p=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l({},t,{},e)),n},b=function(e){var t=p(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},h=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),b=p(n),h=a,m=b["".concat(r,".").concat(h)]||b[h]||d[h]||o;return n?i.a.createElement(m,l({ref:t},c,{components:n})):i.a.createElement(m,l({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var c=2;c<o;c++)r[c]=n[c];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);