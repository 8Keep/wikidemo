(window.webpackJsonp=window.webpackJsonp||[]).push([[194],{333:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return u}));var a=n(1),o=n(9),r=(n(0),n(441)),i={},l={id:"jme3/advanced/multithreading",title:"multithreading",description:"The jME3 Threading Model",source:"@site/docs/jme3/advanced/multithreading.md",permalink:"/wikidemo/docs/jme3/advanced/multithreading",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/advanced/multithreading.md"},c=[{value:"Java Multithreading",id:"java-multithreading",children:[]},{value:"Multithreading in jME3",id:"multithreading-in-jme3",children:[]},{value:"Useful Links",id:"useful-links",children:[]},{value:"Conclusion",id:"conclusion",children:[]}],s={rightToc:c};function u(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"the-jme3-threading-model"},"The jME3 Threading Model"),Object(r.b)("p",null,"jME3 is similar to Swing in that, for speed and efficiency, all changes\nto the scene graph must be made in a single update thread. If you make\nchanges only in Control.update(), AppState.update(), or\nSimpleApplication.simpleUpdate(), this will happen automatically.\nHowever, if you pass work to another thread, you may need to pass\nresults back to the main jME3 thread so that scene graph changes can\ntake place there."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"public void rotateGeometry(final Geometry geo, final Quaternion rot) {\n    mainApp.enqueue(new Callable<Spatial>() {\n        public Spatial call() throws Exception {\n            return geo.rotate(rot);\n        }\n    });\n}\n")),Object(r.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(r.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"This example does not fetch the returned value by calling ",Object(r.b)("inlineCode",{parentName:"p"},"get()")," on the\nFuture object returned from ",Object(r.b)("inlineCode",{parentName:"p"},"enqueue()"),". This means that the example\nmethod ",Object(r.b)("inlineCode",{parentName:"p"},"rotateGeometry()")," will return immediately and will not wait for\nthe rotation to be processed before continuing."),Object(r.b)("p",{parentName:"div"},"If the processing thread needs to wait or needs the return value then\n",Object(r.b)("inlineCode",{parentName:"p"},"get()")," or the other methods in the returned Future object such as\n",Object(r.b)("inlineCode",{parentName:"p"},"isDone()")," can be used."))),Object(r.b)("p",null,"First, make sure you know what ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/advanced/application_states"}),"Application\nStates")," and ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/advanced/custom_controls"}),"Custom\nControls")," are."),Object(r.b)("p",null,"More complex games may feature complex mathematical operations or\nartificial intelligence calculations (such as path finding for several\nNPCs). If you make many time-intensive calls on the same thread (in the\nupdate loop), they will block one another, and thus slow down the game\nto a degree that makes it unplayable. If your game requires long running\ntasks, you should run them concurrently on separate threads, which\nspeeds up the application considerably."),Object(r.b)("p",null,"Often multithreading means having separate detached logical loops going\non in parallel, which communicate about their state. (For example, one\nthread for AI, one Sound, one Graphics). However we recommend to use a\nglobal update loop for game logic, and do multithreading within that\nloop when it is appropriate. This approach scales way better to multiple\ncores and does not break up your code logic."),Object(r.b)("p",null,"Effectively, each for-loop in the main update loop might be a chance for\nmultithreading, if you can break it up into self-contained tasks."),Object(r.b)("h2",{id:"java-multithreading"},"Java Multithreading"),Object(r.b)("p",null,"The java.util.concurrent package provides a good foundation for\nmultithreading and dividing work into tasks that can be executed\nconcurrently (hence the name). The three basic components are the\nExecutor (supervises threads), Callable Objects (the tasks), and Future\nObjects (the result). You can ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"http://download.oracle.com/javase/tutorial/essential/concurrency/"}),"read about the concurrent package more\nhere"),",\nI will give just a short introduction."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"A Callable is one of the classes that gets executed on a thread in\nthe Executor. The object represents one of several concurrent tasks\n(e.g, one NPC's path finding task). Each Callable is started from\nthe updateloop by calling a method named ",Object(r.b)("inlineCode",{parentName:"p"},"call()"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"The Executor is one central object that manages all your Callables.\nEvery time you schedule a Callable in the Executor, the Executor\nreturns a Future object for it.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"A Future is an object that you use to check the status of an\nindividual Callable task. The Future also gives you the return value\nin case one is returned."))),Object(r.b)("h2",{id:"multithreading-in-jme3"},"Multithreading in jME3"),Object(r.b)("p",null,"So how do we implement multithreading in jME3?"),Object(r.b)("p",null,"Let's take the example of a Control that controls an NPC Spatial. The\nNPC Control has to compute a lengthy pathfinding operation for each NPC.\nIf we would execute the operations directly in the simpleUpdate() loop,\nit would block the game each time a NPC wants to move from A to B. Even\nif we move this behaviour into the update() method of a dedicated NPC\nControl, we would still get annoying freeze frames, because it still\nruns on the same update loop thread."),Object(r.b)("p",null,"To avoid slowdown, we decide to keep the pathfinding operations in the\nNPC Control, ",Object(r.b)("em",{parentName:"p"},"but execute it on another thread"),"."),Object(r.b)("h1",{id:"executor"},"Executor"),Object(r.b)("p",null,"You create the executor object in a global AppState (or the\ninitSimpleApp() method), in any case in a high-level place where\nmultiple controls can access it."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"/* This constructor creates a new executor with a core pool size of 4. */\nScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(4);\n")),Object(r.b)("p",null,"Pool size means the executor will keep four threads alive at any time.\nHaving more threads in the pool means that more tasks can run\nconcurrently. But a bigger pool only results in a speed gain if the PC\ncan handle it! Allocating a pool that is uselessly large just wastes\nmemory, so you need to find a good compromise: About the same to double\nthe size of the number of cores in the computer makes sense."),Object(r.b)("p",null,"::: {.warning}\nExecutor needs to be shut down when the application ends, in order to\nmake the process die properly In your simple application you can\noverride the destroy method and shutdown the executor:\n:::"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"    @Override\n    public void destroy() {\n        super.destroy();\n        executor.shutdown();\n    }\n")),Object(r.b)("h1",{id:"control-class-fields"},"Control Class Fields"),Object(r.b)("p",null,"In the NPC Control, we create the individual objects that the thread\nmanipulates. In our example case (the pathfinding control), the task is\nabout locations and path arrays, so we need the following variables:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-{.Java}"}),"//The vector to store the desired location in:\nVector3f desiredLocation = new Vector3f();\n//The MyWayList object that contains the result waylist:\nMyWayList wayList = null;\n//The future that is used to check the execution status:\nFuture future = null;\n")),Object(r.b)("p",null,"Here we also created the Future variable to track the state of this\ntask."),Object(r.b)("h1",{id:"control-update-method"},"Control Update() Method"),Object(r.b)("p",null,"Next let's look at the update() call of the Control where the\ntime-intensive task starts. In our example, the task is the ",Object(r.b)("inlineCode",{parentName:"p"},"findWay"),"\nCallable (which contains the pathfinding process). So instead of\nspelling out the pathfinding process in the Control's update() loop, we\nstart the process via ",Object(r.b)("inlineCode",{parentName:"p"},"future = executor.submit(findWay);"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"public void update(float tpf) {\n    try{\n        //If we have no waylist and not started a callable yet, do so!\n        if(wayList == null && future == null){\n            //set the desired location vector, after that we should not modify it anymore\n            //because it's being accessed on the other thread!\n            desiredLocation.set(getGoodNextLocation());\n            //start the callable on the executor\n            future = executor.submit(findWay);    //  Thread starts!\n        }\n        //If we have started a callable already, we check the status\n        else if(future != null){\n            //Get the waylist when its done\n            if(future.isDone()){\n                wayList = future.get();\n                future = null;\n            }\n            else if(future.isCancelled()){\n                //Set future to null. Maybe we succeed next time...\n                future = null;\n            }\n        }\n    }\n    catch(Exception e){\n      Exceptions.printStackTrace(e);\n    }\n    if(wayList != null){\n        //.... Success! Let's process the wayList and move the NPC...\n    }\n}\n")),Object(r.b)("p",null,"Note how this logic makes its decision based on the Future object."),Object(r.b)("p",null,'Remember not to mess with the class fields after starting the thread,\nbecause they are being accessed and modified on the new thread. In more\nobvious terms: You cannot change the "desired location of the NPC while\nthe path finder is calculating a different path. You have to cancel the\ncurrent Future first.'),Object(r.b)("h1",{id:"the-callable"},"The Callable"),Object(r.b)("p",null,"The next code sample shows the Callable that is dedicated to performing\nthe long-running task (here, wayfinding). This is the task that used to\nblock the rest of the application, and is now executed on a thread of\nits own. You implement the task in the Callable always in an inner\nmethod named ",Object(r.b)("inlineCode",{parentName:"p"},"call()"),"."),Object(r.b)("p",null,"The task code in the Callable should be self-contained! It should not\nwrite or read any data of objects that are managed by the scene graph or\nOpenGL thread directly. Even reading locations of Spatials can be\nproblematic! So ideally all data that is needed for the wayfinding\nprocess should be available to the new thread when it starts already,\npossibly in a cloned version so no concurrent access to the data\nhappens."),Object(r.b)("p",null,"In reality, you might need access to the game state. If you must read or\nwrite a current state from the scene graph, you must have a clone of the\ndata in your thread. There are only two ways:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Use the execution queue ",Object(r.b)("inlineCode",{parentName:"p"},"application.enqueue()")," to create a\nsub-thread that clones the info. Only disadvantage is, it may be\nslower.\\\nThe example below gets the ",Object(r.b)("inlineCode",{parentName:"p"},"Vector3f location")," from the scene object\n",Object(r.b)("inlineCode",{parentName:"p"},"mySpatial")," using this way.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Create a separate World class that allows safe access to its data\nvia synchronized methods to access the scene graph. Alternatively it\ncan also internally use ",Object(r.b)("inlineCode",{parentName:"p"},"application.enqueue()"),".\\\nThe following example gets the object\n",Object(r.b)("inlineCode",{parentName:"p"},"Data data = myWorld.getData();")," using this way."))),Object(r.b)("p",null,"These two ways are thread-safe, they don't mess up the game logic, and\nkeep the Callable code readable."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"// A self-contained time-intensive task:\nprivate Callable<MyWayList> findWay = new Callable<MyWayList>(){\n    public MyWayList call() throws Exception {\n\n        //Read or write data from the scene graph -- via the execution queue:\n        Vector3f location = application.enqueue(new Callable<Vector3f>() {\n        \xa0\xa0\xa0\xa0public Vector3f call() throws Exception {\n        \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//we clone the location so we can use the variable safely on our thread\n        \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0return mySpatial.getLocalTranslation().clone();\n        \xa0\xa0\xa0\xa0}\n        }).get();\n\n        // This world class allows safe access via synchronized methods\n        Data data = myWorld.getData();\n\n        //... Now process data and find the way ...\n\n        return wayList;\n    }\n};\n")),Object(r.b)("h2",{id:"useful-links"},"Useful Links"),Object(r.b)("p",null,"High level description which describes how to manage the game state and\nthe rendering in different threads:\\\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"http://jahej.com/alt/2011_07_03_threading-and-your-game-loop.html"}),"Threading and your game\nloop"),".\\\nA C++ example can be found at:\\\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"http://gamasutra.com/blogs/AndreaMagnorsky/20130527/193087/Multithreading_rendering_in_a_game_engine_with_CDouble_buffer_implementation.php"}),"Multithreading-rendering in a game engine with CDouble buffer\nimplementation"),"."),Object(r.b)("h2",{id:"conclusion"},"Conclusion"),Object(r.b)("p",null,"The cool thing about this approach is that every entity creates one\nself-contained Callable for the Executor, and they are all executed in\nparallel. In theory, you can have one thread per entity without changing\nanything else but the settings of the executor."))}u.isMDXComponent=!0},441:function(e,t,n){"use strict";n.d(t,"a",(function(){return h})),n.d(t,"b",(function(){return b}));var a=n(0),o=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=o.a.createContext({}),u=function(e){var t=o.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l({},t,{},e)),n},h=function(e){var t=u(e.components);return o.a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},p=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),h=u(n),p=a,b=h["".concat(i,".").concat(p)]||h[p]||d[p]||r;return n?o.a.createElement(b,l({ref:t},s,{components:n})):o.a.createElement(b,l({ref:t},s))}));function b(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=p;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var s=2;s<r;s++)i[s]=n[s];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);