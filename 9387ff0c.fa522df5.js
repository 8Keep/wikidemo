(window.webpackJsonp=window.webpackJsonp||[]).push([[171],{310:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return h}));var a=n(1),r=n(9),o=(n(0),n(441)),i={},l={id:"jme3/contributions/particles",title:"particles",description:"This is a new particle system for jME3 posted for review and comments.",source:"@site/docs/jme3/contributions/particles.md",permalink:"/wikidemo/docs/jme3/contributions/particles",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/contributions/particles.md"},s=[],c={rightToc:s};function h(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"This is a new particle system for jME3 posted for review and comments.\nThis is an opportunity for people to comment on and request changes to\nthe API or the internal functionality of the system. The code for this\nparticle system can be found\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jMonkeyEngine-Contributions/ParticleController"}),"jMonkeyEngine-Contributions")),Object(o.b)("p",null,"Apologies for the slight jitter in some of the videos, the\nVideoRecorderState seems to be causing some issues which are not present\nwhen the application is running normally."),Object(o.b)("h1",{id:"credits"},"Credits"),Object(o.b)("p",null,"These particle emitters are inspired by and use some code from t0neg0ds\nparticle emitters as described\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://hub.jmonkeyengine.org/t/influencer-based-particleemitter-candidate-mesh-based-animated-particles/25831"}),"here")),Object(o.b)("p",null,"Those in turn were based on the original jME3 particle system by Kirill\nVainer"),Object(o.b)("h1",{id:"the-big-picture"},"The Big Picture"),Object(o.b)("p",null,"The core of all Particle Emitters is a ParticleController. That is used\nto manage all of the particles, the behaviour of the particles\nthemselves though is controlled though a number of other classes that\nare plugged in to the ParticleController to provide the required\nfunctionality. You can think of the ParticleController as providing the\ncentral hub into which you plug all the modules you need to get the\ndesired behaviour."),Object(o.b)("p",null,"An easy way to see what you need is to create a new ParticleController\nand then look at the constructor, you can see what parameters need to be\nsupplied there."),Object(o.b)("p",null,"+-----------------------------------+-----------------------------------+\n| name                              | The name to use for the geometry  |\n|                                   | in the scene graph                |\n+===================================+===================================+\n| mesh                              | The mesh to use (Usually either   |\n|                                   | PointMesh or QuadMesh)            |\n+-----------------------------------+-----------------------------------+\n| maxParticles                      | The maximum number of particles   |\n|                                   | to allow active at any one time   |\n+-----------------------------------+-----------------------------------+\n| lifeMin                           | The minimum amount of time (in    |\n|                                   | seconds) for which each particle  |\n|                                   | lives                             |\n+-----------------------------------+-----------------------------------+\n| lifeMax                           | The maximum amount of time (in    |\n|                                   | seconds) for which each particle  |\n|                                   | lives                             |\n+-----------------------------------+-----------------------------------+\n| source                            | The source from which the         |\n|                                   | particles are spawned             |\n+-----------------------------------+-----------------------------------+\n| emissionController                | The frequency and timing with     |\n|                                   | which particles are spawned. If   |\n|                                   | null then no particles are        |\n|                                   | automatically spawned and they    |\n|                                   | must be triggered manually using  |\n|                                   | emitNextParticle() or             |\n|                                   | emitAllParticles()                |\n+-----------------------------------+-----------------------------------+\n| influencers                       | Zero or more ParticleInfluencers, |\n|                                   | each of which changes the         |\n|                                   | behaviour of the particles.       |\n+-----------------------------------+-----------------------------------+"),Object(o.b)("p",null,"By selecting the behaviour you desire for each option you can configure\nup a virtually infinite array of possible particle emitters."),Object(o.b)("p",null,"We will now walk through some common examples and possible uses, and\nthen in the end we will document all of the possible choices for these\noptions."),Object(o.b)("p",null,"For a full reference of the standard options available see the\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../../jme3/contributions/particles/reference"}),"Reference Page"),"."),Object(o.b)("h1",{id:"simple-fire"},"Simple Fire"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'public class HelloParticles1_SimpleFire extends SimpleApplication {\n\n    public static void main(String[] args){\n        HelloParticles1_SimpleFire app = new HelloParticles1_SimpleFire();\n        app.start(); // start the game\n    }\n\n    @Override\n    public void simpleInitApp() {\n\n// Construct a new ParticleController\n        ParticleController pCtrl = new ParticleController(\n// The name of the emitter\n                "SimpleFire",\n// Use a simple point mesh (the fastest but most limitted mesh type) with the specified\n// image (from jME3-testdata). The image actually contains a 2x2 grid of sprites.\n                new PointMesh(assetManager, "Effects/Explosion/flame.png", 2, 2),\n// Allow at most 32 particles at any time\n                32,\n// Particles last for at least 2 seconds\n                2,\n// And at most 3 seconds\n                3,\n// Point sources always generate particles at the location of the source, the particles\n// are given a random velocity between the two given.\n                new PointSource(new Vector3f(-3, 0, -3), new Vector3f(3, 0, 3)),\n// Emit particles at regular intervals, 10 particles every second\n                new RegularEmission(10),\n// ** Influencers start here\n// Select a random sprite from the 4 available for each particle\n                new RandomSpriteInfluencer(),\n// Particles start off with a size of 0.5 units, end with a radius of 0.1\n                new SizeInfluencer(0.5f, 0.1f),\n// Particles start yellow full opacity and fade towards red with very low opacity\n                new ColorInfluencer(new ColorRGBA(1,1,0.2f,1), new ColorRGBA(1,0,0,0.1f)),\n// No matter what velocity particles started with they will start moving upwards.\n                new PreferredDirectionInfluencer(new Vector3f(0, 1, 0), 0.25f));\n\n// Finally attach the geometry to the rootNode in order to start the particles running\n        rootNode.attachChild(pCtrl.getGeometry());\n    }\n}\n')),Object(o.b)("p",null,"Run that and the result should look something like:"),Object(o.b)("p",null,Object(o.b)("img",Object(a.a)({parentName:"p"},{src:"/images/jme3/particles1.jpg",alt:"particles1.jpg"}))),Object(o.b)("h1",{id:"simple-fire-and-smoke"},"Simple Fire and Smoke"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'    @Override\n    public void simpleInitApp() {\n\n// Construct a new ParticleController\n        ParticleController pCtrl = new ParticleController(\n// The name of the emitter\n                "SimpleFire",\n// Use a simple point mesh (the fastest but most limitted mesh type) with the specified\n// image (from jME3-testdata). The image actually contains a 2x2 grid of sprites.\n                new PointMesh(assetManager, "Effects/Explosion/flame.png", 2, 2),\n// Allow at most 50 particles at any time, the particles are lasting longer this time\n// so we need to allow more on screen at once\n                50,\n// Particles last for at least 4 seconds\n                4,\n// And at most 5 seconds\n                5,\n// Point sources always generate particles at the location of the source, the particles\n// are given a random velocity between the two given.\n                new PointSource(new Vector3f(-3, 0, -3), new Vector3f(3, 0, 3)),\n// Emit particles at regular intervals, 10 particles every second\n                new RegularEmission(10),\n// ** Influencers start here\n// Select a random sprite from the 4 available for each particle\n                new RandomSpriteInfluencer(),\n// Particles start off with a size of 0.5 units, end with a radius of 0.1\n                new SizeInfluencer(0.5f, 0.25f),\n// Particles start yellow full opacity and fade towards red with very low opacity\n                new MultiColorInfluencer(\n                    new MultiColorInfluencer.Stage(0, new ColorRGBA(1, 1, 0.1f, 1)),\n                    new MultiColorInfluencer.Stage(0.15f, new ColorRGBA(1, 0, 0, 0.25f)),\n                    new MultiColorInfluencer.Stage(0.3f, new ColorRGBA(1f, 1f, 1f, 0.5f)),\n                    new MultiColorInfluencer.Stage(1, new ColorRGBA(1f,1f,1f,0f))\n                ),\n// No matter what velocity particles started with they will start moving upwards.\n                new PreferredDirectionInfluencer(new Vector3f(0, 1, 0), 0.25f));\n\n// Finally attach the geometry to the rootNode in order to start the particles running\n        rootNode.attachChild(pCtrl.getGeometry());\n    }\n')),Object(o.b)("p",null,"You can see that the only change is to make the particles last a little\nlonger and to change the ColorInfluencer for a MultiColorInfluencer, and\nyet the results look quite different:"),Object(o.b)("p",null,Object(o.b)("img",Object(a.a)({parentName:"p"},{src:"/images/jme3/particles2.jpg",alt:"particles2.jpg"}))),Object(o.b)("p",null,"This isn't a very convincing fire yet, but it is very simple to get up\nand running. One problem with this approach is that particles are done\nusing an alpha-additive material, they can only make things brighter but\nnever darker. That is not ideal for smoke which should be able to make\nthem darker too. We will look at this again later but for now we will\nmove on to some different mesh types."),Object(o.b)("h1",{id:"quad-meshes-and-billboarding"},"Quad Meshes and Billboarding"),Object(o.b)("p",null,"Point Meshes are extremely fast, but they have a number of limitations.\nThe main ones being that the sprites must always be facing towards the\nscreen and that on certain graphics cards the maximum number of pixels a\nsprite can occupy on the screen is limited."),Object(o.b)("p",null,"While PointMesh is recommended for basic particles for more advanced\noptions there is the QuadMesh, this constructs each particle using a\nquad and as a result can allow any size on the screen and any\norientation. The following example combines two separate particle\nemitters to produce a spell-like effect."),Object(o.b)("p",null,"::: {.note}\nThe flame image from before is used for the second emitter, the first\nemitter uses this image which you can download and use:"),Object(o.b)("p",null,Object(o.b)("img",Object(a.a)({parentName:"p"},{src:"/images/jme3/runecircle.png",alt:"runecircle.png"})),"\n:::"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'    @Override\n    public void simpleInitApp() {\n\n// Construct a new ParticleController to provide the actual spell runes effect\n        ParticleController pCtrl = new ParticleController(\n// The name of the emitter\n                "SpellRunes",\n// Use a Quad Mesh, this image is available for download on this page. The texture file contains\n// a single image so there are no sprite columns and rows to set up. The BillboardStrategy is how\n// the particles should be oriented, in this case it uses the particle rotation.\n                new QuadMesh(QuadMeshBillboardStrategy.USE_PARTICLE_ROTATION, assetManager, "Textures/runeCircle.png"),\n// Allow at most 9 particles at any time\n                9,\n// Particles always last for 4 seconds\n                4,\n                4,\n// We want to generate all particles from the same location with the same velocity.\n                new PointSource(new Vector3f(0, 1f, 0), new Vector3f(0, 1f, 0)),\n// Emit particles at regular intervals, 4 particles every second\n                new RegularEmission(2),\n// ** Influencers start here\n// These particles should be size 3 and stay the same size\n                new SizeInfluencer(3, 3),\n// Start the particles at full opacity blue and then fade them out to 0 opacity cyan.\n                new ColorInfluencer(ColorRGBA.Blue, new ColorRGBA(0, 1, 1, 0)),\n// Rotate all particles by the same amount. The units are radians-per-second\n                new RotationInfluencer(\n                    new Vector3f(0, FastMath.QUARTER_PI, 0),\n                    new Vector3f(0, FastMath.QUARTER_PI, 0), false));\n\n// Finally attach the geometry to the rootNode in order to start the particles running\n        rootNode.attachChild(pCtrl.getGeometry());\n\n\n// Construct a new ParticleController to provide the central glow effect\n        pCtrl = new ParticleController(\n// The name of the emitter\n                "SpellBase",\n// Use a simple point mesh (the fastest but most limitted mesh type) with the specified\n// image (from jME3-testdata). The image actually contains a 2x2 grid of sprites.\n                new PointMesh(assetManager, "Textures/flame.png", 2, 2),\n// Allow at most 76 particles at any time\n                76,\n// Particles last for at least 5 seconds\n                5,\n// And at most 5 seconds\n                5,\n// Point sources always generate particles at the location of the source, the particles\n// are given a random velocity between the two given.\n                new PointSource(new Vector3f(-1f, 0, -1f), new Vector3f(1f, 0.5f, 1f)),\n// Emit particles at regular intervals, 15 particles every second\n                new RegularEmission(15),\n// ** Influencers start here\n// Select a random sprite from the 4 available for each particle\n                new RandomSpriteInfluencer(),\n// Particles start red with some blue and green and fade towards blue zero opacity\n// Because particles are rendered using an additive blend then any area where a lot\n// of particles overlap will end up white.\n                new ColorInfluencer(new ColorRGBA(1,0.25f,0.25f,0.25f), new ColorRGBA(0,0,1,0f)));\n\n// Finally attach the geometry to the rootNode in order to start the particles running\n        rootNode.attachChild(pCtrl.getGeometry());\n\n\n        cam.setLocation(new Vector3f(0, 10, -10));\n        cam.lookAt(Vector3f.ZERO, Vector3f.UNIT_Y);\n    }\n')),Object(o.b)("p",null,"The result should look something like:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.youtube.com/watch?v=_Spjqag99HY"}),"Video: Particle Emitter Example\n1"))),Object(o.b)("h1",{id:"using-a-mesh-as-the-particle-source"},"Using a mesh as the particle source"),Object(o.b)("p",null,"There is a model of a monkeys head in the test data that is used in this\nexample, although you can use any other model you like. Just make sure\nyou can find the geometry within the model for the next step."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'    @Override\n    public void simpleInitApp() {\n\n        Node monkey = (Node) assetManager.loadModel("Models/MonkeyHead/MonkeyHead.mesh.xml");\n        rootNode.attachChild(monkey);\n\n        DirectionalLight dl = new DirectionalLight();\n        dl.setDirection(new Vector3f(-0.1f,-0.7f,-1).normalizeLocal());\n        dl.setColor(new ColorRGBA(0.88f, 0.60f, 0.60f, 1.0f));\n        rootNode.addLight(dl);\n\n        AmbientLight al = new AmbientLight();\n        al.setColor(ColorRGBA.White);\n        rootNode.addLight(al);\n')),Object(o.b)("p",null,"The result should look something like:"),Object(o.b)("p",null,Object(o.b)("img",Object(a.a)({parentName:"p"},{src:"/images/jme3/particles3.jpg",alt:"particles3.jpg"}))),Object(o.b)("p",null,"Now lets set fire to the monkey! (No monkeys were harmed during the\nmaking of this particle system!)."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'// Construct a new ParticleController\n        ParticleController pCtrl = new ParticleController(\n// The name of the emitter\n                "SimpleFire",\n// Use a simple point mesh (the fastest but most limitted mesh type) with the specified\n// image (from jME3-testdata). The image actually contains a 2x2 grid of sprites.\n                new PointMesh(assetManager, "Textures/flame.png", 2, 2),\n// Allow at most 1200 particles at any time, the particles are lasting longer this time\n// so we need to allow more on screen at once\n                1200,\n// Particles last for at least 4 seconds\n                4,\n// And at most 5 seconds\n                5,\n// A MeshSource scans a geometry and picks a random point on the surface of that\n// geometry in order to emit the particle from it. The particle has an inital velocity\n// of 1wu/s along the normal of the triangle from which it is emitted.\n                new MeshSource(g),\n// Emit particles at regular intervals, 10 particles every second\n                new RegularEmission(240),\n// ** Influencers start here\n// Select a random sprite from the 4 available for each particle\n                new RandomSpriteInfluencer(),\n// Particles start off with a size of 0.1 units, end with a size of 0.15\n                new SizeInfluencer(0.1f, 0.15f),\n// Particles have a constant speed of 0.25f, this will modify the original speed\n// from the emitter and then allow the GravityInfluencer to change the direction\n// of motion but constrain the speed\n                new SpeedInfluencer(0.25f, 0.25f),\n// Fade the paticles through a range of colours\n                new MultiColorInfluencer(\n                    new MultiColorInfluencer.Stage(0, new ColorRGBA(1, 1, 0.1f, 1)),\n                    new MultiColorInfluencer.Stage(0.25f, new ColorRGBA(1, 0, 0, 0.25f)),\n                    new MultiColorInfluencer.Stage(0.5f, new ColorRGBA(1f, 1f, 1f, 0.25f)),\n                    new MultiColorInfluencer.Stage(1, new ColorRGBA(1f,1f,1f,0f))\n                ),\n// No matter what velocity particles started with they will start moving upwards.\n                new GravityInfluencer(new Vector3f(0, 0.5f, 0)));\n\n// Finally attach the geometry to the rootNode in order to start the particles running\n        rootNode.attachChild(pCtrl.getGeometry());\n')),Object(o.b)("p",null,"Again this is just a very simple example, much more sophisticated fire\neffects are possible with the use of the right textures and mixture of\nemitters and influencers. The result though should look something like\nthis:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.youtube.com/watch?v=W__zGJHZ2AU"}),"Video: Particle Emitter Example\n2"))),Object(o.b)("h1",{id:"meshes-and-weighted-meshes"},"Meshes and Weighted Meshes"),Object(o.b)("p",null,"The previous example uses a MeshSource, this picks a random triangle\nfrom the mesh without any regard given to the size of different\ntriangles. This means areas with small triangles are actually more\nlikely to emit particles than areas with large triangles. For most\nmeshes this is not visible, however there is a WeightedMeshSource\navailable if this should be a problem."),Object(o.b)("p",null,"The WeightedMeshSource scans the mesh and works out a weight for each\ntriangle based on its relative size, so that the result is an even\nspread of particles even with very large differences in triangle sizes.\nThere are some limitations with this though:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"The WeightedMeshSource consumes more memory as it needs to remember\nthe weights")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"The WeightedMeshSource is slower as it needs to do more work to pick\na triangle")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"The WeightedMeshSource does not update automatically if the mesh\nchanges, if triangles are added they will not emit, if triangles are\nremoved it could cause a crash. If triangles change shape then the\nweights are not updated."))),Object(o.b)("p",null,"There is a method available to cause the weights to be recalculated\nwhich can be used if changing the mesh, but really if possible a\nnon-weighted MeshSource should be used for dynamic meshes."),Object(o.b)("h1",{id:"3d-particles---templatemesh"},"3d Particles - TemplateMesh"),Object(o.b)("p",null,"The previous mesh examples all use simple 2d quads to display images.\nThere is another mesh type though, the TemplateMesh, which allows fully\nfeatured 3d particles to be used."),Object(o.b)("p",null,"::: {.note}\nThere is a rock texture available in the jME3 test data, or you can\nsubstitute any other suitable texture. The model for this example is:\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://www.zero-separation.com/particles/FracturedCube.j3o"}),"FracturedCube.j3o"),"\n:::"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'    @Override\n    public void simpleInitApp() {\n\n        // Since we actually use a full lit material for these particles we need\n        // to add a light to the scene in order to see anything.\n        DirectionalLight dl = new DirectionalLight();\n        dl.setDirection(new Vector3f(-0.1f,-0.7f,-1).normalizeLocal());\n        dl.setColor(new ColorRGBA(0.6f, 0.60f, 0.60f, 1.0f));\n        rootNode.addLight(dl);\n\n// A standard lit material is used, this rock texture was taking from the\n// jme3 test data but you can easily substitute your own.\n        Material rock = new Material(assetManager, "Common/MatDefs/Light/Lighting.j3md");\n        rock.setTexture("DiffuseMap", assetManager.loadTexture("Textures/Rock.PNG"));\n        rock.setFloat("Shininess", 100f);\n\n// A PointSource is actually a fully featured Spatial object, in this case\n// we simply adjust its translation, but it can actually be attached to the\n// scene graph and the source will automatically move as the Node to which\n// it is attached is transformed.\n        PointSource source = new PointSource(new Vector3f(-5,-5,-5), new Vector3f(5,5,5));\n        source.setLocalTranslation(0, 10, -20);\n\n// A TemplateMesh uses any number of standard meshes to be the template for\n// each 3d particle. This model was generated simply by taking a cube in\n// Blender and running a fracture script on it to generate 20 fragments.\n        Node n = (Node) assetManager.loadModel("Models/FracturedCube.j3o");\n        Mesh[] templates = new Mesh[n.getChildren().size()];\n        int i = 0;\n        for (Spatial s: n.getChildren()) {\n            Geometry g = (Geometry)((Node)s).getChild(0);\n            templates[i++] = g.getMesh();\n        }\n\n// Construct the new particle controller\n        ParticleController rockCtrl = new ParticleController(\n                "TemplateMesh",\n// The TemplateMesh uses the rock material we created previously, the two boolean\n// flags say that we are not interested in vertex colours but we do want the vertex\n// normals. The array of meshes extracted from the model is then passed in to use\n// as models for each particle.\n                new TemplateMesh(rock, false, true, templates),\n// A maximum of 64 particles at once, each lasting for 5 to 5.5 seconds.\n                64,\n                5,\n                5.5f,\n// Particles are emitted from the source that we created and positioned earlier\n                source,\n// Emit 8 particles per second\n                new RegularEmission(8),\n// The "sprites" in this case are the available templates. The TemplateMesh has\n// one spriteColumn for each template it has been provided, so the standard\n// RandomSpriteInfluencer just causes one to be picked at random each time a\n// particle is emitted.\n                new RandomSpriteInfluencer(),\n// Rocks fall.\n                new GravityInfluencer(new Vector3f(0, -4, 0)),\n// Rocks spin.\n                new RotationInfluencer(new Vector3f(-2, -2, -2), new Vector3f(2, 2, 2), false));\n\n        rootNode.attachChild(rockCtrl.getGeometry());\n    }\n')),Object(o.b)("p",null,"The result should look like:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.youtube.com/watch?v=a7y53UF8Giw"}),"Video: Particle Emitter Example\n3"))),Object(o.b)("p",null,"Any number and mixture of models can be used, although as it is all a\nsingle mesh the same material must be used for all of them. It is\nrecommended to keep a similar number of vertices for each of the models\nbut that is not a strict requirement."),Object(o.b)("h1",{id:"emitting-particles-from-particles"},"Emitting Particles from Particles"),Object(o.b)("p",null,"To add more dramatic effects sometimes you want to emit particles from\nparticles, this could be done simply by attaching a MeshSource for the\nsecond controller to the mesh from the first controller. There are a\nnumber of limitations to this approach though, which will be\ndemonstrated now:"),Object(o.b)("p",null,"Adding the following code:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'        ParticleController pCtrl = new ParticleController(\n                "TemplateFlames",\n                new PointMesh(assetManager, "Textures/flame.png", 2, 2),\n                1300,\n                3,\n                4,\n                new MeshSource(rockCtrl.getGeometry()),\n                new RegularEmission(320),\n                new SizeInfluencer(0.5f, 2),\n                new ColorInfluencer(new ColorRGBA(1,1,0.1f, 1f), new ColorRGBA(1,0,0,0.05f)),\n                new GravityInfluencer(new Vector3f(0, 0.3f, 0)),\n                new RandomImpulseInfluencer(\n                    RandomImpulseInfluencer.ImpulseApplicationTime.INITIALIZE,\n                    new Vector3f(-0.5f, -0.5f, -0.5f),\n                    new Vector3f(0.5f, 0.5f, 0.5f)));\n\n        rootNode.attachChild(pCtrl.getGeometry());\n')),Object(o.b)("p",null,"Results in something that looks like this:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.youtube.com/watch?v=WGR5RzF9APg"}),"Video: Particle Emitter Example\n3"))),Object(o.b)("p",null,"You can see that while dramatic the fire is left behind each particle,\nthis is because although it is emitted from the face of the particle at\nits current position it has no knowledge of how that particle is moving."),Object(o.b)("p",null,"To allow for this we also offer a different emitter, this allows one\nParticleController to act as the source for another. The emitted\nparticles are then able to start with the same velocity and rotation of\nthe particle they are being emitted from and then move onwards from\nthere as appropriate."),Object(o.b)("p",null,"Leave everything else the same but change the MeshSource into"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"                new ParticleParticleSource(rockCtrl),\n")),Object(o.b)("p",null,"You can see that this gives much better results:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.youtube.com/watch?v=2BlBZVM0EZQ"}),"Video: Particle Emitter Example\n4"))),Object(o.b)("p",null,"There is a lot of falling rocks and fire here, but not much in the way\nof smoke. That could be added using a multi-colour emitter as\npreviously, but the standard particle material is additive. That means\nit can only make colours brighter, never darker. For smoke it should be\nable to darken as well as lighten."),Object(o.b)("p",null,"To add smoke we can add a third emitter after the other two:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'// Construct a new material for the smoke based off the default particle material\n        Material smokeMat = new Material(\n               assetManager, "Common/MatDefs/Misc/Particle.j3md");\n// The Smoke.png texture can be found in the jme3 test data\n        smokeMat.setTexture("Texture",\n            assetManager.loadTexture("Textures/Smoke.png"));\n// Set the blend mode to Alpha rather than AlphaAdditive so that dark smoke\n// can darken the scene behind it\n        smokeMat.getAdditionalRenderState().setBlendMode(RenderState.BlendMode.Alpha);\n// For point sprite meshes this parameter must be set\n        smokeMat.setBoolean("PointSprite", true);\n\n// Construct the new particle controller\n        pCtrl = new ParticleController(\n                "TemplateSmoke",\n// The Smoke.png texture contains 15 sprites, if you use a different texture adjust\n// these parameters accordingly.\n                new PointMesh(smokeMat, 15, 1),\n                800,\n                4,\n                5,\n                new ParticleParticleSource(rockCtrl),\n                new RegularEmission(180),\n                new SizeInfluencer(1f, 2.5f),\n                new MultiColorInfluencer(\n                    new MultiColorInfluencer.Stage(0, new ColorRGBA(1, 1, 1, 0)),\n                    new MultiColorInfluencer.Stage(0.5f, new ColorRGBA(0, 0, 0, 0.5f)),\n                    new MultiColorInfluencer.Stage(1, new ColorRGBA(1, 1, 1, 0))),\n                new GravityInfluencer(new Vector3f(0, 0.75f, 0)),\n                new RandomImpulseInfluencer(\n                    RandomImpulseInfluencer.ImpulseApplicationTime.INITIALIZE,\n                    new Vector3f(-0.5f, -0.5f, -0.5f),\n                    new Vector3f(0.5f, 0.5f, 0.5f)));\n\n        rootNode.attachChild(pCtrl.getGeometry());\n')),Object(o.b)("p",null,"The results look something like:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.youtube.com/watch?v=01qCBGBvf-c"}),"Video: Particle Emitter Example\n5"))),Object(o.b)("p",null,"To complete the effect one final line of code adds a skybox (using\nanother texture that can be find in the test data):"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'        rootNode.attachChild(SkyFactory.createSky(assetManager, "Textures/BrightSky.dds", false));\n')),Object(o.b)("p",null,"Now we have the final effect which looks like:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.youtube.com/watch?v=uDeWAjw4LxU"}),"Video: Particle Emitter Example\n6"))))}h.isMDXComponent=!0},441:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return d}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=r.a.createContext({}),h=function(e){var t=r.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l({},t,{},e)),n},u=function(e){var t=h(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},p=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=h(n),p=a,d=u["".concat(i,".").concat(p)]||u[p]||m[p]||o;return n?r.a.createElement(d,l({ref:t},c,{components:n})):r.a.createElement(d,l({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);