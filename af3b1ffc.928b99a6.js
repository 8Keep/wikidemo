(window.webpackJsonp=window.webpackJsonp||[]).push([[205],{344:function(e,a,t){"use strict";t.r(a),t.d(a,"frontMatter",(function(){return s})),t.d(a,"metadata",(function(){return l})),t.d(a,"rightToc",(function(){return i})),t.d(a,"default",(function(){return p}));var n=t(1),o=t(9),r=(t(0),t(441)),s={},l={id:"jme3/advanced/spatial",title:"spatial",description:"This is an introduction to the concept of Spatials, the elements of the",source:"@site/docs/jme3/advanced/spatial.md",permalink:"/wikidemo/docs/jme3/advanced/spatial",editUrl:"https://github.com/8keep/wikidemo/edit/master/docs/jme3/advanced/spatial.md"},i=[{value:"Mesh",id:"mesh",children:[]}],c={rightToc:i};function p(e){var a=e.components,t=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(n.a)({},c,t,{components:a,mdxType:"MDXLayout"}),Object(r.b)("p",null,"This is an introduction to the concept of Spatials, the elements of the\n3D scene graph. The scene graph is a data structure that manages all\nobjects in your 3D world. For example, the scene graph keeps track of\nthe 3D models that you load and position. When you extend a Java class\nfrom com.jme3.app.SimpleApplication, you automatically inherit the scene\ngraph and its rootNode."),Object(r.b)("p",null,"The rootNode is the central element of the scene graph. Even if the\nscene graph is empty, it always contains at least the rootNode. We\n",Object(r.b)("em",{parentName:"p"},"attach")," Spatials to the rootNode. Attached Spatials are always in a\n",Object(r.b)("em",{parentName:"p"},"parent-child relationship"),". Every time you attach a Spatial to\nsomething, it is implicitly detached from its previous parent. A Spatial\ncan have only one parent. A Spatial can have several children."),Object(r.b)("p",null,"If you think you need to understand the scene graph concept better,\nplease read ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/scenegraph_for_dummies"}),"Scenegraph for\ndummies")," first."),Object(r.b)("h1",{id:"node-versus-geometry"},"Node versus Geometry"),Object(r.b)("p",null,"In your Java code, a Spatial is either an instance of\n",Object(r.b)("inlineCode",{parentName:"p"},"com.jme3.scene.Node")," or a ",Object(r.b)("inlineCode",{parentName:"p"},"com.jme3.scene.Geometry")," instance. You use\nthe two types of Spatials for different purposes:"),Object(r.b)("p",null,Object(r.b)("img",Object(n.a)({parentName:"p"},{src:"/images/jme3/intermediate/scene-graph.png",alt:"scene-graph.png"}))),Object(r.b)("p",null,"+------+-------------------------------+-------------------------------+\n|      | com.jme3.scene.Spatial        |                               |\n+======+===============================+===============================+\n| Purp | A Spatial is an abstract data |                               |\n| ose: | structure that stores user    |                               |\n|      | data and transformations (=   |                               |\n|      | translation, rotation, scale) |                               |\n|      | of elements of the 3D scene   |                               |\n|      | graph. Spatials can be saved  |                               |\n|      | and loaded using the ","[Asset   |                               |\n|      | Manager]","(../../jme3           |                               |\n|      | /advanced/asset_manager). |                               |\n+------+-------------------------------+-------------------------------+\n|      | com.jme3.scene.Geometry       | com.jme3.scene.Node           |\n+------+-------------------------------+-------------------------------+\n| Vis  | A Geometry represents a       | A Node is an ",Object(r.b)("strong",{parentName:"p"},"invisible      |\n| ibil | "),"visible",Object(r.b)("strong",{parentName:"p"},' 3D object in the  | "handle')," for a group of      |\n| ity: | scene graph.                  | Spatials in the scene graph.  |\n+------+-------------------------------+-------------------------------+\n| Purp | Use Geometries to represent   | Use Nodes to ",Object(r.b)("strong",{parentName:"p"},"structure and  |\n| ose: | an object's "),"look",Object(r.b)("strong",{parentName:"p"},": Every   | group")," Geometries and other  |\n|      | Geometry contains a polygon   | Nodes. Every Node is attached |\n|      | mesh and a material,          | to one parent node, and each  |\n|      | specifying its shape, color,  | node can have zero or more    |\n|      | texture, and                  | children (Nodes or            |\n|      | opacity/transparency.\\        | Geometries) attached to       |\n|      | You attach Geometries to      | itself.\\                      |\n|      | Nodes.                        | ",Object(r.b)("strong",{parentName:"p"},"When you transform (move,   |\n|      |                               | rotate, etc) a parent node,   |\n|      |                               | all its children are          |\n|      |                               | transformed (moved, rotated,  |\n|      |                               | etc)."),"                       |\n+------+-------------------------------+-------------------------------+\n| Cont | Transformations; custom user  | Transformations; custom user  |\n| ent: | data;\\                        | data;\\                        |\n|      | mesh and material;            | no mesh, no material.         |\n+------+-------------------------------+-------------------------------+\n| E    | Box, sphere, player,          | rootNode, guiNode, audioNode, |\n| xamp | building, terrain, vehicle,   | a custom grouping node such   |\n| les: | missiles, NPCs, etc...        | as vehicleNode or shipNode    |\n|      |                               | with passengers attached,     |\n|      |                               | etc.                          |\n+------+-------------------------------+-------------------------------+"),Object(r.b)("p",null,"::: {.important}\nYou never create a Spatial with ",Object(r.b)("inlineCode",{parentName:"p"},"Spatial s = new Spatial();"),'! A Spatial\nis an abstract concept, like a mammal (there is no actual creature\ncalled "mammal walking around here). You create either a\ncom.jme3.scene.Node or com.jme3.scene.Geometry instance. Some methods,\nhowever, require a ',Object(r.b)("inlineCode",{parentName:"p"},"Spatial")," type as argument: This is because they are\nable to accept both Nodes and Geometries as arguments. In this case, you\nsimply ",Object(r.b)("em",{parentName:"p"},"cast")," a Node or Geometry to Spatial.\n:::"),Object(r.b)("h2",{id:"mesh"},"Mesh"),Object(r.b)("p",null,"The polygon ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/advanced/mesh"}),"Mesh")," inside a Geometry can\nbe one of three things:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"Shapes:")," The simplest type of Meshes are jME's default\n",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/advanced/shape"}),"Shape"),"s such as cubes and spheres.\nYou can use several Shapes to build complex Geometries. Shapes are\nbuilt-in and can be created without using the AssetManager.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"3D Models:")," ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/advanced/3d_models"}),"3D models and\nscenes")," are also made up of\nmeshes, but are more complex than Shapes. You create Models and\nScenes in external 3D Mesh Editors and export them as Ogre XML or\nWavefront OBJ. Use the ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/advanced/asset_manager"}),"Asset\nManager")," to load models into\na your jME3 game.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"Custom Meshes:")," Advanced users can create ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/advanced/custom_meshes"}),"Custom\nMeshes")," programmatically."))),Object(r.b)("h1",{id:"what-is-a-clone"},"What is a Clone?"),Object(r.b)("p",null,"Cloned spatials share the same mesh, while each cloned spatial can have\nits own local transformation (translation, rotation, and scale) in the\nscene. This means you only use ",Object(r.b)("inlineCode",{parentName:"p"},"clone()")," on spatials whose meshes never\nchange. The most common use case for cloning is when you use several\nSpatials that are based on the same\n",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/advanced/shape"}),"Shape"),"s (e.g. trees, crates)."),Object(r.b)("p",null,"The second use case is: When you load a model using ",Object(r.b)("inlineCode",{parentName:"p"},"loadModel()")," from\nthe AssetManager, you may automatically get a ","`","clone()","`","ed object. In\nparticular:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"If the model is not animated (it has no ",Object(r.b)("inlineCode",{parentName:"p"},"AnimControl"),"), jME loads a\nclone. All clones share one mesh object in order to use less memory.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"If the model is animated (it has a ",Object(r.b)("inlineCode",{parentName:"p"},"AnimControl"),"), then\n",Object(r.b)("inlineCode",{parentName:"p"},"loadModel()")," duplicates the mesh for each loaded instance. (Uses\nmore memory, but can animate.)"))),Object(r.b)("p",null,"Usually there is no need to manually use any of the ",Object(r.b)("inlineCode",{parentName:"p"},"clone()")," methods on\nmodels. Using the ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/advanced/asset_manager"}),"Asset\nManager"),"\\'s ",Object(r.b)("inlineCode",{parentName:"p"},"loadModel()")," method\nwill automatically do the right thing for your models."),Object(r.b)("p",null,'::: {.note}\n"Box worlds are not made up of statically cloned ',Object(r.b)("inlineCode",{parentName:"p"},"Box()")," shapes, this\nwould still be too slow for large worlds. To learn how to make real fast\nbox worlds, search the web for ",Object(r.b)("em",{parentName:"p"},"voxelization")," techniques.\n:::"),Object(r.b)("h1",{id:"how-to-add-fields-and-methods-to-a-spatial"},"How to Add Fields and Methods to a Spatial"),Object(r.b)("p",null,"You can include custom user data --that is, custom Java objects and\nmethods-- in Nodes and Geometries. This is very useful for maintaining\ninformation about a game element, such as health, budget, ammunition,\ninventory, equipment, etc for players, or landmark locations for\nterrains, and much more."),Object(r.b)("p",null,"::: {.important}\nYou want to add custom accessor methods to a spatial? Do not extend\n",Object(r.b)("inlineCode",{parentName:"p"},"Node")," or ",Object(r.b)("inlineCode",{parentName:"p"},"Geometry"),", use ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/advanced/custom_controls"}),"Custom\nControls")," instead. You want to\nadd custom fields to a spatial? Do not extend ",Object(r.b)("inlineCode",{parentName:"p"},"Node")," or ",Object(r.b)("inlineCode",{parentName:"p"},"Geometry"),", use\nthe built-in ",Object(r.b)("inlineCode",{parentName:"p"},"setUserData()")," method instead. Where ever the Spatial is\naccessible, you can easily access the object's class fields (user data)\nand accessors (control methods) this way.\n:::"),Object(r.b)("p",null,"This first example adds an integer field named ",Object(r.b)("inlineCode",{parentName:"p"},"health")," to the Spatial\n",Object(r.b)("inlineCode",{parentName:"p"},"playerNode"),", and initializes it to 100."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'playerNode.setUserData("health", 100);\n')),Object(r.b)("p",null,"The second example adds a set of custom accessor methods to the player\nobject. You create a ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/advanced/custom_controls"}),"custom PlayerControl()\nclass")," and you add this control\nto the Spatial:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"playerNode.addControl(new PlayerControl());\n")),Object(r.b)("p",null,"In your PlayerControl() class, you define custom methods that set and\nget your user data in the ",Object(r.b)("inlineCode",{parentName:"p"},"spatial")," object. For example, the control\ncould add accessors that set and get the player's health:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'public int getHealth() {\n  return (Integer)spatial.getUserData("health");\n}\npublic void setHealth(int h) {\n  spatial.setUserData("health",h);\n}\n')),Object(r.b)("p",null,"Elsewhere in your code, you can access this data wherever you have\naccess to the Spatial ",Object(r.b)("inlineCode",{parentName:"p"},"playerNode"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"health = playerNode.getControl(PlayerControl.class).getHealth();\n...\nplayerNode.getControl(PlayerControl.class).setHealth(99);\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"You can add as many data objects (of String, Boolean, Integer,\nFloat, Array types) to a Spatial as you want. Just make sure to\nlabel them with unique case-sensitive strings (",Object(r.b)("inlineCode",{parentName:"p"},"health"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"Inventory"),", ",Object(r.b)("inlineCode",{parentName:"p"},"equipment"),", etc).")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"The saved data can even be a custom Java object if you make the\ncustom Java class ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/advanced/save_and_load.xml#custom_savable_class"}),"implement the Savable\ninterface"),"!")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"When you save a Spatial as a .j3o file, the custom data is saved,\ntoo, and all Savables are restored the next time you load the .j3o!"))),Object(r.b)("p",null,"This is how you list all data keys that are already defined for one\nSpatial:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'for(String key : spatial.getUserDataKeys()){\n    System.out.println(spatial.getName()+"\'s keys: "+key);\n}\n')),Object(r.b)("h1",{id:"how-to-access-a-named-sub-mesh"},"How to Access a Named Sub-Mesh"),Object(r.b)("p",null,"Often after you load a scene or model, you need to access a part of it\nas an individual Geometry in the scene graph. Maybe you want to swap a\ncharacter's weapon, or you want to play a door-opening animation. First\nyou need to know the unique name of the sub-mesh."),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Open the model in a 3D mesh editor, or in the jMonkeyEngine SDK's\nScene Composer.")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Find out the existing names of sub-meshes in the model.")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Assign unique names to sub-meshes in the model if neccessary."))),Object(r.b)("p",null,"In the following example, the Node ",Object(r.b)("inlineCode",{parentName:"p"},"house")," is the loaded model. The\nsub-meshes in the Node are called its children. The String, here\n",Object(r.b)("inlineCode",{parentName:"p"},"door 12"),", is the name of the mesh that you are searching."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'Geometry submesh = (Geometry) houseScene.getChild("door 12");\n')),Object(r.b)("h1",{id:"what-is-culling"},"What is Culling?"),Object(r.b)("p",null,"There are two types of culling: Face culling, and view frustrum culling."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Face culling")," means not drawing certain polygons of a mesh. Face\nculling behaviour is a property of the material."),Object(r.b)("p",null,'Usage: The "inside of a mesh (the so called backface) is typically never\nvisible to the player, and as an optimization, the ',Object(r.b)("inlineCode",{parentName:"p"},"Back")," mode skips\ncalculating all backfaces by default. Activating the ",Object(r.b)("inlineCode",{parentName:"p"},"Off")," or ",Object(r.b)("inlineCode",{parentName:"p"},"Front"),"\nmodes can be useful when you are debugging ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/advanced/custom_meshes"}),"custom\nmeshes")," and try to identify\naccidental inside-out faces."),Object(r.b)("p",null,"You can switch the com.jme3.material.RenderState.FaceCullMode to either:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"FaceCullMode.Back")," (default) -- Only the frontsides of a mesh are\ndrawn. Backface culling is the default behaviour.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"FaceCullMode.Front"),' -- Only the backsides of a mesh are drawn. A\nmesh with frontface culling will most likely be invisible. Used for\ndebugging "inside-out custom meshes.')),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"FaceCullMode.FrontAndBack")," -- Use this to make a mesh temporarily\ninvisible.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"FaceCullMode.Off")," -- Every side of the mesh is drawn. Looks normal,\nbut slows down large scenes."))),Object(r.b)("p",null,"Example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"material.getAdditionalRenderState().setFaceCullMode(FaceCullMode.FrontAndBack);\n")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"View frustum culling"),' refers to not drawing (and not even\ncalculating) certain whole models in the scene. At any given moment,\nhalf of the scene is behind the player and out of sight anyway. View\nfrustum culling is an optimization to not calculate scene elements that\nare not visible -- elements that are "outside the view frustrum.'),Object(r.b)("p",null,"The decision what is visible and what not, is done automatically by the\nengine (",Object(r.b)("inlineCode",{parentName:"p"},"CullHint.Dynamic"),"). Optionally, you can manually control\nwhether the engine culls individual spatials (and children) from the\nscene graph:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"CullHint.Dynamic")," -- Default, faster because it doesn't waste time\nwith objects that are out of view.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"CullHint.Never")," -- Calculate and draw everything always (even if it\ndoes not end up on the user's screen because it's out of sight).\nSlower, but can be used while debugging custom meshes.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"CullHint.Always")," -- The whole spatial is culled and is not visible.\nA fast way to hide a Spatial temporarily. Culling a Spatial is\nfaster then detaching it, but it uses more memory.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"CullHint.Inherit")," -- Inherit culling behaviour from parent node."))),Object(r.b)("p",null,"Example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"spatial.setCullHint(CullHint.Never); // always drawn\n")),Object(r.b)("h1",{id:"see-also"},"See also"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/intermediate/optimization"}),"Optimization")," -- The\nGeometryBatchFactory class batches several Geometries into meshes\nwith each their own texture.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"../../jme3/advanced/traverse_scenegraph"}),"Traverse SceneGraph"),"\n-- Find any Node or Geometry in the scenegraph."))))}p.isMDXComponent=!0},441:function(e,a,t){"use strict";t.d(a,"a",(function(){return b})),t.d(a,"b",(function(){return u}));var n=t(0),o=t.n(n);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function s(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function l(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?s(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function i(e,a){if(null==e)return{};var t,n,o=function(e,a){if(null==e)return{};var t,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||(o[t]=e[t]);return o}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=o.a.createContext({}),p=function(e){var a=o.a.useContext(c),t=a;return e&&(t="function"==typeof e?e(a):l({},a,{},e)),t},b=function(e){var a=p(e.components);return o.a.createElement(c.Provider,{value:a},e.children)},m={inlineCode:"code",wrapper:function(e){var a=e.children;return o.a.createElement(o.a.Fragment,{},a)}},d=Object(n.forwardRef)((function(e,a){var t=e.components,n=e.mdxType,r=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),b=p(t),d=n,u=b["".concat(s,".").concat(d)]||b[d]||m[d]||r;return t?o.a.createElement(u,l({ref:a},c,{components:t})):o.a.createElement(u,l({ref:a},c))}));function u(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var r=t.length,s=new Array(r);s[0]=d;var l={};for(var i in a)hasOwnProperty.call(a,i)&&(l[i]=a[i]);l.originalType=e,l.mdxType="string"==typeof e?e:n,s[1]=l;for(var c=2;c<r;c++)s[c]=t[c];return o.a.createElement.apply(null,s)}return o.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"}}]);